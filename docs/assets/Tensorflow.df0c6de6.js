var g3=Object.defineProperty;var Fd=Object.getOwnPropertySymbols;var y3=Object.prototype.hasOwnProperty,_3=Object.prototype.propertyIsEnumerable;var Od=(r,e,t)=>e in r?g3(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,Bd=(r,e)=>{for(var t in e||(e={}))y3.call(e,t)&&Od(r,t,e[t]);if(Fd)for(var t of Fd(e))_3.call(e,t)&&Od(r,t,e[t]);return r};import{c as vr,g as x3}from"./commonjsHelpers.0592d25c.js";import{_ as zd}from"./index.283d3aba.js";import{d as Ud,h as Lc,o as Gs,i as Ws,F as Vd,j as b3,n as v3,k as w3,t as Hd,f as S3,l as T3,r as E3,m as kc,p as M3,q as A3,s as I3}from"./vendor.8fb748f5.js";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N3=1e-7,R3=1e-4;class C3{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class $d{refCount(e){return Tn("refCount")}incRef(e){return Tn("incRef")}timerAvailable(){return!0}time(e){return Tn("time")}read(e){return Tn("read")}readSync(e){return Tn("readSync")}numDataIds(){return Tn("numDataIds")}disposeData(e,t){return Tn("disposeData")}write(e,t,n){return Tn("write")}move(e,t,n,s,i){return Tn("move")}memory(){return Tn("memory")}floatPrecision(){return Tn("floatPrecision")}epsilon(){return this.floatPrecision()===32?N3:R3}dispose(){return Tn("dispose")}}function Tn(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z(r,e){if(!r)throw new Error(typeof e=="string"?e:e())}function Pn(r,e,t=""){z(js(r,e),()=>t+` Shapes ${r} and ${e} must match`)}function Dc(r){z(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function io(r,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(r)||Hn(r)&&!t)for(let n=0;n<r.length;++n)io(r[n],e,t);else e.push(r);return e}function Ne(r){if(r.length===0)return 1;let e=r[0];for(let t=1;t<r.length;t++)e*=r[t];return e}function js(r,e){if(r===e)return!0;if(r==null||e==null||r.length!==e.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==e[t])return!1;return!0}function ao(r){return r%1==0}function oo(r,e){return e<=r.length?r:r+" ".repeat(e-r.length)}function L3(r,e){let t=1,n=-1;for(let i=0;i<r.length;++i)if(r[i]>=0)t*=r[i];else if(r[i]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${i}`);n=i}else if(r[i]<0)throw Error(`Shapes can not be < 0. Found ${r[i]} at dim ${i}`);if(n===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${r}`);return r}if(t===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(e%t!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const s=r.slice();return s[n]=e/t,s}function wr(r,e){const t=e.length;return r=r==null?e.map((n,s)=>s):[].concat(r),z(r.every(n=>n>=-t&&n<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${r}`),z(r.every(n=>ao(n)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(n=>n<0?t+n:n)}function k3(r,e){const t=[],n=[],s=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||s?null:wr(e,r).sort();let a=0;for(let o=0;o<r.length;++o){if(i!=null){if(i[a]===o&&r[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${r[o]}' is not 1`);(i[a]==null||i[a]>o)&&r[o]===1&&(t.push(r[o]),n.push(o)),i[a]<=o&&a++}r[o]!==1&&(t.push(r[o]),n.push(o))}return{newShape:t,keptDims:n}}function Gd(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else if(r==="string")t=new Array(e);else throw new Error(`Unknown data type ${r}`);return t}function D3(r,e){for(let t=0;t<r.length;t++){const n=r[t];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${e} being uploaded contains ${n}.`)}}function P3(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function Hn(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray}function co(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function F3(r){if(r==null)return 0;let e=0;return r.forEach(t=>e+=t.length),e}function Pc(r){return typeof r=="string"||r instanceof String}function O3(r){return typeof r=="boolean"}function B3(r){return typeof r=="number"}function Fc(r){return Array.isArray(r)?Fc(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":B3(r)?"float32":Pc(r)?"string":O3(r)?"bool":"float32"}function Wd(r){return!!(r&&r.constructor&&r.call&&r.apply)}function Xt(r){const e=r.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=r[e-1];for(let n=e-3;n>=0;--n)t[n]=t[n+1]*r[n+1];return t}function jd(r,e,t,n=!1){const s=new Array;if(e.length===1){const i=e[0]*(n?2:1);for(let a=0;a<i;a++)s[a]=t[r+a]}else{const i=e[0],a=e.slice(1),o=a.reduce((c,l)=>c*l)*(n?2:1);for(let c=0;c<i;c++)s[c]=jd(r+c*o,a,t,n)}return s}function Oc(r,e,t=!1){if(r.length===0)return e[0];const n=r.reduce((s,i)=>s*i)*(t?2:1);if(n===0)return[];if(n!==e.length)throw new Error(`[${r}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return jd(0,r,e,t)}function qd(r,e){const t=ta(r,e);for(let n=0;n<t.length;n++)t[n]=1;return t}function ta(r,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${e}`)}function Kd(r){r.forEach(e=>{z(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function na(r){return r&&r.then&&typeof r.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xd="tfjsflags";class z3{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=U3,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(nt().getBool("IS_TEST")||nt().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){const s=this.urlFlags[e];nt().getBool("IS_TEST")||nt().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(na(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;const e=this.getQueryParams(this.global.location.search);Xd in e&&e[Xd].split(",").forEach(n=>{const[s,i]=n.split(":");this.urlFlags[s]=H3(s,i)})}}function U3(r){const e={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(V3(e,n[0],n[1]),n.join("="))),e}function V3(r,e,t){r[decodeURIComponent(e)]=decodeURIComponent(t||"")}function H3(r,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${r}.`)}function nt(){return Yd}let Yd=null;function $3(r){Yd=r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Bc;function Jd(){if(Bc==null){let r;if(typeof window!="undefined")r=window;else if(typeof global!="undefined")r=global;else if(typeof process!="undefined")r=process;else if(typeof self!="undefined")r=self;else throw new Error("Could not find a global object");Bc=r}return Bc}function G3(){const r=Jd();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function zc(r,e){const t=G3();if(t.has(r))return t.get(r);{const n=e();return t.set(r,n),t.get(r)}}const Zd="Abs",W3="Acos",j3="Acosh",Uc="Add",Vc="AddN",Hc="All",$c="Any",Gc="ArgMax",q3="ArgMin",K3="Asin",X3="Asinh",Y3="Atan",J3="Atanh",Z3="Atan2",Wc="AvgPool",Q3="AvgPool3D",jc="BatchMatMul",Qd="BatchToSpaceND",ey="Bincount",ty="BroadcastArgs",qc="Cast",ep="Ceil",Kc="ClipByValue",ny="Complex",ry="ComplexAbs",tp="Concat",Xc="Conv2D",sy="Conv2DBackpropFilter",Yc="Conv2DBackpropInput",iy="Conv3D",np="Cos",rp="Cosh",Jc="Cumsum",Zc="CropAndResize",ay="DenseBincount",Qc="DepthToSpace",eu="DepthwiseConv2dNative",oy="DepthwiseConv2dNativeBackpropFilter",cy="DepthwiseConv2dNativeBackpropInput",uy="Dilation2D",sp="RealDiv",ly="Einsum",ip="Elu",hy="Erf",ap="Equal",op="Exp",cp="ExpandDims",dy="Expm1",py="FFT",up="Fill",tu="FlipLeftRight",lp="Floor",hp="FloorDiv",nu="FusedBatchNorm",dp="GatherV2",ru="GatherNd",pp="Greater",fp="GreaterEqual",su="Identity",fy="IFFT",my="Imag",gy="IsNan",iu="LeakyRelu",mp="Less",gp="LessEqual",yy="LinSpace",yp="Log",_y="Log1p",_p="LogicalAnd",xy="LogicalNot",by="LogicalOr",vy="LRN",au="Max",xp="Maximum",ou="MaxPool",wy="MaxPool3D",Sy="MaxPoolWithArgmax",cu="Mean",uu="Min",bp="Minimum",lu="MirrorPad",Ty="Mod",Ey="Multinomial",vp="Multiply",wp="Neg",Sp="NotEqual",hu="NonMaxSuppressionV3",du="NonMaxSuppressionV4",pu="NonMaxSuppressionV5",Tp="OnesLike",fu="OneHot",Ep="Pack",mu="PadV2",Mp="Pow",gu="Prelu",yu="Prod",Ap="Range",My="Real",Ay="Reciprocal",Ip="Relu",Np="Reshape",Iy="ResizeNearestNeighbor",_u="ResizeBilinear",Rp="Relu6",xu="Reverse",Cp="Round",Lp="Rsqrt",bu="ScatterNd",kp="Select",Ny="Selu",Dp="Slice",Pp="Sin",Ry="Sinh",Cy="Sign",Fp="Sigmoid",Ly="Softplus",Op="Sqrt",vu="Sum",Bp="SpaceToBatchND",zp="SplitV",wu="Softmax",Up="SparseFillEmptyRows",Su="SparseReshape",Vp="SparseSegmentMean",Hp="SparseSegmentSum",ky="SparseToDense",$p="SquaredDifference",Dy="Square",Tu="StridedSlice",Py="StringNGrams",Fy="StringSplit",Oy="StringToHashBucketFast",Gp="Sub",Wp="Tan",jp="Tanh",uo="Tile",Eu="TopK",Mu="Transform",Au="Transpose",By="Unique",qp="Unpack",Kp="ZerosLike",Iu="Step",Xp="FromPixels",Nu="RotateWithOffset",lo="_FusedMatMul",ho="FusedConv2D",po="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qs(...r){nt().getBool("IS_TEST")||nt().getBool("PROD")||console.warn(...r)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fo=zc("kernelRegistry",()=>new Map),zy=zc("gradRegistry",()=>new Map);function Ru(r,e){const t=Zp(r,e);return fo.get(t)}function Yp(r){return zy.get(r)}function Jp(r){const e=fo.entries(),t=[];for(;;){const{done:n,value:s}=e.next();if(n)break;const[i,a]=s,[o]=i.split("_");o===r&&t.push(a)}return t}function Uy(r){const{kernelName:e,backendName:t}=r,n=Zp(e,t);fo.has(n)&&qs(`The kernel '${e}' for backend '${t}' is already registered`),fo.set(n,r)}function Zp(r,e){return`${e}_${r}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vy(r,e){return r instanceof Float32Array&&e==="float32"||r instanceof Int32Array&&e==="int32"||r instanceof Uint8Array&&e==="bool"}function Qp(r,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=io(r)),nt().getBool("DEBUG")&&D3(r,e),Vy(r,e))return r;if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool"){const t=new Uint8Array(r.length);for(let n=0;n<t.length;++n)Math.round(r[n])!==0&&(t[n]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Ks(){return nt().platform.now()}function Hy(r,e){return nt().platform.fetch(r,e)}function ef(r,e="utf-8"){return e=e||"utf-8",nt().platform.encode(r,e)}function Cu(r,e="utf-8"){return e=e||"utf-8",nt().platform.decode(r,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $y{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new Wy)}profileKernel(e,t,n){let s;const i=()=>{s=n()};let a;const o=Ks();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(i);else{i();for(const l of s)l.dataSync();a=Promise.resolve({kernelMs:Ks()-o})}if(nt().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<s.length;l++){const u=s[l];u.data().then(h=>{Gy(h,u.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:a.then(l=>l.kernelMs),extraInfo:a.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:s,inputs:i,extraInfo:a}=e;n.forEach(o=>{Promise.all([o.data(),s,a]).then(c=>{this.logger.logKernelProfile(t,o,c[0],c[1],i,c[2])})})}}function Gy(r,e,t){if(e!=="float32")return!1;for(let n=0;n<r.length;n++){const s=r[n];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}class Wy{logKernelProfile(e,t,n,s,i,a){const o=typeof s=="number"?oo(`${s}ms`,9):s.error,c=oo(e,25),l=t.rank,u=t.size,h=oo(t.shape.toString(),14);let d="";for(const p in i){const f=i[p];if(f!=null){const m=f.shape||t.shape,_=m.length;d+=`${p}: ${_}D ${_>0?m:""} `}}console.log(`%c${c}	%c${o}	%c${l}D ${h}	%c${u}	%c${d}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jy(r,e,t){const n={},s={};for(let c=0;c<e.length;c++)n[e[c].id]=!0;for(let c=0;c<r.length;c++){const l=r[c],u=l.inputs;for(const h in u){const d=u[h];let p=!1;for(let f=0;f<e.length;f++)if(n[d.id]){l.outputs.forEach(m=>n[m.id]=!0),p=!0,s[l.id]=!0;break}if(p)break}}const i={};i[t.id]=!0;const a={};for(let c=r.length-1;c>=0;c--){const l=r[c],u=l.inputs;for(let h=0;h<l.outputs.length;h++)if(i[l.outputs[h].id]){for(const d in u)i[u[d].id]=!0,a[l.id]=!0;break}}const o=[];for(let c=0;c<r.length;c++){const l=r[c];if(s[l.id]&&a[l.id]){const u={};for(const d in l.inputs){const p=l.inputs[d];n[p.id]&&(u[d]=p)}const h=Object.assign({},l);h.inputs=u,h.outputs=l.outputs,o.push(h)}}return o}function qy(r,e,t,n){for(let s=e.length-1;s>=0;s--){const i=e[s],a=[];if(i.outputs.forEach(c=>{const l=r[c.id];l!=null?a.push(l):a.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const o=i.gradient(a);for(const c in i.inputs){if(!(c in o))throw new Error(`Cannot backprop through input ${c}. Available gradients found: ${Object.keys(o)}.`);const l=t(()=>o[c]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${c} must have 'float32' dtype, but has '${l.dtype}'`);const u=i.inputs[c];if(!js(l.shape,u.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${c}' has shape '${l.shape}', which does not match the shape of the input '${u.shape}'`);if(r[u.id]==null)r[u.id]=l;else{const h=r[u.id];r[u.id]=n(h,l),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tf=20,ra=3,Lu=7;function Ky(r,e,t,n){const s=Xt(e),i=Xy(r,e,t,s),a=e.length,o=mo(r,e,t,s,i),c=["Tensor"];return n&&(c.push(`  dtype: ${t}`),c.push(`  rank: ${a}`),c.push(`  shape: [${e}]`),c.push("  values:")),c.push(o.map(l=>"    "+l).join(`
`)),c.join(`
`)}function Xy(r,e,t,n){const s=Ne(e),i=n[n.length-1],a=new Array(i).fill(0),o=e.length,c=t==="complex64"?ia(r):r;if(o>1)for(let l=0;l<s/i;l++){const u=l*i;for(let h=0;h<i;h++)a[h]=Math.max(a[h],sa(c[u+h],0,t).length)}return a}function sa(r,e,t){let n;return Array.isArray(r)?n=`${parseFloat(r[0].toFixed(Lu))} + ${parseFloat(r[1].toFixed(Lu))}j`:Pc(r)?n=`'${r}'`:t==="bool"?n=nf(r):n=parseFloat(r.toFixed(Lu)).toString(),oo(n,e)}function nf(r){return r===0?"false":"true"}function mo(r,e,t,n,s,i=!0){const a=t==="complex64"?2:1,o=e[0],c=e.length;if(c===0){if(t==="complex64"){const m=ia(r);return[sa(m[0],0,t)]}return t==="bool"?[nf(r[0])]:[r[0].toString()]}if(c===1){if(o>tf){const _=ra*a;let g=Array.from(r.slice(0,_)),y=Array.from(r.slice((o-ra)*a,o*a));return t==="complex64"&&(g=ia(g),y=ia(y)),["["+g.map((x,w)=>sa(x,s[w],t)).join(", ")+", ..., "+y.map((x,w)=>sa(x,s[o-ra+w],t)).join(", ")+"]"]}const m=t==="complex64"?ia(r):Array.from(r);return["["+m.map((_,g)=>sa(_,s[g],t)).join(", ")+"]"]}const l=e.slice(1),u=n.slice(1),h=n[0]*a,d=[];if(o>tf){for(let m=0;m<ra;m++){const _=m*h,g=_+h;d.push(...mo(r.slice(_,g),l,t,u,s,!1))}d.push("...");for(let m=o-ra;m<o;m++){const _=m*h,g=_+h;d.push(...mo(r.slice(_,g),l,t,u,s,m===o-1))}}else for(let m=0;m<o;m++){const _=m*h,g=_+h;d.push(...mo(r.slice(_,g),l,t,u,s,m===o-1))}const p=c===2?",":"";d[0]="["+d[0]+p;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=`,
`;for(let m=2;m<c;m++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(i?"":f),d}function ia(r){const e=[];for(let t=0;t<r.length;t+=2)e.push([r[t],r[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ku{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Ne(e),n!=null){const s=n.length;z(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Gd(t,this.size),this.strides=Xt(e)}set(e,...t){t.length===0&&(t=[0]),z(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const s of e){if(s<0||s>=this.shape[t]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}t++}let n=e[e.length-1];for(let s=0;s<e.length-1;++s)n+=this.strides[s]*e[s];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return $n().makeTensor(this.values,this.shape,this.dtype)}}let $n=null,Xs=null;function Yy(r){$n=r}function Jy(r){Xs=r}class At{constructor(e,t,n,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Ne(e),this.strides=Xt(e),this.dataId=n,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Xs.buffer(this.shape,this.dtype,e)}bufferSync(){return Xs.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Oc(this.shape,e,this.dtype==="complex64")}arraySync(){return Oc(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=$n().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(n=>Cu(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();const e=$n().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Cu(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await $n().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||($n().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Xs.print(this,e)}clone(){return this.throwIfDisposed(),Xs.clone(this)}toString(e=!1){const t=this.dataSync();return Ky(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Xs.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),$n().makeVariable(this,e,t,n)}}Object.defineProperty(At,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function Zy(){return zc("Tensor",()=>At)}Zy();class Du extends At{constructor(e,t,n,s){super(e.shape,e.dtype,e.dataId,s);this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!js(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);$n().disposeTensor(this),this.dataId=e.dataId,$n().incRef(this,null)}dispose(){$n().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Du,Symbol.hasInstance,{value:r=>r instanceof At&&r.assign!=null&&r.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var rf;(function(r){r.R0="R0",r.R1="R1",r.R2="R2",r.R3="R3",r.R4="R4",r.R5="R5",r.R6="R6"})(rf||(rf={}));var Pu;(function(r){r.float32="float32",r.int32="int32",r.bool="int32",r.complex64="complex64"})(Pu||(Pu={}));var Fu;(function(r){r.float32="float32",r.int32="int32",r.bool="bool",r.complex64="complex64"})(Fu||(Fu={}));var Ou;(function(r){r.float32="float32",r.int32="float32",r.bool="float32",r.complex64="complex64"})(Ou||(Ou={}));var Bu;(function(r){r.float32="complex64",r.int32="complex64",r.bool="complex64",r.complex64="complex64"})(Bu||(Bu={}));const Qy={float32:Ou,int32:Pu,bool:Fu,complex64:Bu};function e4(r,e){if(r==="string"||e==="string"){if(r==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${r} with ${e}`)}return Qy[r][e]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tt(r,e){if(r.dtype===e.dtype)return[r,e];const t=e4(r.dtype,e.dtype);return[r.cast(t),e.cast(t)]}function sf(r){const e=[],t=new Set;return af(r,e,t),e}function af(r,e,t){if(r==null)return;if(r instanceof At){e.push(r);return}if(!t4(r))return;const n=r;for(const s in n){const i=n[s];t.has(i)||(t.add(i),af(i,e,t))}}function t4(r){return Array.isArray(r)||typeof r=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zu(r){return r.kernelName!=null}class of{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Ys{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new of}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(qs(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new $y(this.backendInstance),!0}setupRegisteredKernels(){Jp(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Jp(e).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(n&&!(n instanceof $d)&&typeof n.then=="function"){const s=++this.pendingBackendInitId,i=n.then(a=>s<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,qs(`Initialization of backend ${e} failed`),qs(a.stack||a.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(n){return qs(`Initialization of backend ${e} failed`),qs(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:s,asyncInit:i}=this.initializeBackend(n);if(i||s)return{name:n,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),s=n.backend,i=this.readSync(t),a=s.refCount(t);s.disposeData(t,!0),n.backend=e,e.move(t,i,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}let s;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(s),()=>(s=t(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,t,n){e();try{const s=n();return t(),s}catch(s){throw t(),s}}nextTensorId(){return Ys.nextTensorId++}nextVariableId(){return Ys.nextVariableId++}clone(e){const t=G.runKernel(su,{x:e}),n={x:e},s=a=>({x:()=>{const o="float32",c={x:a},l={dtype:o};return G.runKernel(qc,c,l)}}),i=[];return this.addTapeNode(this.state.activeScope.name,n,[t],s,i,{}),t}runKernel(e,t,n){if(this.backendName==null&&this.backend,!(Ru(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const s=this.backend.numDataIds();let i=0;n.forEach(c=>{i+=c.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=s-t-i-a;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const s=this.isTapeOn(),i=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let c;const l=zu(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(zu(e)){const{kernelName:f,inputs:m,attrs:_}=e;this.backendName==null&&this.backend;const g=Ru(f,this.backendName);z(g!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),o=()=>{const y=this.backend.numDataIds();c=g.kernelFunc({inputs:m,attrs:_,backend:this.backend});const x=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,y,x);const w=x.map(T=>{if(T.rank!=null)return T;const{dataId:M,shape:S,dtype:R}=T;return this.makeTensorFromDataId(M,S,R)});if(s){const T=this.getTensorsForGradient(f,m,w);n=this.saveTensorsForBackwardMode(T)}return w}}else{const{forwardFunc:f}=e,m=_=>{!s||(n=_.map(g=>this.keep(this.clone(g))))};o=()=>{const _=this.backend.numDataIds();c=this.tidy(()=>f(this.backend,m));const g=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,_,g),g}}const{inputs:u,attrs:h}=e,d=zu(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=o():(p=this.profiler.profileKernel(l,u,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs)}),s&&this.addTapeNode(l,u,t,d,n,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(f=>u[f]!=null?u[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(c)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(e,t,n){const s=Yp(e);if(s!=null){const i=s.inputsToSave||[],a=s.outputsToSave||[];let o;s.saveAllInputs?(z(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(t).map(l=>t[l])):o=i.map(l=>t[l]);const c=n.filter((l,u)=>a[u]);return o.concat(c)}return[]}makeTensor(e,t,n,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",s=s||this.backend;let i=e;n==="string"&&Pc(e[0])&&(i=e.map(c=>ef(c)));const a=s.write(i,t,n),o=new At(t,n,a,this.nextTensorId());if(this.trackTensor(o,s),n==="string"){const c=this.state.tensorInfo.get(a),l=F3(i);this.state.numBytes+=l-c.bytes,c.bytes=l}return o}makeTensorFromDataId(e,t,n,s){n=n||"float32";const i=new At(t,n,e,this.nextTensorId());return this.trackTensor(i,s),i}makeVariable(e,t=!0,n,s){n=n||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const i=new Du(e,t,n,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let n=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(n=e.size*co(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Du||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const n=e.size*co(e.dtype);this.state.numBytes-=n}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,s,i,a){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:i},c=Yp(e);c!=null&&(s=c.gradFunc),s!=null&&(o.gradient=l=>(l=l.map((u,h)=>{if(u==null){const d=n[h],p=ta(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return u}),s(l.length>1?l:l[0],i,a))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=sf(e),n=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const a=this.state.activeScope.track[i];!a.kept&&!n.has(a.id)&&a.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===s.id&&this.track(i)})}gradients(e,t,n,s=!1){if(z(t.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));z(i instanceof At,()=>"The result y returned by f() must be a tensor.");const a=jy(this.state.activeTape,t,i);if(!s&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[i.id]=n==null?n4(i.shape):n,qy(o,a,l=>this.tidy(l),r4);const c=t.map(l=>o[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const u of l.saved)u.dispose()}),this.state.activeTape=null),{value:i,grads:c}})}customGrad(e){return z(Wd(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{z(t.every(o=>o instanceof At),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n;const s={};t.forEach((o,c)=>{s[c]=o});const i=(o,c)=>(n=e(...t,c),z(n.value instanceof At,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),z(Wd(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),a=(o,c)=>{const l=n.gradFunc(o,c),u=Array.isArray(l)?l:[l];z(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),z(u.every(d=>d instanceof At),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return u.forEach((d,p)=>{h[p]=()=>d}),h};return this.runKernelFunc({forwardFunc:i,backwardsFunc:a,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){const t=Ks(),n=await this.backend.time(e);return n.wallMs=Ks()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new of;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Ys.nextTensorId=0;Ys.nextVariableId=0;function n4(r){const e=qd(Ne(r),"float32");return G.makeTensor(e,r,"float32")}function cf(){const r=Jd();if(r._tfengine==null){const e=new z3(r);r._tfengine=new Ys(e)}return $3(r._tfengine.ENV),Yy(()=>r._tfengine),r._tfengine}const G=cf();function r4(r,e){const t={a:r,b:e};return G.runKernel(Uc,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s4(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fn=nt();Fn.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Fn.registerFlag("IS_BROWSER",()=>s4());Fn.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");Fn.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Fn.registerFlag("PROD",()=>!1);Fn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Fn.getBool("DEBUG"));Fn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Fn.registerFlag("IS_TEST",()=>!1);Fn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);Fn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aa(r,e){let t=r;if(Hn(r))return e==="string"?[]:[r.length];if(!Array.isArray(r))return[];const n=[];for(;Array.isArray(t)||Hn(t)&&e!=="string";)n.push(t.length),t=t[0];return Array.isArray(r)&&nt().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&uf(r,n,[]),n}function uf(r,e,t){if(t=t||[],!Array.isArray(r)&&!Hn(r)){z(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}z(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${r.length} elements`),z(r.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${r.length} elements`);const n=e.slice(1);for(let s=0;s<r.length;++s)uf(r[s],n,t.concat(s))}function lf(r,e,t,n){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==e||r==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${n}' must be ${r} tensor, but got ${e} tensor`)}}function C(r,e,t,n="numeric"){if(r instanceof At)return lf(n,r.dtype,e,t),r;let s=Fc(r);if(s!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(s=n),lf(n,s,e,t),r==null||!Hn(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){const c=r==null?"null":r.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${c}'`)}const i=aa(r,s);!Hn(r)&&!Array.isArray(r)&&(r=[r]);const o=s!=="string"?Qp(r,s):io(r,[],!0);return G.makeTensor(o,i,s)}function hf(r,e,t,n="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((i,a)=>C(i,`${e}[${a}]`,t,n))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i4="__op";function W(r){const e=Object.keys(r);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const n=r[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+i4;const s=(...i)=>{G.startScope(t);try{const a=n(...i);return na(a)&&console.error("Cannot return a Promise inside of tidy."),G.endScope(a),a}catch(a){throw G.endScope(null),a}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a4(r,e){const t=C(r,"real","complex"),n=C(e,"imag","complex");Pn(t.shape,n.shape,`real and imag shapes, ${t.shape} and ${n.shape}, must match in call to tf.complex().`);const s={real:t,imag:n};return G.runKernel(ny,s)}const ss=W({complex_:a4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oa(r,e,t,n){if(n==null&&(n=Fc(r)),n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Hn(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Kd(e);const s=Ne(e),i=Ne(t);z(s===i,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${i}`);for(let a=0;a<t.length;++a){const o=t[a],c=a===t.length-1?o!==Ne(e.slice(a)):!0;z(t[a]===e[a]||!c,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Hn(r)&&!Array.isArray(r)&&(r=[r]),e=e||t,r=n!=="string"?Qp(r,n):io(r,[],!0),G.makeTensor(r,e,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sr(r,e,t){const n=aa(r,t);return oa(r,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const df={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pf=4;function o4(r,e){const t={};let n,s=0;for(const i of e){const a=i.name,o=i.dtype,c=i.shape,l=Ne(c);let u;if("quantization"in i){const h=i.quantization;if(h.dtype==="uint8"||h.dtype==="uint16"){if(!("min"in h&&"scale"in h))throw new Error(`Weight ${i.name} with quantization ${h.dtype} doesn't have corresponding metadata min and scale.`)}else if(h.dtype==="float16"){if(o!=="float32")throw new Error(`Weight ${i.name} is quantized with ${h.dtype} which only supports weights of type float32 not ${o}.`)}else throw new Error(`Weight ${i.name} has unknown quantization dtype ${h.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const d=df[h.dtype],p=r.slice(s,s+l*d),f=h.dtype==="uint8"?new Uint8Array(p):new Uint16Array(p);if(o==="float32")if(h.dtype==="uint8"||h.dtype==="uint16"){u=new Float32Array(f.length);for(let m=0;m<f.length;m++){const _=f[m];u[m]=_*h.scale+h.min}}else if(h.dtype==="float16")n===void 0&&(n=g4()),u=n(f);else throw new Error(`Unsupported quantization type ${h.dtype} for weight type float32.`);else if(o==="int32"){if(h.dtype!=="uint8"&&h.dtype!=="uint16")throw new Error(`Unsupported quantization type ${h.dtype} for weight type int32.`);u=new Int32Array(f.length);for(let m=0;m<f.length;m++){const _=f[m];u[m]=Math.round(_*h.scale+h.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${o}`);s+=l*d}else if(o==="string"){const h=Ne(i.shape);u=[];for(let d=0;d<h;d++){const p=new Uint32Array(r.slice(s,s+pf))[0];s+=pf;const f=new Uint8Array(r.slice(s,s+p));u.push(f),s+=p}}else{const h=df[o],d=r.slice(s,s+l*h);if(o==="float32")u=new Float32Array(d);else if(o==="int32")u=new Int32Array(d);else if(o==="bool")u=new Uint8Array(d);else if(o==="complex64"){u=new Float32Array(d);const p=new Float32Array(u.length/2),f=new Float32Array(u.length/2);for(let g=0;g<p.length;g++)p[g]=u[g*2],f[g]=u[g*2+1];const m=Sr(p,c,"float32"),_=Sr(f,c,"float32");t[a]=ss(m,_),m.dispose(),_.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${o}`);s+=l*h}o!=="complex64"&&(t[a]=Sr(u,c,o))}return t}const Uu=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function ff(r){return Uu?Buffer.byteLength(r):new Blob([r]).size}function c4(r){if(Uu)return Buffer.from(r).toString("base64");const e=new Uint8Array(r);let t="";for(let n=0,s=e.length;n<s;n++)t+=String.fromCharCode(e[n]);return btoa(t)}function u4(r){if(Uu){const n=Buffer.from(r,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}const e=atob(r),t=new Uint8Array(e.length);for(let n=0;n<e.length;++n)t.set([e.charCodeAt(n)],n);return t.buffer}function l4(r){if(r.length===1)return r[0];let e=0;r.forEach(s=>{e+=s.byteLength});const t=new Uint8Array(e);let n=0;return r.forEach(s=>{t.set(new Uint8Array(s),n),n+=s.byteLength}),t.buffer}function h4(r,e){const t={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:e};return r.signature!=null&&(t.signature=r.signature),r.userDefinedMetadata!=null&&(t.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(t.modelInitializer=r.modelInitializer),r.trainingConfig!=null&&(t.trainingConfig=r.trainingConfig),t}async function d4(r,e){const t={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(t.trainingConfig=r.trainingConfig),r.weightsManifest!=null){const[n,s]=await e(r.weightsManifest);t.weightSpecs=n,t.weightData=s}return r.signature!=null&&(t.signature=r.signature),r.userDefinedMetadata!=null&&(t.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(t.modelInitializer=r.modelInitializer),t}function Vu(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:ff(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:ff(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:r.weightData.byteLength}}function p4(){const r=t=>{let n=t<<13,s=0;for(;(n&8388608)==0;)s-=8388608,n<<=1;return n&=~8388608,s+=947912704,n|s},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=r(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function f4(){const r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let e=1;e<31;e++)r[e]=e<<23;for(let e=33;e<63;e++)r[e]=2147483648+(e-32<<23);return r}function m4(){const r=new Uint32Array(64);for(let e=0;e<64;e++)r[e]=1024;return r[0]=r[32]=0,r}function g4(){const r=p4(),e=f4(),t=m4();return n=>{const s=new ArrayBuffer(4*n.length),i=new Uint32Array(s);for(let a=0;a<n.length;a++){const o=n[a],c=r[t[o>>10]+(o&1023)]+e[o>>10];i[a]=c}return new Float32Array(s)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ft{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Ft.instance==null&&(Ft.instance=new Ft),Ft.instance}static registerSaveRouter(e){Ft.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Ft.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Ft.getHandlers(e,"save")}static getLoadHandlers(e,t){return Ft.getHandlers(e,"load",t)}static getHandlers(e,t,n){const s=[];return(t==="load"?Ft.getInstance().loadRouters:Ft.getInstance().saveRouters).forEach(a=>{const o=a(e,n);o!==null&&s.push(o)}),s}}const y4=r=>Ft.getSaveHandlers(r),_4=(r,e)=>Ft.getLoadHandlers(r,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hu="tensorflowjs",$u=1,is="models_store",Tr="model_info_store";function mf(){if(!nt().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const r=typeof window=="undefined"?self:window,e=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Gu(r){const e=r.result;e.createObjectStore(is,{keyPath:"modelPath"}),e.createObjectStore(Tr,{keyPath:"modelPath"})}class as{constructor(e){if(this.indexedDB=mf(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,s)=>{const i=this.indexedDB.open(Hu,$u);i.onupgradeneeded=()=>Gu(i),i.onsuccess=()=>{const a=i.result;if(t==null){const o=a.transaction(is,"readonly"),l=o.objectStore(is).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return a.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(l.result.modelArtifacts)},l.onerror=u=>(a.close(),s(l.error)),o.oncomplete=()=>a.close()}else{const o=Vu(t),c=a.transaction(Tr,"readwrite");let l=c.objectStore(Tr);const u=l.put({modelPath:this.modelPath,modelArtifactsInfo:o});let h;u.onsuccess=()=>{h=a.transaction(is,"readwrite");const p=h.objectStore(is).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o});p.onsuccess=()=>n({modelArtifactsInfo:o}),p.onerror=f=>{l=c.objectStore(Tr);const m=l.delete(this.modelPath);m.onsuccess=()=>(a.close(),s(p.error)),m.onerror=_=>(a.close(),s(p.error))}},u.onerror=d=>(a.close(),s(u.error)),c.oncomplete=()=>{h==null?a.close():h.oncomplete=()=>a.close()}}},i.onerror=a=>s(i.error)})}}as.URL_SCHEME="indexeddb://";const gf=r=>nt().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(as.URL_SCHEME)?x4(r.slice(as.URL_SCHEME.length)):null;Ft.registerSaveRouter(gf);Ft.registerLoadRouter(gf);function x4(r){return new as(r)}function b4(r){return r.startsWith(as.URL_SCHEME)?r.slice(as.URL_SCHEME.length):r}class v4{constructor(){this.indexedDB=mf()}async listModels(){return new Promise((e,t)=>{const n=this.indexedDB.open(Hu,$u);n.onupgradeneeded=()=>Gu(n),n.onsuccess=()=>{const s=n.result,i=s.transaction(Tr,"readonly"),o=i.objectStore(Tr).getAll();o.onsuccess=()=>{const c={};for(const l of o.result)c[l.modelPath]=l.modelArtifactsInfo;e(c)},o.onerror=c=>(s.close(),t(o.error)),i.oncomplete=()=>s.close()},n.onerror=s=>t(n.error)})}async removeModel(e){return e=b4(e),new Promise((t,n)=>{const s=this.indexedDB.open(Hu,$u);s.onupgradeneeded=()=>Gu(s),s.onsuccess=()=>{const i=s.result,a=i.transaction(Tr,"readwrite"),o=a.objectStore(Tr),c=o.get(e);let l;c.onsuccess=()=>{if(c.result==null)return i.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const u=o.delete(e),h=()=>{l=i.transaction(is,"readwrite");const p=l.objectStore(is).delete(e);p.onsuccess=()=>t(c.result.modelArtifactsInfo),p.onerror=f=>n(c.error)};u.onsuccess=h,u.onerror=d=>(h(),i.close(),n(c.error))}},c.onerror=u=>(i.close(),n(c.error)),a.oncomplete=()=>{l==null?i.close():l.oncomplete=()=>i.close()}},s.onerror=i=>n(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qn="/",Js="tensorflowjs_models",yf="info",w4="model_topology",S4="weight_specs",T4="weight_data",E4="model_metadata";function _f(r){return{info:[Js,r,yf].join(Qn),topology:[Js,r,w4].join(Qn),weightSpecs:[Js,r,S4].join(Qn),weightData:[Js,r,T4].join(Qn),modelMetadata:[Js,r,E4].join(Qn)}}function xf(r){for(const e of Object.values(r))window.localStorage.removeItem(e)}function M4(r){const e=r.split(Qn);if(e.length<3)throw new Error(`Invalid key format: ${r}`);return e.slice(1,e.length-1).join(Qn)}function A4(r){return r.startsWith(os.URL_SCHEME)?r.slice(os.URL_SCHEME.length):r}class os{constructor(e){if(!nt().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=_f(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),s=Vu(e);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,c4(e.weightData));const i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:s}}catch{throw xf(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=s;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const o=JSON.parse(i);t.format=o.format,t.generatedBy=o.generatedBy,t.convertedBy=o.convertedBy,o.signature!=null&&(t.signature=o.signature),o.userDefinedMetadata!=null&&(t.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(t.modelInitializer=o.modelInitializer),o.trainingConfig!=null&&(t.trainingConfig=o.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=u4(a),t}}os.URL_SCHEME="localstorage://";const bf=r=>nt().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(os.URL_SCHEME)?I4(r.slice(os.URL_SCHEME.length)):null;Ft.registerSaveRouter(bf);Ft.registerLoadRouter(bf);function I4(r){return new os(r)}class N4{constructor(){z(nt().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),z(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Js+Qn,n=Qn+yf;for(let s=0;s<this.LS.length;++s){const i=this.LS.key(s);if(i.startsWith(t)&&i.endsWith(n)){const a=M4(i);e[a]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=A4(e);const t=_f(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const n=JSON.parse(this.LS.getItem(t.info));return xf(t),n}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vf="://";class Er{constructor(){this.managers={}}static getInstance(){return Er.instance==null&&(Er.instance=new Er),Er.instance}static registerManager(e,t){z(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(vf)&&(e=e.slice(0,e.indexOf(vf))),z(e.length>0,()=>"scheme must not be an empty string.");const n=Er.getInstance();z(n.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R4{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(nt().get("IS_BROWSER")){nt().setPlatform("browser",new R4);try{Er.registerManager(os.URL_SCHEME,new N4)}catch{}try{Er.registerManager(as.URL_SCHEME,new v4)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C4={importFetch:()=>require("node-fetch")};let Wu;class L4{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return nt().global.fetch!=null?nt().global.fetch(e,t):(Wu==null&&(Wu=C4.importFetch()),Wu(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}}nt().get("IS_NODE")&&nt().setPlatform("node",new L4);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mr(r,e="float32",t){return e=e||"float32",Kd(r),new ku(r,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k4(r,e){const t=C(r,"x","cast");if(!P3(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const n={x:t},s={dtype:e};return G.runKernel(qc,n,s)}const vt=W({cast_:k4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D4(r){const t={x:C(r,"x","clone","string_or_numeric")};return G.runKernel(su,t)}const cs=W({clone_:D4});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P4(r,e=!1){console.log(r.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */cf();const F4={buffer:Mr,cast:vt,clone:cs,print:P4};Jy(F4);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wf(r,e,t,n){a(r),t=t==null?0:t,n=n==null?1:n,o(t,n);let s=0;const i=c=>(c.then(l=>{const u=t+ ++s/r.length*(n-t);return e(u),l}),c);function a(c){z(c!=null&&Array.isArray(c)&&c.length>0,()=>"promises must be a none empty array")}function o(c,l){z(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${c}`),z(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),z(l>=c,()=>`startFraction must be no more than endFraction, but got startFraction ${c} and endFraction ${l}`)}return Promise.all(r.map(i))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function O4(r,e){e==null&&(e={});const t=e.fetchFunc==null?nt().platform.fetch:e.fetchFunc,n=r.map(h=>t(h,e.requestInit,{isBinary:!0})),s=0,i=.5,o=(e.onProgress==null?await Promise.all(n):await wf(n,e.onProgress,s,i)).map(h=>h.arrayBuffer()),c=.5,l=1;return e.onProgress==null?await Promise.all(o):await wf(o,e.onProgress,c,l)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B4="application/octet-stream",z4="application/json";class ju{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(z(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=nt().platform.fetch,z(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&z(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=h4(e,n);t.body.append("model.json",new Blob([JSON.stringify(s)],{type:z4}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:B4}),"model.weights.bin");const i=await this.fetch(this.path,t);if(i.ok)return{modelArtifactsInfo:Vu(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const n=t.modelTopology,s=t.weightsManifest;if(n==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return d4(t,i=>this.loadWeights(i))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,s]=U4(t),i=this.weightPathPrefix||n,a=[];for(const u of e)a.push(...u.weights);const o=[],c=[];for(const u of e)for(const h of u.paths)this.weightUrlConverter!=null?c.push(this.weightUrlConverter(h)):o.push(i+h+s);this.weightUrlConverter&&o.push(...await Promise.all(c));const l=await O4(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,l4(l)]}}ju.URL_SCHEME_REGEX=/^https?:\/\//;function U4(r){const e=r.lastIndexOf("/"),t=r.lastIndexOf("?"),n=r.substring(0,e),s=t>e?r.substring(t):"";return[n+"/",s]}function Sf(r){return r.match(ju.URL_SCHEME_REGEX)!=null}const Tf=(r,e)=>{if(typeof fetch=="undefined"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(r)?t=r.every(n=>Sf(n)):t=Sf(r),t)return Ef(r,e)}return null};Ft.registerSaveRouter(Tf);Ft.registerLoadRouter(Tf);function Ef(r,e){return new ju(r,e)}function Mf(r,e){return Ef(r,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V4(r,e,t=!1,n=!1){let s=C(r,"a","matMul"),i=C(e,"b","matMul");[s,i]=Tt(s,i);const a={a:s,b:i},o={transposeA:t,transposeB:n};return G.runKernel(jc,a,o)}const Ot=W({matMul_:V4});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H4(r,e,t=1,n=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const i={indices:C(r,"indices","oneHot","int32")},a={depth:e,onValue:t,offValue:n};return G.runKernel(fu,i,a)}const $4=W({oneHot_:H4});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G4(r,e){const t=C(r,"x","transpose");if(e==null&&(e=t.shape.map((i,a)=>a).reverse()),z(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of perm ${e}.`),e.forEach(i=>{z(i>=0&&i<t.rank,()=>`All entries in 'perm' must be between 0 and ${t.rank-1} but got ${e}`)}),t.rank<=1)return t.clone();const n={x:t},s={perm:e};return G.runKernel(Au,n,s)}const qu=W({transpose_:G4});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W4(r,e){const t=[];for(let n=0;n<e.length;n++){const s=r[r.length-n-1],i=e.length-n-1,a=e[i];(s==null||s===1&&a>1)&&t.unshift(i)}return t}function Lt(r,e){const t=[],n=Math.max(r.length,e.length);for(let s=0;s<n;s++){let i=r[r.length-s-1];i==null&&(i=1);let a=e[e.length-s-1];if(a==null&&(a=1),i===1)t.unshift(a);else if(a===1)t.unshift(i);else if(i!==a){const o=`Operands could not be broadcast together with shapes ${r} and ${e}.`;throw Error(o)}else t.unshift(i)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j4(r,e,t){if(Dc(r),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const n=aa(r,t);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return oa(r,e,n,t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let us;function q4(r,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,n=!1,s=!1,i=!1,a=!1,o=!1;if(r.data instanceof Uint8Array)t=!0;else if(typeof ImageData!="undefined"&&r instanceof ImageData)n=!0;else if(typeof HTMLVideoElement!="undefined"&&r instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement)i=!0;else if(r.getContext!=null)a=!0;else if(typeof ImageBitmap!="undefined"&&r instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(s){const f=2;if(s&&r.readyState<f)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(Ru(Xp,G.backendName)!=null){const f={pixels:r},m={numChannels:e};return G.runKernel(Xp,f,m)}const[l,u]=s?[r.videoWidth,r.videoHeight]:[r.width,r.height];let h;if(a)h=r.getContext("2d").getImageData(0,0,l,u).data;else if(n||t)h=r.data;else if(i||s||o){if(us==null)if(typeof document=="undefined")if(typeof OffscreenCanvas!="undefined"&&typeof OffscreenCanvasRenderingContext2D!="undefined")us=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else us=document.createElement("canvas").getContext("2d");us.canvas.width=l,us.canvas.height=u,us.drawImage(r,0,0,l,u),h=us.getImageData(0,0,l,u).data}let d;if(e===4)d=new Int32Array(h);else{const f=l*u;d=new Int32Array(f*e);for(let m=0;m<f;m++)for(let _=0;_<e;++_)d[m*e+_]=h[m*4+_]}return j4(d,[u,l,e],"int32")}const Af=W({fromPixels_:q4});function K4(r,e){const t=r.shape.length,n=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[n-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[n-1]} vs. ${t}`);if(Ne(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);const s=e.shape,i=s[s.length-1];let a=1;for(let h=0;h<s.length-1;++h)a*=s[h];const o=r.shape,c=s.slice();c.pop();let l=1;for(let h=i;h<t;++h)l*=o[h],c.push(o[h]);const u=[...Xt(r.shape).map(h=>h/l),1].slice(0,i);return[c,a,l,u]}function X4(r,e,t){const n=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${r}, sliceDim: ${n}, and batchDim: ${s}.`;if(t.rank<s)throw new Error(i+` update.rank < ${s}. `);if(r.length<n+(t.rank-s))throw new Error(i+` Output shape length < ${n+(t.rank-s)}`);if(t.rank!==s+r.length-n)throw new Error(i+` update.rank != ${s+r.length-n}`);for(let a=0;a<s;++a)if(t.shape[a]!==e.shape[a])throw new Error(i+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-s;++a)if(t.shape[a+s]!==r[a+n])throw new Error(i+` updates.shape[${a+s}] (${t.shape[a+s]}) != shape[${a+s}] (${r[a+s]})`)}function Y4(r,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}X4(t,e,r)}function J4(r,e,t){const n=e.shape.length,s=n>1?e.shape[n-1]:1,i=t.length;let a=1;for(let h=s;h<i;++h)a*=t[h];const o=s<1?1:s,c=Ne(e.shape)/o,l=[...Xt(t.slice(0,s)),1],u=Ne(t);return{sliceRank:s,numUpdates:c,sliceSize:a,strides:l,outputSize:u}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ku=-2,Z4=-1;function Q4(r,e,t){const n=[];for(let s=0;s<r.length;s++)n[s]=Math.ceil((e[s]-r[s])/t[s]);return n}function If(r,e,t){let n=t.length;for(let s=0;s<t.length;s++)if(t[s]>1){n=s;break}for(let s=n+1;s<t.length;s++)if(e[s]>0||t[s]!==r[s])return!1;return!0}function Nf(r,e){let t=r.length>0?r[r.length-1]:1;for(let n=0;n<r.length-1;n++)t+=r[n]*e[n];return t}function e9(r,e,t){let n;const s=r.shape.length;typeof e=="number"?n=[e,...new Array(s-1).fill(0)]:e.length<s?n=e.concat(new Array(s-e.length).fill(0)):n=e.slice(),n.forEach(a=>{z(a!==-1,()=>"slice() does not support negative begin indexing.")});let i;return t==null?i=new Array(s).fill(-1):typeof t=="number"?i=[t,...new Array(s-1).fill(-1)]:t.length<s?i=t.concat(new Array(s-t.length).fill(-1)):i=t,i=i.map((a,o)=>a>=0?a:(z(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${o}.`),r.shape[o]-n[o])),[n,i]}function t9(r,e,t,n,s,i,a,o,c){let l;if(n==null?(l=new Array(e.length),l.fill(1)):l=n,a!=null&&(a&a-1)!=0)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:l.slice(),beginMask:s,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:c};for(let x=0;x<h.dims;x++)u&&(1<<x&o)!=0&&h.numAddAxisAfterEllipsis++,1<<x&a&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:r.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};n9(h,d);let p=!0,f=!0,m=!0;const _=[],g=[];for(let x=0;x<r.length;++x){if(d.strides[x]===0)throw Error(`strides[${x}] must be non-zero`);const w=!!(d.shrinkAxisMask&1<<x),T=r[x];if(T===-1){_.push(w?1:-1);continue}const M=[d.beginMask&1<<x,d.endMask&1<<x],S=[d.strides[x]>0?0:-1,d.strides[x]>0?T:T-1];if(w&&d.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&d.strides[x]===1;const R=!!(d.beginMask&1<<x&&d.endMask&1<<x);if(d.beginValid&&d.endValid){if(w){const Y=d.begin[x]<0?T+d.begin[x]:d.begin[x];if(d.begin[x]=Y,d.end[x]=d.begin[x]+1,Y<0||Y>=T)throw Error(`slice index ${d.begin[x]} of dimension ${x} out of bounds.`)}else d.begin[x]=Rf(d.begin[x],0,d.strides[x],T,M,S),d.end[x]=Rf(d.end[x],1,d.strides[x],T,M,S);const A=d.strides[x]===1&&d.begin[x]===0&&d.end[x]===T;p=p&&A,f=f&&(x===0&&d.strides[x]===1||A)}else p=p&&d.strides[x]===1&&R,f=f&&(x===0&&d.strides[x]===1||R);let k,O=!1;if(d.beginValid&&d.endValid?(k=d.end[x]-d.begin[x],O=!0):w?(k=1,O=!0):R&&T>=0&&(d.strides[x]<0?k=-T:k=T,O=!0),O){let A;k===0||k<0!=d.strides[x]<0?A=0:A=Math.trunc(k/d.strides[x])+(k%d.strides[x]!=0?1:0),_.push(A)}else _.push(-1)}for(let x=0;x<d.finalShapeGatherIndices.length;++x){const w=d.finalShapeGatherIndices[x];w>=0?g.push(_[w]):w===Ku&&g.push(1)}return{finalShapeSparse:g.filter((x,w)=>d.finalShapeGatherIndices[w]!==Ku),finalShape:g,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function n9(r,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=r.begin!=null,e.endValid=r.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let n=0;n<r.dims;n++)if(1<<n&r.ellipsisMask){const s=Math.min(e.dims-(r.dims-n)+1+r.numAddAxisAfterEllipsis,e.dims);for(;t<s;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=n}else if(1<<n&r.newAxisMask)e.finalShapeGatherIndices.push(Ku),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);r.begin!=null&&(e.begin[t]=r.begin[n]),r.end!=null&&(e.end[t]=r.end[n]),e.strides[t]=r.strides[n],r.beginMask&1<<n&&(e.beginMask|=1<<t),r.endMask&1<<n&&(e.endMask|=1<<t),r.shrinkAxisMask&1<<n?(e.finalShapeGatherIndices.push(Z4),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(n)),e.inputShapeGatherIndicesSparse[t]=n,t++}}function Rf(r,e,t,n,s,i){if(s[e])return t>0?i[e]:i[e+1&1];{const a=r<0?n+r:r;return a<i[0]?i[0]:a>i[1]?i[1]:a}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r9(){return G}function rt(r,e){return G.tidy(r,e)}function s9(r){sf(r).forEach(t=>t.dispose())}function Ar(r){return G.keep(r)}function i9(r){return G.setBackend(r)}function a9(){return G.backendName}function o9(r,e,t=1){return G.registerBackend(r,e,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c9(r,e){let t=C(r,"a","add"),n=C(e,"b","add");[t,n]=Tt(t,n);const s={a:t,b:n};return G.runKernel(Uc,s)}const Yt=W({add_:c9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u9(r,e){let t=C(r,"a","floorDiv"),n=C(e,"b","floorDiv");[t,n]=Tt(t,n);const s={a:t,b:n};return G.runKernel(hp,s)}const Cf=W({floorDiv_:u9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l9(r,e){let t=C(r,"a","div"),n=C(e,"b","div");if([t,n]=Tt(t,n),t.dtype==="int32"&&n.dtype==="int32")return Cf(t,n);const s={a:t,b:n},i={};return G.runKernel(sp,s,i)}const kt=W({div_:l9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h9(r,e){let t=C(r,"a","mul"),n=C(e,"b","mul");[t,n]=Tt(t,n);const s={a:t,b:n};return G.runKernel(vp,s)}const Ke=W({mul_:h9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d9(r){const e=C(r,"x","abs");if(e.dtype==="complex64"){const t={x:e};return G.runKernel(ry,t)}else{const t={x:e};return G.runKernel(Zd,t)}}const En=W({abs_:d9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p9(r){const t={x:C(r,"x","acos")};return G.runKernel(W3,t)}const f9=W({acos_:p9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m9(r){const t={x:C(r,"x","acosh")};return G.runKernel(j3,t)}const g9=W({acosh_:m9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y9(r){z(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),z(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);const e=r.map((s,i)=>C(s,`tensors${i}`,"addN")),t=e[0];e.forEach(s=>{if(s.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!js(s.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const n=e;return G.runKernel(Vc,n)}const _9=W({addN_:y9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x9(r,e=null,t=!1){const s={x:C(r,"x","all","bool")},i={axis:e,keepDims:t};return G.runKernel(Hc,s,i)}const b9=W({all_:x9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v9(r,e=null,t=!1){const s={x:C(r,"x","any","bool")},i={axis:e,keepDims:t};return G.runKernel($c,s,i)}const w9=W({any_:v9});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S9(r,e=0){const n={x:C(r,"x","argMax")},s={axis:e};return G.runKernel(Gc,n,s)}const T9=W({argMax_:S9});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E9(r,e=0){const n={x:C(r,"x","argMin")},s={axis:e};return G.runKernel(q3,n,s)}const M9=W({argMin_:E9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A9(r){const t={x:C(r,"x","asin")};return G.runKernel(K3,t)}const I9=W({asin_:A9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N9(r){const t={x:C(r,"x","asinh")};return G.runKernel(X3,t)}const R9=W({asinh_:N9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C9(r){const t={x:C(r,"x","atan")};return G.runKernel(Y3,t)}const L9=W({atan_:C9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k9(r,e){let t=C(r,"a","atan2"),n=C(e,"b","atan2");[t,n]=Tt(t,n);const s={a:t,b:n};return G.runKernel(Z3,s)}const D9=W({atan2_:k9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P9(r){const t={x:C(r,"x","atanh")};return G.runKernel(J3,t)}const F9=W({atanh_:P9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lf(r,e,t,n,s,i,a="channelsLast"){const[o,c]=go(e);let l;if(a==="channelsLast")l=[o,c,r[3],r[3]];else if(a==="channelsFirst")l=[o,c,r[1],r[1]];else throw new Error(`Unknown dataFormat ${a}`);return Ir(r,l,t,n,s,i,!1,a)}function Ir(r,e,t,n,s,i,a=!1,o="channelsLast"){let[c,l,u,h]=[-1,-1,-1,-1];if(o==="channelsLast")[c,l,u,h]=r;else if(o==="channelsFirst")[c,h,l,u]=r;else throw new Error(`Unknown dataFormat ${o}`);const[d,p,,f]=e,[m,_]=go(t),[g,y]=go(n),x=Xu(d,g),w=Xu(p,y),{padInfo:T,outHeight:M,outWidth:S}=z9(s,l,u,m,_,x,w,i,o),R=a?f*h:f;let k;return o==="channelsFirst"?k=[c,R,M,S]:o==="channelsLast"&&(k=[c,M,S,R]),{batchSize:c,dataFormat:o,inHeight:l,inWidth:u,inChannels:h,outHeight:M,outWidth:S,outChannels:R,padInfo:T,strideHeight:m,strideWidth:_,filterHeight:d,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:w,dilationHeight:g,dilationWidth:y,inShape:r,outShape:k,filterShape:e}}function O9(r,e,t,n,s){n==null&&(n=B9(r,e,t));const i=r[0],a=r[1],o=yo((i-e+2*n)/t+1,s),c=yo((a-e+2*n)/t+1,s);return[o,c]}function B9(r,e,t,n=1){const s=Xu(e,n);return Math.floor((r[0]*(t-1)-t+s)/2)}function go(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function Xu(r,e){return e<=1?r:r+(r-1)*(e-1)}function z9(r,e,t,n,s,i,a,o,c){let l,u,h;if(typeof r=="number"){l={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};const p=O9([e,t],i,n,r,o);u=p[0],h=p[1]}else if(r==="same"){u=Math.ceil(e/n),h=Math.ceil(t/s);const d=Math.max(0,(u-1)*n+i-e),p=Math.max(0,(h-1)*s+a-t),f=Math.floor(d/2),m=d-f,_=Math.floor(p/2),g=p-_;l={top:f,bottom:m,left:_,right:g,type:"SAME"}}else if(r==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-i+1)/n),h=Math.ceil((t-a+1)/s);else if(typeof r=="object"){const d=c==="channelsLast"?r[1][0]:r[2][0],p=c==="channelsLast"?r[1][1]:r[2][1],f=c==="channelsLast"?r[2][0]:r[3][0],m=c==="channelsLast"?r[2][1]:r[3][1];l={top:d,bottom:p,left:f,right:m,type:d===0&&p===0&&f===0&&m===0?"VALID":"EXPLICIT"},u=yo((e-i+d+p)/n+1,o),h=yo((t-a+f+m)/s+1,o)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:l,outHeight:u,outWidth:h}}function yo(r,e){if(!e)return Math.trunc(r);switch(e){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${e}`)}}function _o(r){const[e,t,n]=go(r);return e===1&&t===1&&n===1}function ls(r,e){return _o(r)||_o(e)}function kf(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function On(r,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")z(ao(e),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(n=>{n.forEach(s=>{z(ao(s),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${s}.`)})});else throw Error(`Error in ${r}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U9(r,e){const n={x:C(r,"x","reshape","string_or_numeric")},s={shape:e};return G.runKernel(Np,n,s)}const pe=W({reshape_:U9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V9(r,e,t,n,s){const i=C(r,"x","avgPool","float32"),a=1;z(ls(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let o=i,c=!1;i.rank===3&&(c=!0,o=pe(i,[1,i.shape[0],i.shape[1],i.shape[2]])),z(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),On("avgPool",n,s);const l={x:o},u={filterSize:e,strides:t,pad:n,dimRoundingMode:s};let h=G.runKernel(Wc,l,u);return h=vt(h,i.dtype),c?pe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const H9=W({avgPool_:V9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $9(r,e,t,n,s,i="NDHWC"){const a=C(r,"x","avgPool3d","float32");let o=a,c=!1;a.rank===4&&(c=!0,o=pe(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),z(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),z(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),On("avgPool3d",n,s);const l={x:o},u={filterSize:e,strides:t,pad:n,dimRoundingMode:s,dataFormat:i};let h=G.runKernel(Q3,l,u);return h=vt(h,o.dtype),c?pe(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const G9=W({avgPool3d_:$9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W9(r,e=0){z(r.length>=1,()=>"Pass at least one tensor to concat");const t=hf(r,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),t.length===1)return cs(t[0]);const n=t,s={axis:e};return G.runKernel(tp,n,s)}const Jt=W({concat_:W9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j9(r){const t={x:C(r,"x","sigmoid","float32")};return G.runKernel(Fp,t)}const Yu=W({sigmoid_:j9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q9(r,e,t){const n=C(r,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");const s={x:n},i={begin:e,size:t};return G.runKernel(Dp,s,i)}const Qe=W({slice_:q9});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K9(r){const t={x:C(r,"x","tanh","float32")};return G.runKernel(jp,t)}const X9=W({tanh_:K9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y9(r,e,t){const n=C(r,"x","batchToSpaceND"),s=e.reduce((o,c)=>o*c);z(n.rank>=1+e.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${e.length}`),z(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),z(n.shape[0]%s==0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const i={x:n},a={blockShape:e,crops:t};return G.runKernel(Qd,i,a)}const J9=W({batchToSpaceND_:Y9});function Z9(r){let e;return r.rank===0||r.rank===1?e=pe(r,[1,1,1,r.size]):r.rank===2?e=pe(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?e=pe(r,[1,r.shape[0],r.shape[1],r.shape[2]]):e=r,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q9(r,e,t,n,s,i){i==null&&(i=.001);const a=C(r,"x","batchNorm"),o=C(e,"mean","batchNorm"),c=C(t,"variance","batchNorm");let l;s!=null&&(l=C(s,"scale","batchNorm"));let u;n!=null&&(u=C(n,"offset","batchNorm")),z(o.rank===c.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),z(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),z(l==null||o.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:Z9(a),scale:l,offset:u,mean:o,variance:c},p={varianceEpsilon:i},f=G.runKernel(nu,d,p);return pe(f,a.shape)}const Df=W({batchNorm_:Q9});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e5(r,e,t){const n=C(r,"x","bincount"),s=C(e,"weights","bincount");z(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),z(t>=0,()=>`size must be non-negative, but got ${t}.`),z(s.size===n.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${s.shape}.`);const i={x:n,weights:s},a={size:t};return G.runKernel(ey,i,a)}const Pf=W({bincount_:e5});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t5(r,e){const t=C(r,"s0","broadcastArgs","int32"),n=C(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);const s={s0:t,s1:n};return G.runKernel(ty,s)}const n5=W({broadcastArgs_:t5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r5(r,e){let t=C(r,"broadcastTo","x");const n=t.shape;if(e.some(l=>!(l>0)||l%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=pe(t,l)}const s=t.shape,i=Array.from(e);for(let l=e.length-1;l>=0;l--)if(s[l]===e[l])i[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${e}].`);if(i.map((l,u)=>l>1?u:-1).filter(l=>l>=0).length===0)return cs(t);const o={x:t},c={reps:i};return G.runKernel(uo,o,c)}const xo=W({broadcastTo_:r5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s5(r){const t={x:C(r,"x","ceil","float32")};return G.runKernel(ep,t)}const i5=W({ceil_:s5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a5(r,e,t){const n=C(r,"x","clipByValue");z(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`);const s={x:n},i={clipValueMin:e,clipValueMax:t};return G.runKernel(Kc,s,i)}const o5=W({clipByValue_:a5});function c5(r,e){return Jt(r,e)}const Ff=W({concat2d_:c5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u5(r,e,t,n,s="NHWC",i=[1,1],a){const o=C(r,"x","conv2d","float32"),c=C(e,"filter","conv2d","float32");let l=o,u=!1;o.rank===3&&(u=!0,l=pe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),z(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),z(c.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`),On("conv2d",n,a);const h=s==="NHWC"?l.shape[3]:l.shape[1];z(h===c.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${c.shape[2]}.`),z(ls(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);const d={x:l,filter:c},p={strides:t,pad:n,dataFormat:s,dilations:i,dimRoundingMode:a},f=G.runKernel(Xc,d,p);return u?pe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Ju=W({conv2d_:u5});function l5(r,e,t,n,s="NWC",i=1,a){const o=C(r,"x","conv1d"),c=C(e,"filter","conv1d");let l=o,u=!1;o.rank===2&&(u=!0,l=pe(o,[1,o.shape[0],o.shape[1]])),z(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),z(c.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`),On("conv1d",n,a),z(l.shape[2]===c.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${c.shape[1]}.`),z(ls(t,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${i}'`),z(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const h=pe(c,[1,c.shape[0],c.shape[1],c.shape[2]]),d=pe(l,[l.shape[0],1,l.shape[1],l.shape[2]]),_=Ju(d,h,[1,t],n,"NHWC",[1,i],a);return u?pe(_,[_.shape[2],_.shape[3]]):pe(_,[_.shape[0],_.shape[2],_.shape[3]])}const h5=W({conv1d_:l5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d5(r,e,t,n,s,i="NHWC",a){z(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let o=r,c=e,l=!1;e.rank===3&&(l=!0,c=pe(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,r[0],r[1],r[2]]),z(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),z(c.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`),z(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const u=i==="NHWC"?o[3]:o[1],h=i==="NHWC"?c.shape[3]:c.shape[1];z(u===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[2]}.`),z(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),On("conv2dDerInput",s,a);const d={dy:c,filter:t},p={strides:n,pad:s,dataFormat:i,dimRoundingMode:a,inputShape:o},f=G.runKernel(Yc,d,p);return l?pe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Of=W({conv2DBackpropInput_:d5});function p5(r,e,t,n,s,i){const a=C(r,"x","conv2dTranspose"),o=C(e,"filter","conv2dTranspose");return Of(t,a,o,n,s,"NHWC",i)}const f5=W({conv2dTranspose_:p5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m5(r,e,t,n,s="NDHWC",i=[1,1,1]){const a=C(r,"x","conv3d"),o=C(e,"filter","conv3d");let c=a,l=!1;a.rank===4&&(l=!0,c=pe(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),z(c.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${c.rank}.`),z(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),z(c.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${o.shape[3]}.`),z(ls(t,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),z(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);const u={x:c,filter:o},h={strides:t,pad:n,dataFormat:s,dilations:i},d=G.runKernel(iy,u,h);return l?pe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const g5=W({conv3d_:m5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y5(r){const t={x:C(r,"x","cos","float32")};return G.runKernel(np,t)}const _5=W({cos_:y5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x5(r){const t={x:C(r,"x","cosh","float32")};return G.runKernel(rp,t)}const b5=W({cosh_:x5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v5(r,e=0,t=!1,n=!1){const i={x:C(r,"x","cumsum")},a={axis:e,exclusive:t,reverse:n};return G.runKernel(Jc,i,a)}const w5=W({cumsum_:v5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S5(r,e,t,n=!1){const s=C(r,"x","denseBincount"),i=C(e,"weights","denseBincount");z(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),z(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),z(t>=0,()=>`size must be non-negative, but got ${t}.`),z(i.size===s.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${i.shape}.`);const a={x:s,weights:i},o={size:t,binaryOutput:n};return G.runKernel(ay,a,o)}const T5=W({denseBincount_:S5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E5(r,e,t="NHWC"){const n=C(r,"x","depthToSpace","float32"),s=t==="NHWC"?n.shape[1]:n.shape[2],i=t==="NHWC"?n.shape[2]:n.shape[3],a=t==="NHWC"?n.shape[3]:n.shape[1];z(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),z(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${n.shape}`),z(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${n.shape}`),z(a%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${n.shape}`);const o={x:n},c={blockSize:e,dataFormat:t};return G.runKernel(Qc,o,c)}const M5=W({depthToSpace_:E5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A5(r,e,t,n,s="NHWC",i=[1,1],a){const o=C(r,"x","depthwiseConv2d","float32"),c=C(e,"filter","depthwiseConv2d","float32");let l=o,u=!1;o.rank===3&&(u=!0,l=pe(o,[1,o.shape[0],o.shape[1],o.shape[2]])),z(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),z(c.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`),z(l.shape[3]===c.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),On("depthwiseConv2d",n,a);const h={x:l,filter:c},d={strides:t,pad:n,dataFormat:s,dilations:i,dimRoundingMode:a},p=G.runKernel(eu,h,d);return u?pe(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Bf=W({depthwiseConv2d_:A5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I5(r,e,t,n,s=[1,1],i="NHWC"){const a=C(r,"x","dilation2d"),o=C(e,"filter","dilation2d");z(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),z(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),z(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let c=a,l=!1;a.rank===3&&(c=pe(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=!0);const u={x:c,filter:o},h={strides:t,pad:n,dilations:s},d=G.runKernel(uy,u,h);return l?pe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const N5=W({dilation2d_:I5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R5(r,e){let t=C(r,"a","equal","string_or_numeric"),n=C(e,"b","equal","string_or_numeric");[t,n]=Tt(t,n),Lt(t.shape,n.shape);const s={a:t,b:n};return G.runKernel(ap,s)}const zf=W({equal_:R5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C5(r,e,t){const n=C(e,"a","where"),s=C(t,"b","where"),i=C(r,"condition","where","bool"),a=Lt(Lt(i.shape,n.shape),s.shape),o=xo(i,a),c=xo(n,a),l=xo(s,a),u={condition:o,t:c,e:l};return G.runKernel(kp,u)}const Zs=W({where_:C5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L5(r){const t={x:C(r,"x","zerosLike")};return G.runKernel(Kp,t)}const Zu=W({zerosLike_:L5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k5(r,e){let t=C(r,"a","div"),n=C(e,"b","div");[t,n]=Tt(t,n);const s=kt(t,n),i=Zu(s),a=zf(n,i);return Zs(a,i,s)}const D5=W({divNoNan_:k5});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P5(r,...e){const t=e.map((s,i)=>C(s,`tensors${i}`,"einsum")),n={equation:r};return G.runKernel(ly,t,n)}const F5=W({einsum_:P5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O5(r){const t={x:C(r,"x","elu","float32")};return G.runKernel(ip,t)}const Uf=W({elu_:O5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B5(r){let e=C(r,"x","erf");z(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=vt(e,"float32"));const t={x:e};return G.runKernel(hy,t)}const z5=W({erf_:B5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U5(r){const t={x:C(r,"x","exp")};return G.runKernel(op,t)}const hs=W({exp_:U5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V5(r,e=0){const t=C(r,"x","expandDims","string_or_numeric");z(e<=t.rank,()=>"Axis must be <= rank of the tensor");const n={input:t},s={dim:e};return G.runKernel(cp,n,s)}const er=W({expandDims_:V5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H5(r){const t={x:C(r,"x","expm1")};return G.runKernel(dy,t)}const $5=W({expm1_:H5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G5(r,e){const t=C(r,"x","tile","string_or_numeric");z(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const n={x:t},s={reps:e};return G.runKernel(uo,n,s)}const ca=W({tile_:G5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W5(r,e,t,n="float32"){e==null&&(e=r);const s=Mr([r,e],n),i=r<=e?r:e;for(let o=0;o<i;++o)s.set(1,o,o);const a=pe(s.toTensor(),[r,e]);if(t==null)return a;if(t.length===1)return ca(er(a,0),[t[0],1,1]);if(t.length===2)return ca(er(er(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return ca(er(er(er(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const j5=W({eye_:W5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qu(r,e,t){const n={shape:r,value:e,dtype:t};return G.runKernel(up,{},n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q5(r){const t={x:C(r,"x","floor","float32")};return G.runKernel(lp,t)}const K5=W({floor_:q5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X5(r,e,t=0,n=0){const s=C(r,"x","gather"),i=C(e,"indices","gather","int32"),a={x:s,indices:i},o={axis:t,batchDims:n};return G.runKernel(dp,a,o)}const Vf=W({gather_:X5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y5(r,e){let t=C(r,"a","greater","string_or_numeric"),n=C(e,"b","greater","string_or_numeric");[t,n]=Tt(t,n),Lt(t.shape,n.shape);const s={a:t,b:n};return G.runKernel(pp,s)}const bo=W({greater_:Y5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J5(r,e){let t=C(r,"a","greaterEqual","string_or_numeric"),n=C(e,"b","greaterEqual","string_or_numeric");[t,n]=Tt(t,n),Lt(t.shape,n.shape);const s={a:t,b:n};return G.runKernel(fp,s)}const Hf=W({greaterEqual_:J5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z5(r){const t={input:C(r,"input","imag")};return G.runKernel(my,t)}const el=W({imag_:Z5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q5(r){const t={x:C(r,"x","isNaN")};return G.runKernel(gy,t)}const e_=W({isNaN_:Q5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t_(r,e=.2){const n={x:C(r,"x","leakyRelu")},s={alpha:e};return G.runKernel(iu,n,s)}const $f=W({leakyRelu_:t_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n_(r,e){let t=C(r,"a","less","string_or_numeric"),n=C(e,"b","less","string_or_numeric");[t,n]=Tt(t,n),Lt(t.shape,n.shape);const s={a:t,b:n};return G.runKernel(mp,s)}const r_=W({less_:n_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s_(r,e){let t=C(r,"a","lessEqual","string_or_numeric"),n=C(e,"b","lessEqual","string_or_numeric");[t,n]=Tt(t,n),Lt(t.shape,n.shape);const s={a:t,b:n};return G.runKernel(gp,s)}const tl=W({lessEqual_:s_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i_(r,e,t){if(t<=0)throw new Error("The number of values should be positive.");const n={start:r,stop:e,num:t};return G.runKernel(yy,{},n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a_(r,e=5,t=1,n=1,s=.5){const i=C(r,"x","localResponseNormalization");z(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),z(ao(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=i,o=!1;i.rank===3&&(o=!0,a=pe(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const c={x:a},l={depthRadius:e,bias:t,alpha:n,beta:s},u=G.runKernel(vy,c,l);return o?pe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const o_=W({localResponseNormalization_:a_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c_(r){const t={x:C(r,"x","log","float32")};return G.runKernel(yp,t)}const ua=W({log_:c_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u_(r){const t={x:C(r,"x","log1p")};return G.runKernel(_y,t)}const Gf=W({log1p_:u_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nr(r){return G.customGrad(r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l_(r){const t={x:C(r,"x","neg")};return G.runKernel(wp,t)}const la=W({neg_:l_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h_(r){const t={x:C(r,"x","softplus")};return G.runKernel(Ly,t)}const d_=W({softplus_:h_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p_(r,e=null,t=!1){const s={x:C(r,"x","max")},i={reductionIndices:e,keepDims:t};return G.runKernel(au,s,i)}const Qs=W({max_:p_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f_(r,e){let t=C(r,"a","sub"),n=C(e,"b","sub");[t,n]=Tt(t,n);const s={a:t,b:n};return G.runKernel(Gp,s)}const et=W({sub_:f_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m_(r,e=null,t=!1){let n=C(r,"x","sum");n.dtype==="bool"&&(n=vt(n,"int32"));const s={x:n},i={axis:e,keepDims:t};return G.runKernel(vu,s,i)}const mt=W({sum_:m_});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g_(r,e=-1){const t=C(r,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Nr((s,i)=>{const a=!0,o=Qs(s,e,!0),c=et(s,o),l=et(vt(c,"float32"),ua(mt(hs(c),e,a)));return i([l]),{value:l,gradFunc:(h,d)=>{const[p]=d,f=!0,m=hs(p);return et(h,Ke(mt(h,e,f),m))}}})(t)}const y_=W({logSoftmax_:g_});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wf(r,e){for(let t=0;t<r.length;++t)if(r[r.length-t-1]!==e-1-t)return!1;return!0}function __(r,e,t){const n=r.length+e.length,s=[];let i=0,a=0;for(let o=0;o<n;o++)t.indexOf(o)===-1?s.push(r[i++]):s.push(e[a++]);return s}function ds(r,e){const t=[],n=r.length;for(let i=0;i<n;i++)e.indexOf(i)===-1&&t.push(r[i]);const s=e.map(i=>r[i]);return[t,s]}function Gn(r,e){const t=e.map(n=>1);return __(r,t,e)}function Rr(r,e,t){z(Wf(e,t),()=>`${r} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function jf(r,e){if(Wf(r,e))return null;const t=[];for(let n=0;n<e;++n)r.indexOf(n)===-1&&t.push(n);return r.forEach(n=>t.push(n)),t}function x_(r){return r.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function ha(r,e){const t=[];for(let n=e-r;n<e;++n)t.push(n);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b_(r,e=null,t=!1){const n=C(r,"x","logSumExp"),s=wr(e,n.shape),i=Qs(n,s,!0),a=et(n,i),o=hs(a),c=mt(o,s),l=ua(c),u=Yt(pe(i,l.shape),l);if(t){const h=Gn(u.shape,s);return pe(u,h)}return u}const v_=W({logSumExp_:b_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w_(r,e){const t=C(r,"a","logicalAnd","bool"),n=C(e,"b","logicalAnd","bool");Lt(t.shape,n.shape);const s={a:t,b:n};return G.runKernel(_p,s)}const qf=W({logicalAnd_:w_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S_(r){const t={x:C(r,"x","logicalNot","bool")};return G.runKernel(xy,t)}const T_=W({logicalNot_:S_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E_(r,e){const t=C(r,"a","logicalOr","bool"),n=C(e,"b","logicalOr","bool");Lt(t.shape,n.shape);const s={a:t,b:n};return G.runKernel(by,s)}const M_=W({logicalOr_:E_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A_(r,e,t,n,s){const i=C(r,"x","maxPool"),a=1;let o=i,c=!1;i.rank===3&&(c=!0,o=pe(i,[1,i.shape[0],i.shape[1],i.shape[2]])),z(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),z(ls(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),On("maxPool",n,s);const l={x:o},u={filterSize:e,strides:t,pad:n,dimRoundingMode:s},h=G.runKernel(ou,l,u);return c?pe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const I_=W({maxPool_:A_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N_(r,e=[1,1,1],t,n,s,i="NDHWC"){const a=C(r,"x","maxPool3d");let o=a,c=!1;a.rank===4&&(c=!0,o=pe(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),z(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),z(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),On("maxPool3d",n,s);const l={x:o},u={filterSize:e,strides:t,pad:n,dimRoundingMode:s,dataFormat:i},h=G.runKernel(wy,l,u);return c?pe(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const R_=W({maxPool3d_:N_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C_(r,e,t,n,s=!1){const a={x:C(r,"x","maxPoolWithArgmax")},o={filterSize:e,strides:t,pad:n,includeBatchInIndex:s},c=G.runKernel(Sy,a,o);return{result:c[0],indexes:c[1]}}const L_=W({maxPoolWithArgmax_:C_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k_(r,e){let t=C(r,"a","maximum"),n=C(e,"b","maximum");[t,n]=Tt(t,n),t.dtype==="bool"&&(t=vt(t,"int32"),n=vt(n,"int32")),Lt(t.shape,n.shape);const s={a:t,b:n};return G.runKernel(xp,s)}const D_=W({maximum_:k_});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P_(r,e=null,t=!1){const s={x:C(r,"x","mean")},i={axis:e,keepDims:t};return G.runKernel(cu,s,i)}const Kf=W({mean_:P_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ei(r,e="float32"){if(e==="complex64"){const n=ei(r,"float32"),s=ei(r,"float32");return ss(n,s)}const t=ta(Ne(r),e);return G.makeTensor(t,r,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nl(r,e="float32"){if(e==="complex64"){const n=nl(r,"float32"),s=ei(r,"float32");return ss(n,s)}const t=qd(Ne(r),e);return G.makeTensor(t,r,e)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F_(r,e=null,t=!1){const s={x:C(r,"x","min")},i={axis:e,keepDims:t};return G.runKernel(uu,s,i)}const rl=W({min_:F_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O_(r,e){let t=C(r,"a","minimum"),n=C(e,"b","minimum");[t,n]=Tt(t,n),t.dtype==="bool"&&(t=vt(t,"int32"),n=vt(n,"int32")),Lt(t.shape,n.shape);const s={a:t,b:n};return G.runKernel(bp,s)}const Xf=W({minimum_:O_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B_(r,e,t){z(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const n=C(r,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");z(e.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${e.length}.`);const s=t==="reflect"?1:0;for(let o=0;o<n.rank;o++)z(e[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),z(e[o][0]>=0&&e[o][0]<=n.shape[o]-s&&e[o][1]>=0&&e[o][1]<=n.shape[o]-s,()=>`Padding in dimension ${o} cannot be greater than or equal to ${n.shape[o]-s} or less than 0 for input of shape ${n.shape}`);const i={paddings:e,mode:t},a={x:n};return G.runKernel(lu,a,i)}const z_=W({mirrorPad_:B_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U_(r,e){let t=C(r,"a","mod"),n=C(e,"b","mod");[t,n]=Tt(t,n);const s={a:t,b:n};return G.runKernel(Ty,s)}const V_=W({mod_:U_});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H_(r){const e=C(r,"x","square"),t={};return G.runKernel("Square",{x:e},t)}const sl=W({square_:H_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $_(r,e,t,n=!1){const s=C(r,"logits","multinomial"),i=s.size,a=s.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);t=t||Math.random();const c={logits:a===1?pe(s,[1,-1]):s},l={numSamples:e,seed:t,normalized:n},u=G.runKernel(Ey,c,l);return a===1?pe(u,[u.size]):u}const G_=W({multinomial_:$_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W_(r,e){let t=C(r,"a","notEqual","string_or_numeric"),n=C(e,"b","notEqual","string_or_numeric");[t,n]=Tt(t,n),Lt(t.shape,n.shape);const s={a:t,b:n};return G.runKernel(Sp,s)}const Yf=W({notEqual_:W_});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j_(r){const t={x:C(r,"x","onesLike")};return G.runKernel(Tp,t)}const q_=W({onesLike_:j_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K_(r,e,t=0){const n=C(r,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:t},i={x:n};return G.runKernel(mu,i,s)}const X_=W({pad_:K_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y_(r,e,t){const n=C(r,"x","spaceToBatchND");z(n.rank>=1+e.length,()=>`input rank ${n.rank} should be > than [blockShape] ${e.length}`),z(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),z(n.shape.reduce((a,o,c)=>c>0&&c<=e.length?a&&(o+t[c-1][0]+t[c-1][1])%e[c-1]==0:a,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:n},i={blockShape:e,paddings:t};return G.runKernel(Bp,s,i)}const J_=W({spaceToBatchND_:Y_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z_(r,e){let t=C(r,"base","pow"),n=C(e,"exp","pow");[t,n]=Tt(t,n);const s={a:t,b:n};return G.runKernel(Mp,s)}const Jf=W({pow_:Z_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q_(r,e){const t=C(r,"x","prelu"),n=C(e,"alpha","prelu"),s={x:t,alpha:n};return G.runKernel(gu,s)}const Zf=W({prelu_:Q_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e6(r,e=null,t=!1){let n=C(r,"x","prod");n.dtype==="bool"&&(n=vt(n,"int32"));const s={x:n},i={axis:e,keepDims:t};return G.runKernel(yu,s,i)}const Qf=W({prod_:e6});var em={exports:{}};(function(r){(function(e,t,n){function s(c){var l=this,u=o();l.next=function(){var h=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=h-(l.c=h|0)},l.c=1,l.s0=u(" "),l.s1=u(" "),l.s2=u(" "),l.s0-=u(c),l.s0<0&&(l.s0+=1),l.s1-=u(c),l.s1<0&&(l.s1+=1),l.s2-=u(c),l.s2<0&&(l.s2+=1),u=null}function i(c,l){return l.c=c.c,l.s0=c.s0,l.s1=c.s1,l.s2=c.s2,l}function a(c,l){var u=new s(c),h=l&&l.state,d=u.next;return d.int32=function(){return u.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&i(h,u),d.state=function(){return i(u,{})}),d}function o(){var c=4022871197,l=function(u){u=u.toString();for(var h=0;h<u.length;h++){c+=u.charCodeAt(h);var d=.02519603282416938*c;c=d>>>0,d-=c,d*=c,c=d>>>0,d-=c,c+=d*4294967296}return(c>>>0)*23283064365386963e-26};return l}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.alea=a})(vr,r,!1)})(em);var tm={exports:{}};(function(r){(function(e,t,n){function s(o){var c=this,l="";c.x=0,c.y=0,c.z=0,c.w=0,c.next=function(){var h=c.x^c.x<<11;return c.x=c.y,c.y=c.z,c.z=c.w,c.w^=c.w>>>19^h^h>>>8},o===(o|0)?c.x=o:l+=o;for(var u=0;u<l.length+64;u++)c.x^=l.charCodeAt(u)|0,c.next()}function i(o,c){return c.x=o.x,c.y=o.y,c.z=o.z,c.w=o.w,c}function a(o,c){var l=new s(o),u=c&&c.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var d=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=l.next,h.quick=h,u&&(typeof u=="object"&&i(u,l),h.state=function(){return i(l,{})}),h}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xor128=a})(vr,r,!1)})(tm);var nm={exports:{}};(function(r){(function(e,t,n){function s(o){var c=this,l="";c.next=function(){var h=c.x^c.x>>>2;return c.x=c.y,c.y=c.z,c.z=c.w,c.w=c.v,(c.d=c.d+362437|0)+(c.v=c.v^c.v<<4^(h^h<<1))|0},c.x=0,c.y=0,c.z=0,c.w=0,c.v=0,o===(o|0)?c.x=o:l+=o;for(var u=0;u<l.length+64;u++)c.x^=l.charCodeAt(u)|0,u==l.length&&(c.d=c.x<<10^c.x>>>4),c.next()}function i(o,c){return c.x=o.x,c.y=o.y,c.z=o.z,c.w=o.w,c.v=o.v,c.d=o.d,c}function a(o,c){var l=new s(o),u=c&&c.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var d=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=l.next,h.quick=h,u&&(typeof u=="object"&&i(u,l),h.state=function(){return i(l,{})}),h}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xorwow=a})(vr,r,!1)})(nm);var rm={exports:{}};(function(r){(function(e,t,n){function s(o){var c=this;c.next=function(){var u=c.x,h=c.i,d,p;return d=u[h],d^=d>>>7,p=d^d<<24,d=u[h+1&7],p^=d^d>>>10,d=u[h+3&7],p^=d^d>>>3,d=u[h+4&7],p^=d^d<<7,d=u[h+7&7],d=d^d<<13,p^=d^d<<9,u[h]=p,c.i=h+1&7,p};function l(u,h){var d,p=[];if(h===(h|0))p[0]=h;else for(h=""+h,d=0;d<h.length;++d)p[d&7]=p[d&7]<<15^h.charCodeAt(d)+p[d+1&7]<<13;for(;p.length<8;)p.push(0);for(d=0;d<8&&p[d]===0;++d);for(d==8&&(p[7]=-1),u.x=p,u.i=0,d=256;d>0;--d)u.next()}l(c,o)}function i(o,c){return c.x=o.x.slice(),c.i=o.i,c}function a(o,c){o==null&&(o=+new Date);var l=new s(o),u=c&&c.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var d=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=l.next,h.quick=h,u&&(u.x&&i(u,l),h.state=function(){return i(l,{})}),h}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xorshift7=a})(vr,r,!1)})(rm);var sm={exports:{}};(function(r){(function(e,t,n){function s(o){var c=this;c.next=function(){var u=c.w,h=c.X,d=c.i,p,f;return c.w=u=u+1640531527|0,f=h[d+34&127],p=h[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=h[d]=f^p,c.i=d,f+(u^u>>>16)|0};function l(u,h){var d,p,f,m,_,g=[],y=128;for(h===(h|0)?(p=h,h=null):(h=h+"\0",p=0,y=Math.max(y,h.length)),f=0,m=-32;m<y;++m)h&&(p^=h.charCodeAt((m+32)%h.length)),m===0&&(_=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,m>=0&&(_=_+1640531527|0,d=g[m&127]^=p+_,f=d==0?f+1:0);for(f>=128&&(g[(h&&h.length||0)&127]=-1),f=127,m=4*128;m>0;--m)p=g[f+34&127],d=g[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,g[f]=p^d;u.w=_,u.X=g,u.i=f}l(c,o)}function i(o,c){return c.i=o.i,c.w=o.w,c.X=o.X.slice(),c}function a(o,c){o==null&&(o=+new Date);var l=new s(o),u=c&&c.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var d=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=l.next,h.quick=h,u&&(u.X&&i(u,l),h.state=function(){return i(l,{})}),h}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.xor4096=a})(vr,r,!1)})(sm);var im={exports:{}};(function(r){(function(e,t,n){function s(o){var c=this,l="";c.next=function(){var h=c.b,d=c.c,p=c.d,f=c.a;return h=h<<25^h>>>7^d,d=d-p|0,p=p<<24^p>>>8^f,f=f-h|0,c.b=h=h<<20^h>>>12^d,c.c=d=d-p|0,c.d=p<<16^d>>>16^f,c.a=f-h|0},c.a=0,c.b=0,c.c=2654435769|0,c.d=1367130551,o===Math.floor(o)?(c.a=o/4294967296|0,c.b=o|0):l+=o;for(var u=0;u<l.length+20;u++)c.b^=l.charCodeAt(u)|0,c.next()}function i(o,c){return c.a=o.a,c.b=o.b,c.c=o.c,c.d=o.d,c}function a(o,c){var l=new s(o),u=c&&c.state,h=function(){return(l.next()>>>0)/4294967296};return h.double=function(){do var d=l.next()>>>11,p=(l.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=l.next,h.quick=h,u&&(typeof u=="object"&&i(u,l),h.state=function(){return i(l,{})}),h}t&&t.exports?t.exports=a:n&&n.amd?n(function(){return a}):this.tychei=a})(vr,r,!1)})(im);var am={exports:{}};(function(r){(function(e,t){var n=this,s=256,i=6,a=52,o="random",c=t.pow(s,i),l=t.pow(2,a),u=l*2,h=s-1,d;function p(w,T,M){var S=[];T=T==!0?{entropy:!0}:T||{};var R=g(_(T.entropy?[w,x(e)]:w==null?y():w,3),S),k=new f(S),O=function(){for(var A=k.g(i),Y=c,B=0;A<l;)A=(A+B)*s,Y*=s,B=k.g(1);for(;A>=u;)A/=2,Y/=2,B>>>=1;return(A+B)/Y};return O.int32=function(){return k.g(4)|0},O.quick=function(){return k.g(4)/4294967296},O.double=O,g(x(k.S),e),(T.pass||M||function(A,Y,B,H){return H&&(H.S&&m(H,k),A.state=function(){return m(k,{})}),B?(t[o]=A,Y):A})(O,R,"global"in T?T.global:this==t,T.state)}t["seed"+o]=p;function f(w){var T,M=w.length,S=this,R=0,k=S.i=S.j=0,O=S.S=[];for(M||(w=[M++]);R<s;)O[R]=R++;for(R=0;R<s;R++)O[R]=O[k=h&k+w[R%M]+(T=O[R])],O[k]=T;(S.g=function(A){for(var Y,B=0,H=S.i,U=S.j,j=S.S;A--;)Y=j[H=h&H+1],B=B*s+j[h&(j[H]=j[U=h&U+Y])+(j[U]=Y)];return S.i=H,S.j=U,B})(s)}function m(w,T){return T.i=w.i,T.j=w.j,T.S=w.S.slice(),T}function _(w,T){var M=[],S=typeof w,R;if(T&&S=="object")for(R in w)try{M.push(_(w[R],T-1))}catch{}return M.length?M:S=="string"?w:w+"\0"}function g(w,T){for(var M=w+"",S,R=0;R<M.length;)T[h&R]=h&(S^=T[h&R]*19)+M.charCodeAt(R++);return x(T)}function y(){try{var w;return d&&(w=d.randomBytes)?w=w(s):(w=new Uint8Array(s),(n.crypto||n.msCrypto).getRandomValues(w)),x(w)}catch{var T=n.navigator,M=T&&T.plugins;return[+new Date,n,M,n.screen,x(e)]}}function x(w){return String.fromCharCode.apply(0,w)}if(g(t.random(),e),r.exports){r.exports=p;try{d=require("crypto")}catch{}}})([],Math)})(am);var t6=em.exports,n6=tm.exports,r6=nm.exports,s6=rm.exports,i6=sm.exports,a6=im.exports,ps=am.exports;ps.alea=t6;ps.xor128=n6;ps.xorwow=r6;ps.xorshift7=s6;ps.xor4096=i6;ps.tychei=a6;var om=ps;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o6{constructor(e,t,n,s,i){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=i||Math.random();this.random=om.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,t,n=!1;for(;!n;){let s,i,a;do s=2*this.random()-1,i=2*this.random()-1,a=s*s+i*i;while(a>=1||a===0);const o=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*s*o,t=this.mean+this.stdDev*i*o,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class c6{constructor(e=0,t=1,n,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=om.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u6(r,e=0,t=1,n="float32",s){const i=Mr(r,n),a=new c6(e,t,null,s);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const l6=W({randomUniform_:u6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function da(r,e,t=1,n="float32"){if(t===0)throw new Error("Cannot have a step of zero");const s={start:r,stop:e,step:t,dtype:n};return G.runKernel(Ap,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h6(r){const t={input:C(r,"input","real")};return G.runKernel(My,t)}const vo=W({real_:h6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d6(r){const t={x:C(r,"x","reciprocal")};return G.runKernel(Ay,t)}const p6=W({reciprocal_:d6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f6(r){const t={x:C(r,"x","relu")};return G.runKernel(Ip,t)}const wo=W({relu_:f6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m6(r){const t={x:C(r,"x","relu6")};return G.runKernel(Rp,t)}const cm=W({relu6_:m6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g6(r,e){const n={x:C(r,"x","reverse")},s={dims:e};return G.runKernel(xu,n,s)}const So=W({reverse_:g6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y6(r){const t={x:C(r,"x","round")};return G.runKernel(Cp,t)}const um=W({round_:y6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _6(r){const t={x:C(r,"x","rsqrt","float32")};return G.runKernel(Lp,t)}const x6=W({rsqrt_:_6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lt(r,e){if((Hn(r)&&e!=="string"||Array.isArray(r))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Hn(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return oa(r,[],[],e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b6(r){const t={x:C(r,"x","selu")};return G.runKernel(Ny,t)}const v6=W({selu_:b6});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function w6(r,e){const t=C(r,"x","setdiff1d"),n=C(e,"y","setdiff1d");z(t.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${n.dtype}).`),z(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),z(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);const s=await t.data(),i=await n.data(),a=new Set(i);let o=0;for(let u=0;u<s.length;u++)a.has(s[u])||o++;const c=new ku([o],t.dtype),l=new ku([o],"int32");for(let u=0,h=0;u<s.length;u++)a.has(s[u])||(c.values[h]=s[u],l.values[h]=u,h++);return[c.toTensor(),l.toTensor()]}const S6=w6;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T6(r){const t={x:C(r,"x","sign")};return G.runKernel(Cy,t)}const E6=W({sign_:T6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M6(r){const t={x:C(r,"x","sin","float32")};return G.runKernel(Pp,t)}const A6=W({sin_:M6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I6(r){const t={x:C(r,"x","sinh")};return G.runKernel(Ry,t)}const N6=W({sinh_:I6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R6(r,e=-1){const t=C(r,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const n={logits:t},s={dim:e};return G.runKernel(wu,n,s)}const C6=W({softmax_:R6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L6(r){z(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);const e={input:r};return G.runKernel(py,e)}const lm=W({fft_:L6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k6(r){z(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);const e={input:r};return G.runKernel(fy,e)}const il=W({ifft_:k6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D6(r){const e=r.shape[r.shape.length-1],t=r.size/e;let n;if(e<=2){const s=pe(r,[t,e]);n=il(s)}else{const s=[t,2*(e-1)],i=pe(vo(r),[t,e]),a=pe(el(r),[t,e]),o=So(Qe(i,[0,1],[t,e-2]),1),c=Ke(So(Qe(a,[0,1],[t,e-2]),1),lt(-1)),l=Jt([i,o],1),u=Jt([a,c],1),h=pe(ss(l,u),[s[0],s[1]]);n=il(h)}if(n=vo(n),r.rank===3&&r.shape[0]!==0){const s=n,i=r.shape[0];n=pe(n,[i,n.shape[0]/i,n.shape[1]]),s.dispose()}return n}const P6=W({irfft_:D6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F6(r,e,t=0){const s={x:C(r,"x","split")},i={numOrSizeSplits:e,axis:t};return G.runKernel(zp,s,i)}const pa=W({split_:F6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O6(r,e){z(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let t=r.shape[r.shape.length-1];const n=r.size/t;let s;if(e!=null&&e<t){const f=r.shape.map(_=>0),m=r.shape.map(_=>_);m[r.shape.length-1]=e,s=Qe(r,f,m),t=e}else if(e!=null&&e>t){const f=r.shape.map(m=>m);f[r.shape.length-1]=e-t,s=Jt([r,ei(f)],r.shape.length-1),t=e}else s=r;const i=Zu(s),a=pe(ss(s,i),[n,t]),o=lm(a),c=Math.floor(t/2)+1,l=vo(o),u=el(o),h=pa(l,[c,t-c],l.shape.length-1),d=pa(u,[c,t-c],u.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=c,pe(ss(h[0],d[0]),p)}const hm=W({rfft_:O6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B6(r){const t={x:C(r,"x","sqrt","float32")};return G.runKernel(Op,t)}const al=W({sqrt_:B6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z6(r,e){let t=C(r,"a","squaredDifference"),n=C(e,"b","squaredDifference");[t,n]=Tt(t,n),Lt(t.shape,n.shape);const s={a:t,b:n},i={};return G.runKernel($p,s,i)}const dm=W({squaredDifference_:z6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U6(r,e){const t=C(r,"x","squeeze");return pe(t,k3(t.shape,e).newShape)}const Bn=W({squeeze_:U6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V6(r,e=0){const t=hf(r,"tensors","stack","string_or_numeric");z(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&z(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const n=t,s={axis:e};return G.runKernel(Ep,n,s)}const tr=W({stack_:V6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H6(r,e=0){const n={x:C(r,"x","step")},s={alpha:e};return G.runKernel(Iu,n,s)}const $6=W({step_:H6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G6(r,e,t,n,s=0,i=0,a=0,o=0,c=0){const u={x:C(r,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:n,beginMask:s,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:c};return G.runKernel(Tu,u,h)}const W6=W({stridedSlice_:G6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j6(r){const t={x:C(r,"x","tan","float32")};return G.runKernel(Wp,t)}const q6=W({tan_:j6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bt(r,e){Dc(r);const t=aa(r,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return oa(r,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cr(r,e,t){if(Dc(r),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const n=aa(r,t);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return oa(r,e,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K6(r,e=1,t=!0){const n=C(r,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=n.shape[n.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const i={x:n},a={k:e,sorted:t},[o,c]=G.runKernel(Eu,i,a);return{values:o,indices:c}}const X6=W({topk_:K6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y6(r,e=0,t=1,n,s){if(n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new o6(e,t,n,!0,s),a=Mr(r,n);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const J6=W({truncatedNormal_:Y6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z6(r,e=0){const t=C(r,"x","unique","string_or_numeric");z(t.rank>0,()=>"The input tensor must be at least 1D");const n={x:t},s={axis:e},[i,a]=G.runKernel(By,n,s);return{values:i,indices:a}}const pm=W({unique_:Z6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q6(r,e=0){const t=C(r,"x","unstack","string_or_numeric");z(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const n={value:t},s={axis:e};return G.runKernel(qp,n,s)}const fs=W({unstack_:Q6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e8(r,e){const t=[];for(let i=0;i<e.length;i++)e[i]&&t.push(i);const n=Mr(r,"int32"),s=Mr([t.length,r.length],"int32");for(let i=0;i<t.length;i++){const a=n.indexToLoc(t[i]),o=i*r.length;s.values.set(a,o)}return s.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function t8(r){const e=C(r,"condition","whereAsync","bool"),t=await e.data(),n=e8(e.shape,t);return r!==e&&e.dispose(),n}const n8=t8;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r8(r,e="euclidean",t=null,n=!1){r=C(r,"x","norm");const s=fm(r,e,t);let i=s.shape;if(n){const a=wr(t,r.shape);i=Gn(s.shape,a)}return pe(s,i)}function fm(r,e,t=null){if(r.rank===0)return En(r);if(r.rank!==1&&t===null)return fm(pe(r,[-1]),e,t);if(r.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return mt(En(r),t);if(e===1/0)return Qs(En(r),t);if(e===-1/0)return rl(En(r),t);if(e==="euclidean"||e===2)return al(mt(Jf(En(r),lt(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Qs(mt(En(r),t[0]),t[1]-1);if(e===1/0)return Qs(mt(En(r),t[1]),t[0]);if(e===-1/0)return rl(mt(En(r),t[1]),t[0]);if(e==="fro"||e==="euclidean")return al(mt(sl(r),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const mm=W({norm_:r8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s8(r,e,t){const n=C(r,"indices","scatterND","int32"),s=C(e,"updates","scatterND");Y4(s,n,t);const i={indices:n,updates:s},a={shape:t};return G.runKernel(bu,i,a)}const i8=W({scatterND_:s8});function a8(r,e,t,n){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);const s=r.rank>0?r.shape[0]:1,i=r.rank>1?r.shape[1]:1;if(t.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${i}.`);const a=e.size;if(!(e.rank===0||e.rank===1&&a===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o8(r,e,t,n=0){const s=C(r,"sparseIndices","sparseToDense","int32"),i=C(e,"sparseValues","sparseToDense"),a=C(n,"defaultValue","sparseToDense",i.dtype);a8(s,i,t,a);const o={sparseIndices:s,sparseValues:i,defaultValue:a},c={outputShape:t};return G.runKernel(ky,o,c)}const gm=W({sparseToDense_:o8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c8(r,e){const t=C(e,"indices","gatherND","int32"),s={params:C(r,"x","gatherND","string_or_numeric"),indices:t};return G.runKernel(ru,s)}const u8=W({gatherND_:c8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l8(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function ym(r,e,t){const n=1-r%2,s=new Float32Array(r);for(let i=0;i<r;++i){const a=2*Math.PI*i/(r+n-1);s[i]=e-t*Math.cos(a)}return Bt(s,"float32")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h8(r,e,t,n,s,i="NHWC",a){let o=r;r.rank===3&&(o=pe(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let c=e;c.rank===3&&(c=pe(e,[1,e.shape[0],e.shape[1],e.shape[2]])),z(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),z(c.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`),z(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const l=i==="NHWC"?o.shape[3]:o.shape[1],u=i==="NHWC"?c.shape[3]:c.shape[1];z(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),z(u===t[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${t[3]}).`),On("conv2dDerFilter",s,a);const h={x:o,dy:c},d={strides:n,pad:s,dataFormat:i,dimRoundingMode:a,filterShape:t};return G.runKernel(sy,h,d)}const d8=W({conv2DBackpropFilter_:h8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ol(r,e,t){if(t==null||t==="linear")return r;if(t==="relu")return Ke(r,$6(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function cl(r,e){let t=e;const n=W4(r.shape,e.shape);return n.length>0&&(t=mt(t,n)),pe(t,r.shape)}function ul(r,e,t,n){if(e==="linear")return r;if(e==="relu")return wo(r);if(e==="elu")return Uf(r);if(e==="relu6")return cm(r);if(e==="prelu")return Zf(r,t);if(e==="leakyrelu")return $f(r,n);if(e==="sigmoid")return Yu(r);throw new Error(`Unknown fused activation ${e}.`)}const ll=(r,e)=>!(r>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p8({x:r,filter:e,strides:t,pad:n,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:c="linear",preluActivationWeights:l,leakyreluAlpha:u}){if(c=c||"linear",ll(G.state.gradientDepth,c)===!1){let T=Ju(r,e,t,n,s,i,a);return o!=null&&(T=Yt(T,o)),ul(T,c,l,u)}const h=C(r,"x","conv2d","float32"),d=C(e,"filter","conv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=pe(h,[1,h.shape[0],h.shape[1],h.shape[2]])),z(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),z(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),On("fused conv2d",n,a),z(p.shape[3]===d.shape[2],()=>`Error in conv2d: depth of input (${p.shape[3]}) must match input depth for filter ${d.shape[2]}.`),z(ls(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),z(s==="NHWC",()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);const m=Ir(p.shape,d.shape,t,i,n,a);let _;o!=null&&(_=C(o,"bias","fused conv2d"),[_]=Tt(_,h),Lt(m.outShape,_.shape));let g;l!=null&&(g=C(l,"prelu weights","fused conv2d"));const y=(T,M)=>{const[S,R,k,O]=M,A=ol(T,k,c);z(_o(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const Y=Of(R.shape,A,S,t,n),B=d8(R,A,S.shape,t,n),H=[Y,B];if(O!=null){const U=cl(O,A);H.push(U)}return H},x={x:p,filter:d,bias:_,preluActivationWeights:g},w={strides:t,pad:n,dataFormat:s,dilations:i,dimRoundingMode:a,activation:c,leakyreluAlpha:u};return o==null?Nr((M,S,R)=>{let k=G.runKernel(ho,x,w);return R([S,M,k]),f&&(k=pe(k,[k.shape[1],k.shape[2],k.shape[3]])),{value:k,gradFunc:y}})(p,d):Nr((M,S,R,k)=>{let O=G.runKernel(ho,x,w);return k([S,M,O,R]),f&&(O=pe(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:y}})(p,d,_)}const f8=W({fusedConv2d_:p8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m8(r,e,t,n,s,i=[1,1],a){let o=r;r.rank===3&&(o=pe(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let c=e;c.rank===3&&(c=pe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:o,dy:c},u={strides:n,pad:s,dimRoundingMode:a,dilations:i,filterShape:t};return G.runKernel(oy,l,u)}const g8=W({depthwiseConv2dNativeBackpropFilter_:m8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y8(r,e,t,n,s,i=[1,1],a){let o=e,c=!1;e.rank===3&&(c=!0,o=pe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:o,filter:t},u={strides:n,pad:s,dimRoundingMode:a,dilations:i,inputShape:r},h=G.runKernel(cy,l,u);return c?pe(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const _8=W({depthwiseConv2dNativeBackpropInput_:y8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x8({x:r,filter:e,strides:t,pad:n,dataFormat:s="NHWC",dilations:i=[1,1],dimRoundingMode:a,bias:o,activation:c="linear",preluActivationWeights:l,leakyreluAlpha:u}){if(ll(G.state.gradientDepth,c)===!1){let T=Bf(r,e,t,n,s,i,a);return o!=null&&(T=Yt(T,o)),ul(T,c,l,u)}const h=C(r,"x","depthwiseConv2d","float32"),d=C(e,"filter","depthwiseConv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=pe(h,[1,h.shape[0],h.shape[1],h.shape[2]])),z(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),z(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),z(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),i==null&&(i=[1,1]),z(ls(t,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),On("fused depthwiseConv2d",n,a);const m=Ir(p.shape,d.shape,t,i,n,a,!0);let _;o!=null&&(_=C(o,"bias","fused conv2d"),[_]=Tt(_,h),Lt(m.outShape,_.shape));let g;l!=null&&(g=C(l,"prelu weights","fused depthwiseConv2d"));const y=(T,M)=>{z(_o(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[S,R,k,O]=M,A=ol(T,k,c),Y=_8(R.shape,A,S,t,n,i,a),B=g8(R,A,S.shape,t,n,i,a);if(O!=null){const H=cl(_,A);return[Y,B,H]}return[Y,B]},x={x:p,filter:d,bias:_,preluActivationWeights:g},w={strides:t,pad:n,dataFormat:s,dilations:i,dimRoundingMode:a,activation:c,leakyreluAlpha:u};return o==null?Nr((M,S,R)=>{let k=G.runKernel(po,x,w);return R([S,M,k]),f&&(k=pe(k,[k.shape[1],k.shape[2],k.shape[3]])),{value:k,gradFunc:y}})(p,d):Nr((M,S,R,k)=>{let O=G.runKernel(po,x,w);return k([S,M,O,R]),f&&(O=pe(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:y}})(p,d,_)}const b8=W({fusedDepthwiseConv2d_:x8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v8({a:r,b:e,transposeA:t=!1,transposeB:n=!1,bias:s,activation:i="linear",preluActivationWeights:a,leakyreluAlpha:o}){if(ll(G.state.gradientDepth,i)===!1){let A=Ot(r,e,t,n);return s!=null&&(A=Yt(A,s)),ul(A,i,a,o)}let c=C(r,"a","fused matMul"),l=C(e,"b","fused matMul");[c,l]=Tt(c,l);const u=t?c.shape[c.rank-2]:c.shape[c.rank-1],h=n?l.shape[l.rank-1]:l.shape[l.rank-2],d=t?c.shape[c.rank-1]:c.shape[c.rank-2],p=n?l.shape[l.rank-2]:l.shape[l.rank-1],f=c.shape.slice(0,-2),m=l.shape.slice(0,-2),_=Ne(f),g=Ne(m);z(u===h,()=>`Error in fused matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${c.shape} and ${l.shape} and transposeA=${t} and transposeB=${n} must match.`);const x=Lt(c.shape.slice(0,-2),l.shape.slice(0,-2)).concat([d,p]),w=t?pe(c,[_,u,d]):pe(c,[_,d,u]),T=n?pe(l,[g,p,h]):pe(l,[g,h,p]);let M;s!=null&&(M=C(s,"bias","fused matMul"),[M]=Tt(M,c),Lt(x,M.shape));let S;a!=null&&(S=C(a,"prelu weights","fused matMul"));const R=(A,Y)=>{const[B,H,U,j]=Y,K=ol(pe(A,U.shape),U,i);let se,ue;if(!t&&!n?(se=Ot(K,H,!1,!0),ue=Ot(B,K,!0,!1)):!t&&n?(se=Ot(K,H,!1,!1),ue=Ot(K,B,!0,!1)):t&&!n?(se=Ot(H,K,!1,!0),ue=Ot(B,K,!1,!1)):(se=Ot(H,K,!0,!0),ue=Ot(K,B,!0,!0)),s!=null){const Q=cl(j,K);return[se,ue,Q]}else return[se,ue]},k={a:w,b:T,bias:M,preluActivationWeights:S},O={transposeA:t,transposeB:n,activation:i,leakyreluAlpha:o};return s==null?Nr((Y,B,H)=>{const U=G.runKernel(lo,k,O);return H([Y,B,U]),{value:pe(U,x),gradFunc:R}})(w,T):Nr((Y,B,H,U)=>{const j=G.runKernel(lo,k,O);return U([Y,B,j,H]),{value:pe(j,x),gradFunc:R}})(w,T,M)}const w8=W({fusedMatMul_:v8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S8(r){return ym(r,.54,.46)}const rD=W({hammingWindow_:S8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T8(r){return ym(r,.5,.5)}const E8=W({hannWindow_:T8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M8(r,e,t,n=!1,s=0){let i=0;const a=[];for(;i+e<=r.size;)a.push(Qe(r,i,e)),i+=t;if(n)for(;i<r.size;){const o=i+e-r.size,c=Jt([Qe(r,i,e-o),Qu([o],s)]);a.push(c),i+=t}return a.length===0?Cr([],[0,e]):pe(Jt(a),[a.length,e])}const A8=W({frame_:M8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I8(r,e,t,n,s=E8){n==null&&(n=l8(e));const i=A8(r,e,t),a=Ke(i,s(e));return hm(a,n)}const sD=W({stft_:I8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N8(r,e,t,n,s="bilinear",i=0){const a=C(r,"image","cropAndResize"),o=C(e,"boxes","cropAndResize","float32"),c=C(t,"boxInd","cropAndResize","int32"),l=o.shape[0];z(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),z(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${o.shape}.`),z(c.rank===1&&c.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${o.shape}.`),z(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),z(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),z(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const u={image:a,boxes:o,boxInd:c},h={method:s,extrapolationValue:i,cropSize:n};return G.runKernel(Zc,u,h)}const R8=W({cropAndResize_:N8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C8(r){const e=C(r,"image","flipLeftRight","float32");z(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return G.runKernel(tu,t,{})}const L8=W({flipLeftRight_:C8});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k8(r){const e=C(r,"image","grayscaleToRGB"),t=e.rank-1,n=e.shape[t];z(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),z(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);const s=new Array(e.rank);return s.fill(1,0,t),s[t]=3,ca(e,s)}const D8=W({grayscaleToRGB_:k8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P8(r,e,t=0,n=.5){const s=C(r,"image","rotateWithOffset","float32");z(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const i={image:s},a={radians:e,fillValue:t,center:n};return G.runKernel(Nu,i,a)}const F8=W({rotateWithOffset_:P8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ti(r,e,t,n,s,i){n==null&&(n=.5),s==null&&(s=Number.NEGATIVE_INFINITY),i==null&&(i=0);const a=r.shape[0];return t=Math.min(t,a),z(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),z(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),z(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),z(e.rank===1,()=>"scores must be a 1D tensor"),z(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),z(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:t,iouThreshold:n,scoreThreshold:s,softNmsSigma:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O8(r,e,t,n=.5,s=Number.NEGATIVE_INFINITY){const i=C(r,"boxes","nonMaxSuppression","float32"),a=C(e,"scores","nonMaxSuppression","float32"),o=ti(i,a,t,n,s);t=o.maxOutputSize,n=o.iouThreshold,s=o.scoreThreshold;const c={maxOutputSize:t,iouThreshold:n,scoreThreshold:s};return G.runKernel(hu,{boxes:i,scores:a},c)}const B8=W({nonMaxSuppression_:O8});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z8(r,e,t){const n=U8(r,e,t),s=n<0?-(n+1):n;r.splice(s,0,e)}function U8(r,e,t){return H8(r,e,t||V8)}function V8(r,e){return r>e?1:r<e?-1:0}function H8(r,e,t){let n=0,s=r.length,i=0,a=!1;for(;n<s;){i=n+(s-n>>>1);const o=t(e,r[i]);o>0?n=i+1:(s=i,a=!o)}return a?n:-n-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $8(r,e,t,n,s){return hl(r,e,t,n,s,0)}function G8(r,e,t,n,s,i){return hl(r,e,t,n,s,0,!1,i,!0)}function W8(r,e,t,n,s,i){return hl(r,e,t,n,s,i,!0)}function hl(r,e,t,n,s,i,a=!1,o=!1,c=!1){const l=[];for(let _=0;_<e.length;_++)e[_]>s&&l.push({score:e[_],boxIndex:_,suppressBeginIndex:0});l.sort(_m);const u=i>0?-.5/i:0,h=[],d=[];for(;h.length<t&&l.length>0;){const _=l.pop(),{score:g,boxIndex:y,suppressBeginIndex:x}=_;if(g<s)break;let w=!1;for(let T=h.length-1;T>=x;--T){const M=j8(r,y,h[T]);if(M>=n){w=!0;break}if(_.score=_.score*q8(n,u,M),_.score<=s)break}_.suppressBeginIndex=h.length,w||(_.score===g?(h.push(y),d.push(_.score)):_.score>s&&z8(l,_,_m))}const p=h.length,f=t-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return a&&(m.selectedScores=d),c&&(m.validOutputs=p),m}function j8(r,e,t){const n=r.subarray(e*4,e*4+4),s=r.subarray(t*4,t*4+4),i=Math.min(n[0],n[2]),a=Math.min(n[1],n[3]),o=Math.max(n[0],n[2]),c=Math.max(n[1],n[3]),l=Math.min(s[0],s[2]),u=Math.min(s[1],s[3]),h=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),p=(o-i)*(c-a),f=(h-l)*(d-u);if(p<=0||f<=0)return 0;const m=Math.max(i,l),_=Math.max(a,u),g=Math.min(o,h),y=Math.min(c,d),x=Math.max(g-m,0)*Math.max(y-_,0);return x/(p+f-x)}function q8(r,e,t){const n=Math.exp(e*t*t);return t<=r?n:0}function _m(r,e){return r.score-e.score||r.score===e.score&&e.boxIndex-r.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function K8(r,e,t,n=.5,s=Number.NEGATIVE_INFINITY){const i=C(r,"boxes","nonMaxSuppressionAsync"),a=C(e,"scores","nonMaxSuppressionAsync"),o=ti(i,a,t,n,s);t=o.maxOutputSize,n=o.iouThreshold,s=o.scoreThreshold;const c=await Promise.all([i.data(),a.data()]),l=c[0],u=c[1],{selectedIndices:h}=$8(l,u,t,n,s);return i!==r&&i.dispose(),a!==e&&a.dispose(),Bt(h,"int32")}const X8=K8;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y8(r,e,t,n=.5,s=Number.NEGATIVE_INFINITY,i=0){const a=C(r,"boxes","nonMaxSuppression"),o=C(e,"scores","nonMaxSuppression"),c=ti(a,o,t,n,s,i);t=c.maxOutputSize,n=c.iouThreshold,s=c.scoreThreshold,i=c.softNmsSigma;const l={boxes:a,scores:o},u={maxOutputSize:t,iouThreshold:n,scoreThreshold:s,softNmsSigma:i},h=G.runKernel(pu,l,u);return{selectedIndices:h[0],selectedScores:h[1]}}const J8=W({nonMaxSuppressionWithScore_:Y8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Z8(r,e,t,n=.5,s=Number.NEGATIVE_INFINITY,i=0){const a=C(r,"boxes","nonMaxSuppressionAsync"),o=C(e,"scores","nonMaxSuppressionAsync"),c=ti(a,o,t,n,s,i);t=c.maxOutputSize,n=c.iouThreshold,s=c.scoreThreshold,i=c.softNmsSigma;const l=await Promise.all([a.data(),o.data()]),u=l[0],h=l[1],{selectedIndices:d,selectedScores:p}=W8(u,h,t,n,s,i);return a!==r&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:Bt(d,"int32"),selectedScores:Bt(p)}}const Q8=Z8;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ex(r,e,t,n=.5,s=Number.NEGATIVE_INFINITY,i=!1){const a=C(r,"boxes","nonMaxSuppression"),o=C(e,"scores","nonMaxSuppression"),c=ti(a,o,t,n,s,null),l=c.maxOutputSize,u=c.iouThreshold,h=c.scoreThreshold,d={boxes:a,scores:o},p={maxOutputSize:l,iouThreshold:u,scoreThreshold:h,padToMaxOutputSize:i},f=G.runKernel(du,d,p);return{selectedIndices:f[0],validOutputs:f[1]}}const tx=W({nonMaxSuppressionPadded_:ex});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function nx(r,e,t,n=.5,s=Number.NEGATIVE_INFINITY,i=!1){const a=C(r,"boxes","nonMaxSuppressionAsync"),o=C(e,"scores","nonMaxSuppressionAsync"),c=ti(a,o,t,n,s,null),l=c.maxOutputSize,u=c.iouThreshold,h=c.scoreThreshold,[d,p]=await Promise.all([a.data(),o.data()]),{selectedIndices:f,validOutputs:m}=G8(d,p,l,u,h,i);return a!==r&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:Bt(f,"int32"),validOutputs:lt(m,"int32")}}const rx=nx;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sx(r,e,t=!1,n=!1){const s=C(r,"images","resizeBilinear");z(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),z(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),z(n===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=s,a=!1;s.rank===3&&(a=!0,i=pe(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const o={images:i},c={alignCorners:t,halfPixelCenters:n,size:e},l=G.runKernel(_u,o,c);return a?pe(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const ix=W({resizeBilinear_:sx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ax(r,e,t=!1,n=!1){const s=C(r,"images","resizeNearestNeighbor");z(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),z(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),z(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),z(n===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=s,a=!1;s.rank===3&&(a=!0,i=pe(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const o={images:i},c={alignCorners:t,halfPixelCenters:n,size:e},l=G.runKernel(Iy,o,c);return a?pe(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const ox=W({resizeNearestNeighbor_:ax});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cx(r,e="binary",t=!1,n=.5){const s=C(r,"image","threshold"),i=.2989,a=.587,o=.114,c=s.shape[0]*s.shape[1];let l=Ke(Bt([n]),255),u,h,d,p;if(z(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),z(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),z(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),z(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[u,h,d]=pa(s,[1,1,1],-1);const _=Ke(u,i),g=Ke(h,a),y=Ke(d,o);p=Yt(Yt(_,g),y)}else p=r;if(e==="otsu"){const _=Pf(vt(um(p),"int32"),Sr([]),256);l=ux(_,c)}const f=t?tl(p,l):bo(p,l);return vt(Ke(f,255),"int32")}function ux(r,e){let t=Bt([-1]),n=Bt([0]),s=Bt([0]),i,a,o,c,l,u;for(let h=0;h<r.size-1;h++){i=Qe(r,0,h+1),a=Qe(r,h+1),l=kt(mt(i),e),u=kt(mt(a),e);const d=mt(Ke(i,da(0,i.size)));o=kt(d,mt(i));const p=Qu(a.shape,i.size),f=Yt(da(0,a.size),p),m=Ke(a,f);c=kt(mt(m),mt(a));const _=et(o,c),g=et(o,c),y=Ke(l,u);s=Ke(Ke(y,_),g);const x=bo(s,n);n=Zs(x,s,n),t=Zs(x,Bt([h]),t)}return t}const lx=W({threshold_:cx});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hx(r,e,t="nearest",n="constant",s=0,i){const a=C(r,"image","transform","float32"),o=C(e,"transforms","transform","float32");z(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),z(o.rank===2&&(o.shape[0]===a.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),z(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const c={image:a,transforms:o},l={interpolation:t,fillMode:n,fillValue:s,outputShape:i};return G.runKernel(Mu,c,l)}const dx=W({transform_:hx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function px(r,e,t){z(e%1==0,()=>`bandPart(): numLower must be an integer, got ${e}.`),z(t%1==0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);const n=C(r,"a","bandPart");z(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);const s=n.shape,[i,a]=n.shape.slice(-2);if(!(e<=i))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`);if(!(t<=a))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`);e<0&&(e=i),t<0&&(t=a);const o=pe(da(0,i,1,"int32"),[-1,1]),c=da(0,a,1,"int32"),l=et(o,c),u=qf(tl(l,lt(+e,"int32")),Hf(l,lt(-t,"int32"))),h=ei([i,a],n.dtype);return pe(tr(fs(pe(n,[-1,i,a])).map(d=>Zs(u,d,h))),s)}const iD=W({bandPart_:px});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fx(r){let e;if(Array.isArray(r)){e=!1,z(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=r[0].shape[0];for(let i=1;i<r.length;++i)z(r[i].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[i].shape[0]} vs. ${s})`)}else e=!0,r=pa(r,r.shape[0],0).map(s=>Bn(s,[0]));z(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);const t=[],n=r;for(let s=0;s<r.length;++s)t.push(G.tidy(()=>{let i=n[s];if(s>0)for(let a=0;a<s;++a){const o=Ke(mt(Ke(t[a],i)),t[a]);i=et(i,o)}return kt(i,mm(i,"euclidean"))}));return e?tr(t,0):t}const aD=W({gramSchmidt_:fx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mx(r,e=!1){if(z(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return xm(r,e);{const t=r.shape.slice(0,r.shape.length-2).reduce((c,l)=>c*l),n=fs(pe(r,[t,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),s=[],i=[];n.forEach(c=>{const[l,u]=xm(c,e);s.push(l),i.push(u)});const a=pe(tr(s,0),r.shape),o=pe(tr(i,0),r.shape);return[a,o]}}function xm(r,e=!1){return G.tidy(()=>{z(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);const t=r.shape[0],n=r.shape[1];let s=j5(t),i=cs(r);const a=Cr([[1]],[1,1]);let o=cs(a);const c=t>=n?n:t;for(let l=0;l<c;++l){const u=i,h=o,d=s;[o,i,s]=G.tidy(()=>{const p=Qe(i,[l,l],[t-l,1]),f=mm(p),m=Qe(i,[l,l],[1,1]),_=Zs(bo(m,0),Cr([[-1]]),Cr([[1]])),g=et(m,Ke(_,f)),y=kt(p,g);y.shape[0]===1?o=cs(a):o=Jt([a,Qe(y,[1,0],[y.shape[0]-1,y.shape[1]])],0);const x=la(kt(Ot(_,g),f)),w=Qe(i,[l,0],[t-l,n]),T=Ke(x,o),M=qu(o);if(l===0)i=et(w,Ot(T,Ot(M,w)));else{const k=et(w,Ot(T,Ot(M,w)));i=Jt([Qe(i,[0,0],[l,n]),k],0)}const S=qu(T),R=Qe(s,[0,l],[t,s.shape[1]-l]);if(l===0)s=et(R,Ot(Ot(R,o),S));else{const k=et(R,Ot(Ot(R,o),S));s=Jt([Qe(s,[0,0],[t,l]),k],1)}return[o,i,s]}),s9([u,h,d])}return!e&&t>n&&(s=Qe(s,[0,0],[t,n]),i=Qe(i,[0,0],[n,n])),[s,i]})}const oD=W({qr_:mx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var un;(function(r){r[r.NONE=0]="NONE",r[r.MEAN=1]="MEAN",r[r.SUM=2]="SUM",r[r.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(un||(un={}));function gx(r,e,t=un.SUM_BY_NONZERO_WEIGHTS){const n=C(r,"losses","computeWeightedLoss");let s=null;e!=null&&(s=C(e,"weights","computeWeightedLoss"));const i=s==null?n:Ke(n,s);if(t===un.NONE)return i;if(t===un.SUM)return mt(i);if(t===un.MEAN){if(s==null)return Kf(i);{const a=n.size/s.size,o=kt(mt(i),mt(s));return a>1?kt(o,lt(a)):o}}if(t===un.SUM_BY_NONZERO_WEIGHTS){if(s==null)return kt(mt(i),lt(n.size));{const a=Ke(s,nl(n.shape)),o=vt(mt(Yf(a,lt(0))),"float32");return kt(mt(i),o)}}throw Error(`Unknown reduction: ${t}`)}const Lr=W({computeWeightedLoss_:gx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yx(r,e,t,n=un.SUM_BY_NONZERO_WEIGHTS){const s=C(r,"labels","absoluteDifference"),i=C(e,"predictions","absoluteDifference");let a=null;t!=null&&(a=C(t,"weights","absoluteDifference")),Pn(s.shape,i.shape,"Error in absoluteDifference: ");const o=En(et(s,i));return Lr(o,a,n)}const cD=W({absoluteDifference_:yx});function _x(r,e,t,n,s=un.SUM_BY_NONZERO_WEIGHTS){const i=C(r,"labels","cosineDistance"),a=C(e,"predictions","cosineDistance");let o=null;n!=null&&(o=C(n,"weights","cosineDistance")),Pn(i.shape,a.shape,"Error in cosineDistance: ");const c=lt(1),l=et(c,mt(Ke(i,a),t,!0));return Lr(l,o,s)}const uD=W({cosineDistance_:_x});function xx(r,e,t,n=un.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"labels","hingeLoss");const i=C(e,"predictions","hingeLoss");let a=null;t!=null&&(a=C(t,"weights","hingeLoss")),Pn(s.shape,i.shape,"Error in hingeLoss: ");const o=lt(1);s=et(Ke(lt(2),s),o);const c=wo(et(o,Ke(s,i)));return Lr(c,a,n)}const lD=W({hingeLoss_:xx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bx(r,e,t,n=1,s=un.SUM_BY_NONZERO_WEIGHTS){const i=C(r,"labels","huberLoss"),a=C(e,"predictions","huberLoss");let o=null;t!=null&&(o=C(t,"weights","huberLoss")),Pn(i.shape,a.shape,"Error in huberLoss: ");const c=lt(n),l=En(et(a,i)),u=Xf(l,c),h=et(l,u),d=Yt(Ke(lt(.5),sl(u)),Ke(c,h));return Lr(d,o,s)}const hD=W({huberLoss_:bx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vx(r,e,t,n=1e-7,s=un.SUM_BY_NONZERO_WEIGHTS){const i=C(r,"labels","logLoss"),a=C(e,"predictions","logLoss");let o=null;t!=null&&(o=C(t,"weights","logLoss")),Pn(i.shape,a.shape,"Error in logLoss: ");const c=lt(1),l=lt(n),u=la(Ke(i,ua(Yt(a,l)))),h=Ke(et(c,i),ua(Yt(et(c,a),l))),d=et(u,h);return Lr(d,o,s)}const dD=W({logLoss_:vx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wx(r,e,t,n=un.SUM_BY_NONZERO_WEIGHTS){const s=C(r,"labels","meanSquaredError"),i=C(e,"predictions","meanSquaredError");let a=null;t!=null&&(a=C(t,"weights","meanSquaredError")),Pn(s.shape,i.shape,"Error in meanSquaredError: ");const o=dm(s,i);return Lr(o,a,n)}const pD=W({meanSquaredError_:wx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sx(r,e){const t=C(r,"labels","sigmoidCrossEntropyWithLogits"),n=C(e,"logits","sigmoidCrossEntropyWithLogits");Pn(t.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=wo(n),i=Ke(n,t),a=Gf(hs(la(En(n))));return Yt(et(s,i),a)}function Tx(r,e,t,n=0,s=un.SUM_BY_NONZERO_WEIGHTS){let i=C(r,"multiClassLabels","sigmoidCrossEntropy");const a=C(e,"logits","sigmoidCrossEntropy");let o=null;if(t!=null&&(o=C(t,"weights","sigmoidCrossEntropy")),Pn(i.shape,a.shape,"Error in sigmoidCrossEntropy: "),n>0){const l=lt(n),u=lt(1),h=lt(.5);i=Yt(Ke(i,et(u,l)),Ke(h,l))}const c=Sx(i,a);return Lr(c,o,s)}const fD=W({sigmoidCrossEntropy_:Tx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ex(r,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return Nr((s,i,a)=>{const c=v_(i,[t],!0),l=et(vt(i,"float32"),c);a([s,l]);const u=la(Ke(l,s));return{value:mt(u,[t]),gradFunc:(p,f)=>{const[m,_]=f,g=Gn(p.shape,[t]);return[Ke(pe(p,g),et(vt(m,"float32"),hs(_))),Ke(pe(p,g),et(hs(_),vt(m,"float32")))]}}})(r,e)}function Mx(r,e,t,n=0,s=un.SUM_BY_NONZERO_WEIGHTS){let i=C(r,"onehotLabels","softmaxCrossEntropy");const a=C(e,"logits","softmaxCrossEntropy");let o=null;if(t!=null&&(o=C(t,"weights","softmaxCrossEntropy")),Pn(i.shape,a.shape,"Error in softmaxCrossEntropy: "),n>0){const l=lt(n),u=lt(1),h=lt(i.shape[1]);i=Yt(Ke(i,et(u,l)),kt(l,h))}const c=Ex(i,a);return Lr(c,o,s)}const mD=W({softmaxCrossEntropy_:Mx});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ax(r,e,t,n){const s=C(r,"indices","sparseFillEmptyRows","int32"),i=C(e,"values","sparseFillEmptyRows"),a=C(t,"denseShape","sparseFillEmptyRows","int32"),o=C(n,"defaultValue","sparseFillEmptyRows",i.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(i.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const c={indices:s,values:i,denseShape:a,defaultValue:o},l=G.runKernel(Up,c);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}const Ix=W({sparseFillEmptyRows_:Ax});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nx(r,e,t){const n=C(r,"inputIndices","sparseReshape","int32"),s=C(e,"inputShape","sparseReshape","int32"),i=C(t,"newShape","sparseReshape","int32");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const a={inputIndices:n,inputShape:s,newShape:i},o=G.runKernel(Su,a);return{outputIndices:o[0],outputShape:o[1]}}const Rx=W({sparseReshape_:Nx});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cx(r,e,t){const n=C(r,"data","sparseSegmentMean"),s=C(e,"indices","sparseSegmentMean","int32"),i=C(t,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);const a={data:n,indices:s,segmentIds:i};return G.runKernel(Vp,a)}const Lx=W({sparseSegmentMean_:Cx});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kx(r,e,t){const n=C(r,"data","sparseSegmentSum"),s=C(e,"indices","sparseSegmentSum","int32"),i=C(t,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);const a={data:n,indices:s,segmentIds:i};return G.runKernel(Hp,a)}const Dx=W({sparseSegmentSum_:kx});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Px(r,e,t,n,s,i,a,o){const c=C(r,"data","stringNGrams","string");if(c.dtype!=="string")throw new Error("Data must be of datatype string");if(c.shape.length!==1)throw new Error(`Data must be a vector, saw: ${c.shape}`);const l=C(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const u={separator:t,nGramWidths:n,leftPad:s,rightPad:i,padWidth:a,preserveShortSequences:o},h={data:c,dataSplits:l},d=G.runKernel(Py,h,u);return{nGrams:d[0],nGramsSplits:d[1]}}const Fx=W({stringNGrams_:Px});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ox(r,e,t=!0){const n=C(r,"input","stringSplit","string"),s=C(e,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const i={skipEmpty:t},a={input:n,delimiter:s},o=G.runKernel(Fy,a,i);return{indices:o[0],values:o[1],shape:o[2]}}const Bx=W({stringSplit_:Ox});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zx(r,e){const t=C(r,"input","stringToHashBucketFast","string"),n={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:t};return G.runKernel(Oy,s,n)}const Ux=W({stringToHashBucketFast_:zx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mn={flipLeftRight:L8,grayscaleToRGB:D8,resizeNearestNeighbor:ox,resizeBilinear:ix,rotateWithOffset:F8,cropAndResize:R8,nonMaxSuppression:B8,nonMaxSuppressionAsync:X8,nonMaxSuppressionWithScore:J8,nonMaxSuppressionWithScoreAsync:Q8,nonMaxSuppressionPadded:tx,nonMaxSuppressionPaddedAsync:rx,threshold:lx,transform:dx},To={sparseFillEmptyRows:Ix,sparseReshape:Rx,sparseSegmentMean:Lx,sparseSegmentSum:Dx},dl={stringNGrams:Fx,stringSplit:Bx,stringToHashBucketFast:Ux};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vx(r,e){const t=r[0].length;r.forEach((s,i)=>{z(s.length===t,()=>`Error in concat${t}D: rank of tensors[${i}] must be the same as the rank of the rest (${t})`)}),z(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const n=r[0];r.forEach((s,i)=>{for(let a=0;a<t;a++)z(a===e||s[a]===n[a],()=>`Error in concat${t}D: Shape of tensors[${i}] (${s}) does not match the shape of the rest (${n}) along the non-concatenated axis ${i}.`)})}function pl(r,e){const t=r[0].slice();for(let n=1;n<r.length;n++)t[e]+=r[n][e];return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hx(r,e,t){const n=t*(typeof r=="number"?r:r[0]),s=e*(typeof r=="number"?r:r[1]);return[n,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bm(r,e,t,n=!0){let s=[];if(n)s=s.concat(e.slice(0)),s.push(r[0]/t),s=s.concat(r.slice(1));else{s=s.concat(r[0]);const i=e.length;for(let a=0;a<i;++a)s=s.concat([r[a+1]/e[a],e[a]]);s=s.concat(r.slice(i+1))}return s}function vm(r,e,t=!0){const n=[];if(t){n.push(e);for(let s=e+1;s<r;++s)s<=2*e?(n.push(s),n.push(s-(e+1))):n.push(s)}else{const s=[],i=[];for(let a=1;a<r;++a)a>=e*2+1||a%2==1?i.push(a):s.push(a);n.push(...s),n.push(0),n.push(...i)}return n}function wm(r,e,t,n=!0){const s=[];n?s.push(r[0]/t):s.push(r[0]*t);for(let i=1;i<r.length;++i)i<=e.length?n?s.push(e[i-1]*r[i]):s.push(r[i]/e[i-1]):s.push(r[i]);return s}function $x(r,e){const t=[0];for(let n=0;n<e;++n)t.push(r[n][0]);return t}function Gx(r,e,t){const n=r.slice(0,1);for(let s=0;s<t;++s)n.push(r[s+1]-e[s][0]-e[s][1]);return n}function Wx(r,e,t=0){let n=[];if(typeof e=="number")z(r.shape[t]%e==0,()=>"Number of splits must evenly divide the axis."),n=new Array(e).fill(r.shape[t]/e);else{const s=e.reduce((a,o)=>(o===-1&&(a+=1),a),0);z(s<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const a=e.reduce((o,c)=>c>0?o+c:o);e[i]=r.shape[t]-a}z(r.shape[t]===e.reduce((a,o)=>a+o),()=>"The sum of sizes must match the size of the axis dimension."),n=e}return n}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jx(r){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${r}`}function qx(r,e){return`indices(${r}, 0) is invalid: ${e} < 0`}function Kx(r,e,t){return`indices(${r}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xx(r,e){return`only one output dimension may be -1, not both ${r} and ${e}`}function Yx(r,e){return`size ${r} must be non-negative, not ${e}`}function Jx(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Zx(r,e){const t=Ne(r),n=Ne(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${r} outputShape= ${e}`}function Qx(r,e){const t=Ne(r),n=Ne(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${n}. inputShape=${r} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sm(){return"segment ids must be >= 0"}function eb(){return"segment ids are not increasing"}function tb(r,e){return`Segment id ${r} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function nb(r,e,t){return`Bad: indices[${r}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rb(r,e,t,n){const s=e.shape.length,i=r.shape.length;if(n!==0&&(n<-s||n>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${n}`);if(n<0&&(n+=s),n>i)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${i}).`);if(t<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${t}).`);for(let h=0;h<n;++h)if(r.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${r.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const a=r.shape[t],o=[];let c=1,l=1,u=1;for(let h=0;h<n;++h)o.push(r.shape[h]),c*=r.shape[h];for(let h=n;h<t;h++)o.push(r.shape[h]),l*=r.shape[h];for(let h=n;h<s;h++)o.push(e.shape[h]);for(let h=t+1;h<i;h++)o.push(r.shape[h]),u*=r.shape[h];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:a,outputShape:o}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tm(r){try{return r.map(e=>Cu(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function Em(r){return r.map(e=>ef(e))}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sb=nt();sb.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,r=>{r&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var An;(function(r){r[r.DT_INVALID=0]="DT_INVALID",r[r.DT_FLOAT=1]="DT_FLOAT",r[r.DT_DOUBLE=2]="DT_DOUBLE",r[r.DT_INT32=3]="DT_INT32",r[r.DT_UINT8=4]="DT_UINT8",r[r.DT_INT16=5]="DT_INT16",r[r.DT_INT8=6]="DT_INT8",r[r.DT_STRING=7]="DT_STRING",r[r.DT_COMPLEX64=8]="DT_COMPLEX64",r[r.DT_INT64=9]="DT_INT64",r[r.DT_BOOL=10]="DT_BOOL",r[r.DT_QINT8=11]="DT_QINT8",r[r.DT_QUINT8=12]="DT_QUINT8",r[r.DT_QINT32=13]="DT_QINT32",r[r.DT_BFLOAT16=14]="DT_BFLOAT16",r[r.DT_QINT16=15]="DT_QINT16",r[r.DT_QUINT16=16]="DT_QUINT16",r[r.DT_UINT16=17]="DT_UINT16",r[r.DT_COMPLEX128=18]="DT_COMPLEX128",r[r.DT_HALF=19]="DT_HALF",r[r.DT_RESOURCE=20]="DT_RESOURCE",r[r.DT_VARIANT=21]="DT_VARIANT",r[r.DT_UINT32=22]="DT_UINT32",r[r.DT_UINT64=23]="DT_UINT64",r[r.DT_FLOAT_REF=101]="DT_FLOAT_REF",r[r.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",r[r.DT_INT32_REF=103]="DT_INT32_REF",r[r.DT_UINT8_REF=104]="DT_UINT8_REF",r[r.DT_INT16_REF=105]="DT_INT16_REF",r[r.DT_INT8_REF=106]="DT_INT8_REF",r[r.DT_STRING_REF=107]="DT_STRING_REF",r[r.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",r[r.DT_INT64_REF=109]="DT_INT64_REF",r[r.DT_BOOL_REF=110]="DT_BOOL_REF",r[r.DT_QINT8_REF=111]="DT_QINT8_REF",r[r.DT_QUINT8_REF=112]="DT_QUINT8_REF",r[r.DT_QINT32_REF=113]="DT_QINT32_REF",r[r.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",r[r.DT_QINT16_REF=115]="DT_QINT16_REF",r[r.DT_QUINT16_REF=116]="DT_QUINT16_REF",r[r.DT_UINT16_REF=117]="DT_UINT16_REF",r[r.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",r[r.DT_HALF_REF=119]="DT_HALF_REF",r[r.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",r[r.DT_VARIANT_REF=121]="DT_VARIANT_REF",r[r.DT_UINT32_REF=122]="DT_UINT32_REF",r[r.DT_UINT64_REF=123]="DT_UINT64_REF"})(An||(An={}));var Mm;(function(r){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(r.CheckpointFormatVersion||(r.CheckpointFormatVersion={}))})(Mm||(Mm={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ib={};function Am(r){return ib[r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b(r,e,t,n,s){const i=e.inputParams[r];if(i&&i.inputIndexStart!==void 0){const o=i.inputIndexStart,c=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?o+1:i.inputIndexEnd;if(i.type==="tensor")return nn(e.inputNames[i.inputIndexStart],t,n,s);if(i.type==="tensors")return e.inputNames.slice(o,c).map(d=>nn(d,t,n,s));const l=nn(e.inputNames.slice(o)[0],t,n,s),u=l.dataSync();return i.type==="number"?u[0]:Oc(l.shape,u)}const a=e.attrParams[r];return a&&a.value}function nn(r,e,t,n){const[s,i]=fn(r);if(n!=null){const o=n.getHashTableHandleByName(s);if(o!=null)return o}const a=t.currentContextIds.find(o=>!!e[Eo(s,o)]);return a!==void 0?e[Eo(s,a)][i]:void 0}function ab(r,e,t){return e[Eo(r,t.currentContextId)]}function Wn(r,e){const[t,n,s]=fn(r);return[Eo(t,e&&e.currentContextId),n,s]}function Eo(r,e){return e?`${r}-${e}`:r}function fn(r){const e=r.split(":");if(e.length===1)return[r,0,void 0];const t=e[0],n=e.length===3?e[1]:void 0,s=Number(e[e.length-1]);return[t,s,n]}function Mo(r,e,t){let n=b("pad",r,e,t);if(n==="explicit"){n=b("explicitPaddings",r,e,t);const s=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)s[i][0]=n[i*2],s[i][1]=n[i*2+1];return s}return n}function nr(r){return r.kept?r:cs(r)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ob=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var cb=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:ob});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ub=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var lb=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:ub});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hb=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}];var db=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:hb});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pb=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var fb=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:pb});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mb=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var gb=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:mb});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yb=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var _b=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:yb});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xb=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var bb=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:xb});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vb=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var wb=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:vb});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sb=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var Tb=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:Sb});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eb=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}];var Mb=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:Eb});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ab=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var Ib=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:Ab});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nb=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var Rb=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:Nb});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cb=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var Lb=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:Cb});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kb=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var Db=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:kb});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pb=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var Fb=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:Pb});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ob=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var Bb=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:Ob});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zb=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var Ub=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:zb});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vb=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var Hb=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:Vb});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $b=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var Gb=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:$b});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Im{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[cb,lb,db,fb,gb,_b,bb,wb,Tb,Mb,Ib,Rb,Lb,Db,Fb,Bb,Ub,Hb,Gb],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,s)=>(n[s.tfOpName]=s,n),{})}transformGraph(e,t={}){const n=e.node,s=[],i=[],a=[],o=n.reduce((m,_)=>(m[_.name]=this.mapNode(_),_.op.startsWith("Placeholder")?s.push(m[_.name]):_.op==="Const"?i.push(m[_.name]):(_.input==null||_.input.length===0)&&a.push(m[_.name]),m),{});let c=[];const l=[];let u={},h={};t!=null&&(u=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const d=Object.keys(o);d.forEach(m=>{const _=o[m];_.inputNames.forEach((g,y)=>{const[x,,w]=Wn(g),T=o[x];if(T.outputs!=null){const M=T.outputs.indexOf(w);if(M!==-1){const S=`${x}:${M}`;_.inputNames[y]=S}}_.inputs.push(T),T.children.push(_)})}),Object.keys(h).length===0?d.forEach(m=>{const _=o[m];_.children.length===0&&l.push(_)}):Object.keys(h).forEach(m=>{const[_]=Wn(m),g=o[_];g!=null&&(g.signatureKey=h[m],l.push(g))}),Object.keys(u).length>0?Object.keys(u).forEach(m=>{const[_]=Wn(m),g=o[_];g&&(g.signatureKey=u[m],c.push(g))}):c=s;let p={};e.library!=null&&e.library.function!=null&&(p=e.library.function.reduce((m,_)=>(m[_.signature.name]=this.mapFunction(_),m),{}));const f={nodes:o,inputs:c,outputs:l,weights:i,placeholders:s,signature:t,functions:p};return a.length>0&&(f.initNodes=a),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){const t=Am(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.substr(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((s,i)=>(s[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},s),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((s,i)=>{const a=i.type;let o;switch(i.type){case"string":o=fl(e.attr,i.tfName,i.defaultValue),o===void 0&&!!i.tfDeprecatedName&&(o=fl(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":o=wl(e.attr,i.tfName,i.defaultValue),o===void 0&&!!i.tfDeprecatedName&&(o=wl(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":o=gl(e.attr,i.tfName,i.defaultValue||0),o===void 0&&!!i.tfDeprecatedName&&(o=gl(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":o=vl(e.attr,i.tfName,i.defaultValue),o===void 0&&!!i.tfDeprecatedName&&(o=vl(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":o=ml(e.attr,i.tfName,i.defaultValue),o===void 0&&!!i.tfDeprecatedName&&(o=ml(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":o=Tl(e.attr,i.tfName,i.defaultValue),o===void 0&&!!i.tfDeprecatedName&&(o=Tl(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":o=bl(e.attr,i.tfName,i.defaultValue),o===void 0&&!!i.tfDeprecatedName&&(o=bl(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":o=Sl(e.attr,i.tfName,i.defaultValue),o===void 0&&!!i.tfDeprecatedName&&(o=Sl(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":o=_l(e.attr,i.tfName,i.defaultValue),o===void 0&&!!i.tfDeprecatedName&&(o=_l(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":o=xl(e.attr,i.tfName,i.defaultValue),o===void 0&&!!i.tfDeprecatedName&&(o=xl(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":o=Rm(e.attr,i.tfName,i.defaultValue),o===void 0&&!!i.tfDeprecatedName&&(o=Rm(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${e.op}`)}return s[i.name]={value:o,type:a},s},{})),n}mapFunction(e){const t=e.nodeDef,n=[],s=[];let i={};t!=null&&(i=t.reduce((h,d)=>(h[d.name]=this.mapNode(d),d.op==="Const"&&s.push(h[d.name]),h),{}));const a=[],o=[];e.signature.inputArg.forEach(h=>{const[d]=Wn(h.name),p={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:yl(h.type),type:"dtype"}},children:[]};p.signatureKey=h.name,a.push(p),i[d]=p}),Object.keys(i).forEach(h=>{const d=i[h];d.inputNames.forEach((p,f)=>{const[m,,_]=Wn(p),g=i[m];if(g.outputs!=null){const y=g.outputs.indexOf(_);if(y!==-1){const x=`${m}:${y}`;d.inputNames[f]=x}}d.inputs.push(g),g.children.push(d)})});const l=e.ret;e.signature.outputArg.forEach(h=>{const[d,p]=Wn(l[h.name]),f=i[d];f!=null&&(f.defaultOutput=p,o.push(f))});const u=this.mapArgsToSignature(e);return{nodes:i,inputs:a,outputs:o,weights:s,placeholders:n,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}}function Wb(r){const e=nt().global;if(typeof e.atob!="undefined")return e.atob(r);if(typeof Buffer!="undefined")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Nm(r,e){const t=Array.isArray(r)?String.fromCharCode.apply(null,r):Wb(r);return e?t:t.toLowerCase()}function fl(r,e,t,n=!1){const s=r[e];return s!=null?Nm(s.s,n):t}function ml(r,e,t){const n=r[e];return n?n.b:t}function gl(r,e,t){const n=r[e]||{},s=n.i!=null?n.i:n.f!=null?n.f:t;return typeof s=="number"?s:parseInt(s,10)}function yl(r){switch(typeof r=="string"&&(r=An[r]),r){case An.DT_FLOAT:case An.DT_HALF:return"float32";case An.DT_INT32:case An.DT_INT64:case An.DT_INT8:case An.DT_UINT8:return"int32";case An.DT_BOOL:return"bool";case An.DT_DOUBLE:return"float32";case An.DT_STRING:return"string";default:return null}}function Rm(r,e,t){const n=r[e];return n&&n.func?n.func.name:t}function _l(r,e,t){const n=r[e];return n&&n.type?yl(n.type):t}function xl(r,e,t){const n=r[e];return n&&n.list&&n.list.type?n.list.type.map(s=>yl(s)):t}function Cm(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function bl(r,e,t){const n=r[e];return n&&n.shape?Cm(n.shape):t}function vl(r,e,t){const n=r[e];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):t}function wl(r,e,t,n=!1){const s=r[e];return s&&s.list&&s.list.s?s.list.s.map(i=>Nm(i,n)):t}function Sl(r,e,t){const n=r[e];return n&&n.list&&n.list.shape?n.list.shape.map(s=>Cm(s)):t}function Tl(r,e,t){const n=r[e];return n&&n.list&&n.list.b?n.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jb{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,i)=>(s[i]=this.getAttr(i),s),{}))}getInput(e){return nn(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(n.tensor!=null)return nn(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return gl(this.node.rawAttrs,e,t);if(n.s!=null)return fl(this.node.rawAttrs,e,t);if(n.b!=null)return ml(this.node.rawAttrs,e,t);if(n.shape!=null)return bl(this.node.rawAttrs,e,t);if(n.type!=null)return _l(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return vl(this.node.rawAttrs,e,t);if(n.list.s!=null)return wl(this.node.rawAttrs,e,t);if(n.list.shape!=null)return Sl(this.node.rawAttrs,e,t);if(n.list.b!=null)return Tl(this.node.rawAttrs,e,t);if(n.list.type!=null)return xl(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qb=(r,e,t)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[Yt(b("a",r,e,t),b("b",r,e,t))];case"AddN":return[_9(b("tensors",r,e,t))];case"FloorMod":case"Mod":return[V_(b("a",r,e,t),b("b",r,e,t))];case"Mul":return[Ke(b("a",r,e,t),b("b",r,e,t))];case"RealDiv":case"Div":return[kt(b("a",r,e,t),b("b",r,e,t))];case"DivNoNan":return[D5(b("a",r,e,t),b("b",r,e,t))];case"FloorDiv":return[Cf(b("a",r,e,t),b("b",r,e,t))];case"Sub":return[et(b("a",r,e,t),b("b",r,e,t))];case"Minimum":return[Xf(b("a",r,e,t),b("b",r,e,t))];case"Maximum":return[D_(b("a",r,e,t),b("b",r,e,t))];case"Pow":return[Jf(b("a",r,e,t),b("b",r,e,t))];case"SquaredDifference":return[dm(b("a",r,e,t),b("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kb=(r,e,t)=>{switch(r.op){case"Abs":case"ComplexAbs":return[En(b("x",r,e,t))];case"Acos":return[f9(b("x",r,e,t))];case"Acosh":return[g9(b("x",r,e,t))];case"Asin":return[I9(b("x",r,e,t))];case"Asinh":return[R9(b("x",r,e,t))];case"Atan":return[L9(b("x",r,e,t))];case"Atan2":return[D9(b("x",r,e,t),b("y",r,e,t))];case"Atanh":return[F9(b("x",r,e,t))];case"Ceil":return[i5(b("x",r,e,t))];case"Complex":return[ss(b("real",r,e,t),b("imag",r,e,t))];case"Cos":return[_5(b("x",r,e,t))];case"Cosh":return[b5(b("x",r,e,t))];case"Elu":return[Uf(b("x",r,e,t))];case"Erf":return[z5(b("x",r,e,t))];case"Exp":return[hs(b("x",r,e,t))];case"Expm1":return[$5(b("x",r,e,t))];case"Floor":return[K5(b("x",r,e,t))];case"Log":return[ua(b("x",r,e,t))];case"Log1p":return[Gf(b("x",r,e,t))];case"Imag":return[el(b("x",r,e,t))];case"Neg":return[la(b("x",r,e,t))];case"Reciprocal":return[p6(b("x",r,e,t))];case"Real":return[vo(b("x",r,e,t))];case"Relu":return[wo(b("x",r,e,t))];case"Round":return[um(b("x",r,e,t))];case"Selu":return[v6(b("x",r,e,t))];case"Sigmoid":return[Yu(b("x",r,e,t))];case"Sin":return[A6(b("x",r,e,t))];case"Sign":return[E6(b("x",r,e,t))];case"Sinh":return[N6(b("x",r,e,t))];case"Softplus":return[d_(b("x",r,e,t))];case"Sqrt":return[al(b("x",r,e,t))];case"Square":return[sl(b("x",r,e,t))];case"Tanh":return[X9(b("x",r,e,t))];case"Tan":return[q6(b("x",r,e,t))];case"ClipByValue":return[o5(b("x",r,e,t),b("clipValueMin",r,e,t),b("clipValueMax",r,e,t))];case"Relu6":return[cm(b("x",r,e,t))];case"Rsqrt":return[x6(nn(r.inputNames[0],e,t))];case"Prod":return[Qf(b("x",r,e,t),b("axes",r,e,t))];case"LeakyRelu":return[$f(b("x",r,e,t),b("alpha",r,e,t))];case"Prelu":return[Zf(b("x",r,e,t),b("alpha",r,e,t))];case"IsNan":return[e_(nn(r.inputNames[0],e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function In(r,e,t=""){if(!(typeof r=="number"||typeof e=="number")){z(r.length===e.length,()=>t+` Shapes ${r} and ${e} must match`);for(let n=0;n<r.length;n++){const s=r[n],i=e[n];z(s<0||i<0||s===i,()=>t+` Shapes ${r} and ${e} must match`)}}}function Lm(r){return!(typeof r=="number"||r.some(e=>e<0))}function fa(r,e,t){let n=El(r,t);const s=!Lm(n);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(s&&e.forEach(i=>{n=El(i.shape,n)}),!Lm(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function El(r,e){if(typeof r=="number")return e;if(typeof e=="number")return r;if(r.length!==e.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${e}`);const t=[];for(let n=0;n<r.length;++n){const s=r[n],i=e[n];if(s>=0&&i>=0&&s!==i)throw new Error(`Incompatible shape during merge: ${r} vs. ${e}`);t[n]=s>=0?s:i}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xb{constructor(e,t,n,s,i,a,o){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=s,this.identicalElementShapes=i,this.dynamicSize=a,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=lt(0),Ar(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),In(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Ar(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,s)=>this.write(n,t[s]))}gather(e,t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return Sr([],[0].concat(this.elementShape));const n=this.readMany(e);return In(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),tr(n,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Sr([],[0].concat(this.elementShape));const t=[];for(let s=0;s<this.size();s++)t.push(s);const n=this.readMany(t);return In(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),Jt(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,fs(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const s=e.map(c=>(n+=c,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=n===0?0:t.size/n,a=[];rt(()=>{t=pe(t,[1,n,i]);for(let c=0;c<e.length;++c){const l=c===0?0:s[c-1],u=[0,l,0],h=[1,e[c],i];a[c]=pe(Qe(t,u,h),this.elementShape)}return a});const o=[];for(let c=0;c<e.length;c++)o[c]=c;this.writeMany(o,a)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ni{constructor(e,t,n,s=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,e!=null&&e.forEach(i=>{if(n!==i.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${i.dtype}`);In(t,i.shape,"TensorList shape mismatch: "),Ar(i)}),this.idTensor=lt(0),this.maxNumElements=s,Ar(this.idTensor)}get id(){return this.idTensor.id}copy(){return new ni([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);In(e,this.elementShape,"TensorList shape mismatch: ");const s=fa(this.elementShape,this.tensors,e);return rt(()=>{const i=this.tensors.map(a=>pe(a,s));return tr(i,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const n=fa(this.elementShape,this.tensors,e),s=this.tensors.pop();return In(s.shape,e,"TensorList shape mismatch: "),pe(s,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(In(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ar(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);In(this.tensors[e].shape,t,"TensorList shape mismatch: ");const s=fa(this.elementShape,this.tensors,t);return pe(this.tensors[e],s)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);In(this.elementShape,t.shape,"TensorList shape mismatch: "),Ar(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);In(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=fa(this.elementShape,this.tensors,n);return e.length===0?Sr([],[0].concat(s)):rt(()=>{const i=e.map(a=>pe(this.tensors[a],s));return tr(i,0)})}concat(e,t){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);In(this.elementShape,t,"TensorList shape mismatch: ");const n=fa(this.elementShape,this.tensors,t);return this.size()===0?Sr([],[0].concat(n)):rt(()=>{const s=this.tensors.map(i=>pe(i,n));return Jt(s,0)})}}function Yb(r,e,t){const n=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==t)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${t}`);const s=r.shape.slice(1);In(s,e,"TensorList shape mismatch: ");const i=fs(r);return new ni(i,e,n)}function Jb(r,e,t){return new ni([],r,e,t)}function Zb(r,e,t,n){if(e.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${r.shape[0]}`);const s=Math.max(...e);if(n!=null&&n!==-1&&s>=n)throw new Error(`Max index must be < array size (${s}  vs. ${n})`);const i=new ni([],t,r.dtype,n),a=fs(r,0);return e.forEach((o,c)=>{i.setItem(o,a[c])}),i}function Qb(r,e,t){let n=0;const s=e.map(u=>(n+=u,n));if(n!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${r.shape}`);const i=r.shape.slice(1),a=El(i,t),o=n===0?0:r.size/n,c=rt(()=>{const u=[];r=pe(r,[1,n,o]);for(let h=0;h<e.length;++h){const d=h===0?0:s[h-1],p=[0,d,0],f=[1,e[h],o];u[h]=pe(Qe(r,p,f),a)}return r.dispose(),u}),l=new ni([],t,r.dtype,e.length);for(let u=0;u<c.length;u++)l.setItem(u,c[u]);return l}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ev=async(r,e,t)=>{switch(r.op){case"If":case"StatelessIf":{const n=b("thenBranch",r,e,t),s=b("elseBranch",r,e,t),i=b("cond",r,e,t),a=b("args",r,e,t);return(await i.data())[0]?t.functionMap[n].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[s].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const n=b("body",r,e,t),s=b("cond",r,e,t),i=b("args",r,e,t),a=await t.functionMap[s].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap),o=i.map(u=>u.id);let c=await a[0].data();a.forEach(u=>{!u.kept&&o.indexOf(u.id)===-1&&u.dispose()});let l=i;for(;c[0];){const u=l;l=await t.functionMap[n].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);const h=l.map(p=>p.id);u.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()});const d=await t.functionMap[s].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);c=await d[0].data(),d.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()})}return l}case"LoopCond":{const n=b("pred",r,e,t);return[nr(n)]}case"Switch":{const n=b("pred",r,e,t);let s=b("data",r,e,t);return s.kept||(s=nr(s)),(await n.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const n=r.inputNames.find(s=>nn(s,e,t)!==void 0);if(n){const s=nn(n,e,t);return[nr(s)]}return}case"Enter":{const n=b("frameName",r,e,t),s=b("tensor",r,e,t);return t.enterFrame(n),[nr(s)]}case"Exit":{const n=b("tensor",r,e,t);return t.exitFrame(),[nr(n)]}case"NextIteration":{const n=b("tensor",r,e,t);return t.nextIteration(),[nr(n)]}case"TensorArrayV3":{const n=b("size",r,e,t),s=b("dtype",r,e,t),i=b("elementShape",r,e,t),a=b("dynamicSize",r,e,t),o=b("clearAfterRead",r,e,t),c=b("identicalElementShapes",r,e,t),l=b("name",r,e,t),u=new Xb(l,s,n,i,c,a,o);return t.addTensorArray(u),[u.idTensor,lt(1)]}case"TensorArrayWriteV3":{const n=b("tensorArrayId",r,e,t),s=b("index",r,e,t),i=b("tensor",r,e,t),a=t.getTensorArray(n.id);return a.write(s,i),[a.idTensor]}case"TensorArrayReadV3":{const n=b("tensorArrayId",r,e,t),s=b("index",r,e,t);return[t.getTensorArray(n.id).read(s)]}case"TensorArrayGatherV3":{const n=b("tensorArrayId",r,e,t),s=b("indices",r,e,t),i=b("dtype",r,e,t);return[t.getTensorArray(n.id).gather(s,i)]}case"TensorArrayScatterV3":{const n=b("tensorArrayId",r,e,t),s=b("indices",r,e,t),i=b("tensor",r,e,t),a=t.getTensorArray(n.id);return a.scatter(s,i),[a.idTensor]}case"TensorArrayConcatV3":{const n=b("tensorArrayId",r,e,t),s=t.getTensorArray(n.id),i=b("dtype",r,e,t);return[s.concat(i)]}case"TensorArraySplitV3":{const n=b("tensorArrayId",r,e,t),s=b("tensor",r,e,t),i=b("lengths",r,e,t),a=t.getTensorArray(n.id);return a.split(i,s),[a.idTensor]}case"TensorArraySizeV3":{const n=b("tensorArrayId",r,e,t),s=t.getTensorArray(n.id);return[lt(s.size(),"int32")]}case"TensorArrayCloseV3":{const n=b("tensorArrayId",r,e,t),s=t.getTensorArray(n.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const n=b("tensorListId",r,e,t),s=b("index",r,e,t),i=b("tensor",r,e,t),a=t.getTensorList(n.id);return a.setItem(s,i),[a.idTensor]}case"TensorListGetItem":{const n=b("tensorListId",r,e,t),s=b("index",r,e,t),i=b("elementShape",r,e,t),a=b("elementDType",r,e,t);return[t.getTensorList(n.id).getItem(s,i,a)]}case"TensorListScatterV2":case"TensorListScatter":{const n=b("indices",r,e,t),s=b("tensor",r,e,t),i=b("elementShape",r,e,t),a=b("numElements",r,e,t),o=Zb(s,n,i,a);return t.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const n=b("elementShape",r,e,t),s=b("elementDType",r,e,t);let i;r.op==="TensorListReserve"?i="numElements":i="maxNumElements";const a=b(i,r,e,t),o=Jb(n,s,a);return t.addTensorList(o),[o.idTensor]}case"TensorListGather":{const n=b("tensorListId",r,e,t),s=b("indices",r,e,t),i=b("elementShape",r,e,t),a=b("elementDType",r,e,t);return[t.getTensorList(n.id).gather(s,a,i)]}case"TensorListStack":{const n=b("tensorListId",r,e,t),s=b("elementShape",r,e,t),i=b("elementDType",r,e,t),a=b("numElements",r,e,t);return[t.getTensorList(n.id).stack(s,i,a)]}case"TensorListFromTensor":{const n=b("tensor",r,e,t),s=b("elementShape",r,e,t),i=b("elementDType",r,e,t),a=Yb(n,s,i);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":{const n=b("tensorListId",r,e,t),s=t.getTensorList(n.id),i=b("dtype",r,e,t),a=b("elementShape",r,e,t);return[s.concat(i,a)]}case"TensorListPushBack":{const n=b("tensorListId",r,e,t),s=b("tensor",r,e,t),i=t.getTensorList(n.id);return i.pushBack(s),[i.idTensor]}case"TensorListPopBack":{const n=b("tensorListId",r,e,t),s=b("elementShape",r,e,t),i=b("elementDType",r,e,t);return[t.getTensorList(n.id).popBack(s,i)]}case"TensorListSplit":{const n=b("tensor",r,e,t),s=b("elementShape",r,e,t),i=b("lengths",r,e,t),a=Qb(n,i,s);return t.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function km(r,e,t){const[n,s]=b("fusedOps",r,e,t),i=n==="biasadd",a=!i,o=s==="prelu",c=n==="fusedbatchnorm",l=b("numArgs",r,e,t);if(i){if(o&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&i&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=b("strides",r,e,t),h=Mo(r,e,t),d=b("dataFormat",r,e,t).toUpperCase(),p=b("dilations",r,e,t);let[f,m]=b("args",r,e,t);a&&(m=f,f=void 0);const _=b("leakyreluAlpha",r,e,t);return{stride:u,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:_}}const tv=(r,e,t)=>{switch(r.op){case"Conv1D":{const n=b("stride",r,e,t),s=b("pad",r,e,t),i=b("dataFormat",r,e,t).toUpperCase(),a=b("dilation",r,e,t);return[h5(b("x",r,e,t),b("filter",r,e,t),n,s,i,a)]}case"Conv2D":{const n=b("strides",r,e,t),s=Mo(r,e,t),i=b("dataFormat",r,e,t).toUpperCase(),a=b("dilations",r,e,t);return[Ju(b("x",r,e,t),b("filter",r,e,t),[n[1],n[2]],s,i,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:n,pad:s,dataFormat:i,dilations:a,biasArg:o,preluArg:c,activationFunc:l,leakyreluAlpha:u}=km(r,e,t);return[f8({x:b("x",r,e,t),filter:b("filter",r,e,t),strides:[n[1],n[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:o,activation:l,preluActivationWeights:c,leakyreluAlpha:u})]}case"FusedDepthwiseConv2dNative":{const{stride:n,pad:s,dataFormat:i,dilations:a,biasArg:o,preluArg:c,activationFunc:l,leakyreluAlpha:u}=km(r,e,t);return[b8({x:b("x",r,e,t),filter:b("filter",r,e,t),strides:[n[1],n[2]],pad:s,dataFormat:i,dilations:[a[1],a[2]],bias:o,activation:l,preluActivationWeights:c,leakyreluAlpha:u})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const n=b("outputShape",r,e,t),s=b("strides",r,e,t),i=Mo(r,e,t);return[f5(b("x",r,e,t),b("filter",r,e,t),n,[s[1],s[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const n=b("strides",r,e,t),s=Mo(r,e,t),i=b("dilations",r,e,t),a=b("dataFormat",r,e,t).toUpperCase();return[Bf(b("input",r,e,t),b("filter",r,e,t),[n[1],n[2]],s,a,[i[1],i[2]])]}case"Conv3D":{const n=b("strides",r,e,t),s=b("pad",r,e,t),i=b("dataFormat",r,e,t).toUpperCase(),a=b("dilations",r,e,t);return[g5(b("x",r,e,t),b("filter",r,e,t),[n[1],n[2],n[3]],s,i,[a[1],a[2],a[3]])]}case"AvgPool":{const n=b("strides",r,e,t),s=b("pad",r,e,t),i=b("kernelSize",r,e,t);return[H9(b("x",r,e,t),[i[1],i[2]],[n[1],n[2]],s)]}case"MaxPool":{const n=b("strides",r,e,t),s=b("pad",r,e,t),i=b("kernelSize",r,e,t);return[I_(b("x",r,e,t),[i[1],i[2]],[n[1],n[2]],s)]}case"MaxPoolWithArgmax":{const n=b("strides",r,e,t),s=b("pad",r,e,t),i=b("kernelSize",r,e,t),a=b("includeBatchInIndex",r,e,t),{result:o,indexes:c}=L_(b("x",r,e,t),[i[1],i[2]],[n[1],n[2]],s,a);return[o,c]}case"AvgPool3D":{const n=b("strides",r,e,t),s=b("pad",r,e,t),i=b("kernelSize",r,e,t);return[G9(b("x",r,e,t),[i[1],i[2],i[3]],[n[1],n[2],n[3]],s)]}case"MaxPool3D":{const n=b("strides",r,e,t),s=b("pad",r,e,t),i=b("kernelSize",r,e,t);return[R_(b("x",r,e,t),[i[1],i[2],i[3]],[n[1],n[2],n[3]],s)]}case"Dilation2D":{const n=b("strides",r,e,t),s=b("pad",r,e,t),i=b("dilations",r,e,t),a=n[1],o=n[2],c=i[1],l=i[2];return[N5(b("x",r,e,t),b("filter",r,e,t),[a,o],s,[c,l],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nv=(r,e,t)=>{switch(r.op){case"Fill":{const n=b("shape",r,e,t),s=b("dtype",r,e,t),i=b("value",r,e,t);return[Qu(n,i,s)]}case"LinSpace":{const n=b("start",r,e,t),s=b("stop",r,e,t),i=b("num",r,e,t);return[i_(n,s,i)]}case"Multinomial":{const n=b("logits",r,e,t),s=b("numSamples",r,e,t),i=b("seed",r,e,t);return[G_(n,s,i)]}case"OneHot":{const n=b("indices",r,e,t),s=b("depth",r,e,t),i=b("onValue",r,e,t),a=b("offValue",r,e,t);return[$4(n,s,i,a)]}case"Ones":return[nl(b("shape",r,e,t),b("dtype",r,e,t))];case"OnesLike":return[q_(b("x",r,e,t))];case"RandomUniform":return[l6(b("shape",r,e,t),b("minval",r,e,t),b("maxval",r,e,t),b("dtype",r,e,t))];case"Range":{const n=b("start",r,e,t),s=b("stop",r,e,t),i=b("step",r,e,t);return[da(n,s,i,b("dtype",r,e,t))]}case"TruncatedNormal":{const n=b("shape",r,e,t),s=b("mean",r,e,t),i=b("stdDev",r,e,t),a=b("seed",r,e,t);return[J6(n,s,i,b("dtype",r,e,t),a)]}case"Zeros":return[ei(b("shape",r,e,t),b("dtype",r,e,t))];case"ZerosLike":return[Zu(b("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ml(r,e,t){const n=b("boxes",r,e,t),s=b("scores",r,e,t),i=b("maxOutputSize",r,e,t),a=b("iouThreshold",r,e,t),o=b("scoreThreshold",r,e,t),c=b("softNmsSigma",r,e,t);return{boxes:n,scores:s,maxOutputSize:i,iouThreshold:a,scoreThreshold:o,softNmsSigma:c}}const rv=async(r,e,t)=>{switch(r.op){case"NonMaxSuppressionV5":{const{boxes:n,scores:s,maxOutputSize:i,iouThreshold:a,scoreThreshold:o,softNmsSigma:c}=Ml(r,e,t),l=await Mn.nonMaxSuppressionWithScoreAsync(n,s,i,a,o,c);return[l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:n,scores:s,maxOutputSize:i,iouThreshold:a,scoreThreshold:o}=Ml(r,e,t),c=b("padToMaxOutputSize",r,e,t),l=await Mn.nonMaxSuppressionPaddedAsync(n,s,i,a,o,c);return[l.selectedIndices,l.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:n,scores:s,maxOutputSize:i,iouThreshold:a,scoreThreshold:o}=Ml(r,e,t);return[await Mn.nonMaxSuppressionAsync(n,s,i,a,o)]}case"Where":{const n=vt(b("condition",r,e,t),"bool"),s=[await n8(n)];return n.dispose(),s}case"ListDiff":return S6(b("x",r,e,t),b("y",r,e,t));default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sv=(r,e,t)=>{switch(r.op){case"TopKV2":{const n=b("x",r,e,t),s=b("k",r,e,t),i=b("sorted",r,e,t),a=X6(n,s,i);return[a.values,a.indices]}case"Unique":{const n=b("x",r,e,t),s=pm(n);return[s.values,s.indices]}case"UniqueV2":{const n=b("x",r,e,t),s=b("axis",r,e,t),i=pm(n,s);return[i.values,i.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iv=(r,e,t)=>{switch(r.op){case"Const":return e[r.name];case"PlaceholderWithDefault":const n=b("default",r,e,t);return[nn(r.name,e,t)||n];case"Placeholder":return[nn(r.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const l=b("x",r,e,t);return[nr(l)]}case"IdentityN":return b("x",r,e,t).map(l=>nr(l));case"Snapshot":const s=b("x",r,e,t);return[nr(s)];case"Shape":return[Bt(b("x",r,e,t).shape,"int32")];case"ShapeN":return b("x",r,e,t).map(l=>Bt(l.shape));case"Size":return[lt(b("x",r,e,t).size,"int32")];case"Rank":return[lt(b("x",r,e,t).rank,"int32")];case"NoOp":return[lt(1)];case"Print":const i=b("x",r,e,t),a=b("data",r,e,t),o=b("message",r,e,t),c=b("summarize",r,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let l=0;l<a.length;l++)console.log(Array.prototype.slice.call(a[l].dataSync()).slice(0,c));return[i];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class av{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=lt(0),this.tensorMap=new Map,Ar(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return lt(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),rt(()=>{const s=fs(t),i=n.length,a=s.length;z(i===a,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${a} elements.`);for(let o=0;o<i;o++){const c=n[o],l=s[o];Ar(l),this.tensorMap.set(c,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return rt(()=>{const s=[];for(let i=0;i<n.length;i++){const a=n[i],o=this.findWithDefault(a,t);s.push(o)}return tr(s)})}findWithDefault(e,t){const n=this.tensorMap.get(e);return n!=null?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ov=async(r,e,t,n)=>{switch(r.op){case"HashTable":case"HashTableV2":{const s=b("keyDType",r,e,t),i=b("valueDType",r,e,t),a=new av(s,i);return n.addHashTable(r.name,a),[a.handle]}case"LookupTableImport":case"LookupTableImportV2":{const s=b("tableHandle",r,e,t,n),i=b("keys",r,e,t),a=b("values",r,e,t);return[await n.getHashTableById(s.id).import(i,a)]}case"LookupTableFind":case"LookupTableFindV2":{const s=b("tableHandle",r,e,t,n),i=b("keys",r,e,t),a=b("defaultValue",r,e,t);return[await n.getHashTableById(s.id).find(i,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=b("tableHandle",r,e,t,n);return[n.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cv=(r,e,t)=>{switch(r.op){case"ResizeBilinear":{const n=b("images",r,e,t),s=b("size",r,e,t),i=b("alignCorners",r,e,t),a=b("halfPixelCenters",r,e,t);return[Mn.resizeBilinear(n,[s[0],s[1]],i,a)]}case"ResizeNearestNeighbor":{const n=b("images",r,e,t),s=b("size",r,e,t),i=b("alignCorners",r,e,t),a=b("halfPixelCenters",r,e,t);return[Mn.resizeNearestNeighbor(n,[s[0],s[1]],i,a)]}case"CropAndResize":{const n=b("image",r,e,t),s=b("boxes",r,e,t),i=b("boxInd",r,e,t),a=b("cropSize",r,e,t),o=b("method",r,e,t),c=b("extrapolationValue",r,e,t);return[Mn.cropAndResize(n,s,i,a,o,c)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uv=(r,e,t)=>{switch(r.op){case"Equal":return[zf(b("a",r,e,t),b("b",r,e,t))];case"NotEqual":return[Yf(b("a",r,e,t),b("b",r,e,t))];case"Greater":return[bo(b("a",r,e,t),b("b",r,e,t))];case"GreaterEqual":return[Hf(b("a",r,e,t),b("b",r,e,t))];case"Less":return[r_(b("a",r,e,t),b("b",r,e,t))];case"LessEqual":return[tl(b("a",r,e,t),b("b",r,e,t))];case"LogicalAnd":return[qf(b("a",r,e,t),b("b",r,e,t))];case"LogicalNot":return[T_(b("a",r,e,t))];case"LogicalOr":return[M_(b("a",r,e,t),b("b",r,e,t))];case"Select":case"SelectV2":return[Zs(b("condition",r,e,t),b("a",r,e,t),b("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lv=(r,e,t)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Ot(b("a",r,e,t),b("b",r,e,t),b("transposeA",r,e,t),b("transposeB",r,e,t))];case"Einsum":return[F5(b("equation",r,e,t),...b("tensors",r,e,t))];case"Transpose":return[qu(b("x",r,e,t),b("perm",r,e,t))];case"_FusedMatMul":const[n,s]=b("fusedOps",r,e,t),i=n==="biasadd",a=s==="prelu",o=b("numArgs",r,e,t),c=b("leakyreluAlpha",r,e,t);if(i){if(a&&o!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[l,u]=b("args",r,e,t);return[w8({a:b("a",r,e,t),b:b("b",r,e,t),transposeA:b("transposeA",r,e,t),transposeB:b("transposeB",r,e,t),bias:l,activation:s,preluActivationWeights:u,leakyreluAlpha:c})];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hv=(r,e,t)=>{switch(r.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[Df(b("x",r,e,t),b("mean",r,e,t),b("variance",r,e,t),b("offset",r,e,t),b("scale",r,e,t),b("epsilon",r,e,t))];case"FusedBatchNormV3":return[Df(b("x",r,e,t),b("mean",r,e,t),b("variance",r,e,t),b("offset",r,e,t),b("scale",r,e,t),b("epsilon",r,e,t))];case"LRN":return[o_(b("x",r,e,t),b("radius",r,e,t),b("bias",r,e,t),b("alpha",r,e,t),b("beta",r,e,t))];case"Softmax":return[C6(b("x",r,e,t))];case"LogSoftmax":return[y_(b("x",r,e,t))];case"SparseToDense":return[gm(b("sparseIndices",r,e,t),b("outputShape",r,e,t),b("sparseValues",r,e,t),b("defaultValue",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dv=(r,e,t)=>{switch(r.op){case"Max":{const a=b("axis",r,e,t),o=b("keepDims",r,e,t);return[Qs(b("x",r,e,t),a,o)]}case"Mean":{const a=b("axis",r,e,t),o=b("keepDims",r,e,t);return[Kf(b("x",r,e,t),a,o)]}case"Min":{const a=b("axis",r,e,t),o=b("keepDims",r,e,t);return[rl(b("x",r,e,t),a,o)]}case"Sum":{const a=b("axis",r,e,t),o=b("keepDims",r,e,t);return[mt(b("x",r,e,t),a,o)]}case"All":{const a=b("axis",r,e,t),o=b("keepDims",r,e,t);return[b9(b("x",r,e,t),a,o)]}case"Any":{const a=b("axis",r,e,t),o=b("keepDims",r,e,t);return[w9(b("x",r,e,t),a,o)]}case"ArgMax":{const a=b("axis",r,e,t);return[T9(b("x",r,e,t),a)]}case"ArgMin":{const a=b("axis",r,e,t);return[M9(b("x",r,e,t),a)]}case"Prod":{const a=b("axis",r,e,t),o=b("keepDims",r,e,t);return[Qf(b("x",r,e,t),a,o)]}case"Cumsum":{const a=b("axis",r,e,t),o=b("exclusive",r,e,t),c=b("reverse",r,e,t);return[w5(b("x",r,e,t),a,o,c)]}case"Bincount":const n=b("x",r,e,t),s=b("weights",r,e,t),i=b("size",r,e,t);return[Pf(n,s,i)];case"DenseBincount":{const a=b("x",r,e,t),o=b("weights",r,e,t),c=b("size",r,e,t),l=b("binaryOutput",r,e,t);return[T5(a,o,c,l)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pv=(r,e,t)=>{switch(r.op){case"ConcatV2":case"Concat":{const n=b("n",r,e,t),s=b("axis",r,e,t);let i=b("tensors",r,e,t);return i=i.slice(0,n),[Jt(i,s)]}case"Gather":{const n=b("x",r,e,t),s=b("indices",r,e,t);return[Vf(n,vt(s,"int32"),0)]}case"GatherV2":{const n=b("axis",r,e,t),s=b("batchDims",r,e,t),i=b("x",r,e,t),a=b("indices",r,e,t);return[Vf(i,vt(a,"int32"),n,s)]}case"Reverse":{const n=b("dims",r,e,t),s=[];for(let a=0;a<n.length;a++)n[a]&&s.push(a);const i=b("x",r,e,t);return[So(i,s)]}case"ReverseV2":{const n=b("axis",r,e,t),s=b("x",r,e,t);return[So(s,n)]}case"Slice":{const n=b("begin",r,e,t),s=b("size",r,e,t);return[Qe(b("x",r,e,t),n,s)]}case"StridedSlice":{const n=b("begin",r,e,t),s=b("end",r,e,t),i=b("strides",r,e,t),a=b("beginMask",r,e,t),o=b("endMask",r,e,t),c=b("ellipsisMask",r,e,t),l=b("newAxisMask",r,e,t),u=b("shrinkAxisMask",r,e,t),h=b("x",r,e,t);return[W6(h,n,s,i,a,o,c,l,u)]}case"Pack":return rt(()=>{const n=b("axis",r,e,t),s=b("tensors",r,e,t),i=s[0].shape,a=Bn(s[0]).shape,o=s.map(c=>{const l=js(c.shape,i);if(!l&&!js(Bn(c).shape,a))throw new Error("the input tensors shape does not match");return l?c:pe(c,i)});return[tr(o,n)]});case"Unpack":{const n=b("axis",r,e,t),s=b("tensor",r,e,t);return fs(s,n)}case"Tile":{const n=b("reps",r,e,t);return[ca(b("x",r,e,t),n)]}case"Split":case"SplitV":{const n=b("axis",r,e,t),s=b("numOrSizeSplits",r,e,t),i=b("x",r,e,t);return pa(i,s,n)}case"ScatterNd":{const n=b("indices",r,e,t),s=b("values",r,e,t),i=b("shape",r,e,t);return[i8(n,s,i)]}case"GatherNd":{const n=b("x",r,e,t),s=b("indices",r,e,t);return[u8(n,s)]}case"SparseToDense":{const n=b("sparseIndices",r,e,t),s=b("outputShape",r,e,t),i=b("sparseValues",r,e,t),a=b("defaultValue",r,e,t);return[gm(n,i,s,i.dtype===a.dtype?a:vt(a,i.dtype))]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fv=(r,e,t)=>{switch(r.op){case"SparseFillEmptyRows":{const{outputIndices:n,outputValues:s,emptyRowIndicator:i,reverseIndexMap:a}=To.sparseFillEmptyRows(b("indices",r,e,t),b("values",r,e,t),b("denseShape",r,e,t),b("defaultValue",r,e,t));return[n,s,i,a]}case"SparseReshape":{const{outputIndices:n,outputShape:s}=To.sparseReshape(b("inputIndices",r,e,t),b("inputShape",r,e,t),b("newShape",r,e,t));return[n,s]}case"SparseSegmentMean":return[To.sparseSegmentMean(b("data",r,e,t),b("indices",r,e,t),b("segmentIds",r,e,t))];case"SparseSegmentSum":return[To.sparseSegmentSum(b("data",r,e,t),b("indices",r,e,t),b("segmentIds",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mv=(r,e,t)=>{switch(r.op){case"FFT":return[lm(b("x",r,e,t))];case"IFFT":return[il(b("x",r,e,t))];case"RFFT":return[hm(b("x",r,e,t))];case"IRFFT":return[P6(b("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gv=(r,e,t)=>{switch(r.op){case"StringNGrams":{const{nGrams:n,nGramsSplits:s}=dl.stringNGrams(b("data",r,e,t),b("dataSplits",r,e,t),b("separator",r,e,t),b("nGramWidths",r,e,t),b("leftPad",r,e,t),b("rightPad",r,e,t),b("padWidth",r,e,t),b("preserveShortSequences",r,e,t));return[n,s]}case"StringSplit":{const{indices:n,values:s,shape:i}=dl.stringSplit(b("input",r,e,t),b("delimiter",r,e,t),b("skipEmpty",r,e,t));return[n,s,i]}case"StringToHashBucketFast":return[dl.stringToHashBucketFast(b("input",r,e,t),b("numBuckets",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yv=(r,e,t)=>{switch(r.op){case"Cast":return[vt(b("x",r,e,t),b("dtype",r,e,t))];case"ExpandDims":{const n=b("axis",r,e,t);return[er(b("x",r,e,t),n)]}case"Squeeze":{const n=b("axis",r,e,t);return[Bn(b("x",r,e,t),n)]}case"Reshape":return[pe(b("x",r,e,t),b("shape",r,e,t))];case"MirrorPad":return[z_(b("x",r,e,t),b("padding",r,e,t),b("mode",r,e,t))];case"PadV2":case"Pad":return[X_(b("x",r,e,t),b("padding",r,e,t),b("constantValue",r,e,t))];case"SpaceToBatchND":{const n=b("blockShape",r,e,t),s=b("paddings",r,e,t);return[J_(b("x",r,e,t),n,s)]}case"BatchToSpaceND":{const n=b("blockShape",r,e,t),s=b("crops",r,e,t);return[J9(b("x",r,e,t),n,s)]}case"DepthToSpace":{const n=b("blockSize",r,e,t),s=b("dataFormat",r,e,t).toUpperCase();return[M5(b("x",r,e,t),n,s)]}case"BroadcastTo":return[xo(b("x",r,e,t),b("shape",r,e,t))];case"BroadcastArgs":return[n5(b("s0",r,e,t),b("s1",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dm(r,e,t,n){const s=((i,a,o)=>{switch(i.category){case"arithmetic":return rt(()=>qb(i,a,o));case"basic_math":return rt(()=>Kb(i,a,o));case"control":return ev(i,a,o);case"convolution":return rt(()=>tv(i,a,o));case"creation":return rt(()=>nv(i,a,o));case"dynamic":return rv(i,a,o);case"evaluation":return rt(()=>sv(i,a,o));case"image":return rt(()=>cv(i,a,o));case"graph":return rt(()=>iv(i,a,o));case"logical":return rt(()=>uv(i,a,o));case"matrices":return rt(()=>lv(i,a,o));case"normalization":return rt(()=>hv(i,a,o));case"reduction":return rt(()=>dv(i,a,o));case"slice_join":return rt(()=>pv(i,a,o));case"sparse":return rt(()=>fv(i,a,o));case"spectral":return rt(()=>mv(i,a,o));case"string":return rt(()=>gv(i,a,o));case"transformation":return rt(()=>yv(i,a,o));case"hash_table":return ov(i,a,o,n);case"custom":const c=Am(i.op);if(c&&c.customExecutor)return c.customExecutor(new jb(i,a,o));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,e,t);return na(s)?s.then(i=>[].concat(i)):[].concat(s)}class Pm{constructor(e={},t={},n={},s={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fm(r,e,t,n){const s=new Set,i=[];let a=null,o=null;const c=new Set,l=Object.keys(r).map(d=>fn(d)[0]);let u=[];n!=null&&(u=n.map(d=>fn(d.name)[0]));const h=[...e];for(;h.length>0;){const d=h.pop();if((Om(d)||wv(d)||Sv(d))&&a==null&&(a=d,o=a.children.map(p=>p.name).filter(p=>s.has(p))),s.add(d.name),t[d.name]==null&&l.indexOf(d.name)===-1&&u.indexOf(d.name)===-1){if(d.inputs.length===0){i.push(d.name);continue}d.inputs.forEach(p=>{c.has(p.name)||(c.add(p.name),h.push(p))})}}return{inputs:r,outputs:e,usedNodes:s,missingInputs:i,dynamicNode:a,syncInputs:o}}function _v(r,e,t){const{usedNodes:n,inputs:s}=t,i=[],a=Object.keys(s).map(u=>fn(u)[0]).map(u=>r.nodes[u]),o=r.initNodes;a.forEach(u=>{n.has(u.name)&&i.push(u)}),r.weights.forEach(u=>{n.has(u.name)&&i.push(u)}),o!=null&&o.forEach(u=>{n.has(u.name)&&i.push(u)});const c=new Set,l=[];for(;i.length>0;){const u=i.pop();c.add(u.name),e[u.name]||l.push(u),u.children.forEach(h=>{!c.has(h.name)&&n.has(h.name)&&h.inputs.every(d=>c.has(d.name))&&i.push(h)})}return l}const xv=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],bv=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],vv=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Om(r){return xv.indexOf(r.op)>=0}function wv(r){return bv.indexOf(r.op)>=0}function Sv(r){return vv.indexOf(r.op)>=0}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ao{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(n=>{this._functionExecutorMap[n]=new Ao(e.functions[n],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(n=>e[n].map(s=>s.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const n=e.map(i=>i.name).sort(),s=t.map(i=>i.name).sort();return n.join(this.SEPERATOR)+"--"+s.join(this.SEPERATOR)}compile(e,t){const n=Fm(e,t,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:i,syncInputs:a}=n;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(s.length>0){const o=t.map(l=>l.name),c=Object.keys(e);throw new Error(`Cannot compute the outputs [${o}] from the provided inputs [${c}]. Missing the following inputs: [${s}]`)}return _v(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const s=n.map(h=>this.graph.nodes[fn(h)[0]]),i=t.map(h=>fn(h)[0]);let a=i.map(h=>this.graph.nodes[h]);this.resetIntermediateTensors(),a.length===0&&(a=this._outputs);const o=this.getCompilationKey(s,a);let c=this.compiledMap.get(o);c==null&&(c=this.compile(e,a),this.compiledMap.set(o,c));const l={},u={};return rt(()=>{const h=new Pm(this.weightMap,l,u,this.functionExecutorMap),d=Object.assign({},this.weightMap);Object.keys(e).forEach(m=>{const[_,g]=fn(m),y=[];y[g]=e[m],d[_]=y});const p=this.getFrozenTensorIds(d),f={};for(let m=0;m<c.length;m++){const _=c[m];if(!d[_.name]){const g=Dm(_,d,h,this._resourceManager);if(na(g))throw new Error(`The execution of the op '${_.op}' returned a promise. Please use model.executeAsync() instead.`);d[_.name]=g,this.checkTensorForDisposal(_.name,_,d,h,p,i,f)}}return this.parent==null&&h.dispose(p),t.map(m=>nn(m,d,h))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(n=>e[n]).map(n=>n.map(s=>s.id)));return new Set(t)}checkTensorForDisposal(e,t,n,s,i,a,o){t.category==="control"||a.indexOf(e)!==-1||(n[e].forEach(c=>{c!=null&&(o[c.id]=(o[c.id]||0)+t.children.length)}),t.inputs.forEach(c=>{if(c.category!=="control"){const l=ab(c.name,n,s);l!=null&&l.forEach(u=>{if(u&&!u.kept&&!i.has(u.id)){const h=o[u.id];if(h===1){if(!this.keepTensorForDebug)u.dispose();else{const[d,p]=Wn(t.name,s);this.intermediateTensors[d]?this.intermediateTensors[d][p]=u:(this.intermediateTensors[d]=[],this.intermediateTensors[d][p]=u)}delete o[u.id]}else h!=null&&o[u.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(e=>this.intermediateTensors[e].forEach(t=>t.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(e=>{this.tensorsMap[e].forEach(n=>{n&&!n.kept&&!n.isDisposed&&!this.keepIds.has(n.id)&&n.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach(t=>t.dispose()),delete this.intermediateTensors[e]}async _executeAsync(e,t,n=!1,s={},i={}){n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=nt().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(u){console.warn(u.message)}this.resetIntermediateTensors();const a=new Pm(this.weightMap,s,i,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,a,t,n);const o=t.map(u=>nn(u,this.tensorsMap,a)),c=o.map(u=>u.id),l=Object.keys(e).map(u=>e[u].id);return this.keepIds=new Set([...c,...l,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&a.dispose(this.keepIds),o}async executeFunctionAsync(e,t,n){const s=e.reduce((i,a,o)=>(i[this.inputs[o].name]=a,i),{});return this._executeAsync(s,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,s){const i=Object.keys(e),a=i.map(x=>this.graph.nodes[fn(x)[0]]),o=n.map(x=>fn(x)[0]);let c=o.map(x=>this.graph.nodes[x]);c.length===0&&(c=this._outputs);const{usedNodes:l,missingInputs:u,dynamicNode:h,syncInputs:d}=Fm(e,c,this.weightMap,this._initNodes),p=[...a,...this.graph.weights,...this._initNodes||[]].map(x=>({node:x,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(x=>{const[w,T]=fn(x),M=[];M[T]=e[x],f[w]=M});const m={},_=this.getFrozenTensorIds(f),g={};for(;p.length>0;){const x=this.processStack(a,p,t,f,g,_,o,m,l);await Promise.all(x)}h==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const y=c.filter(x=>!Om(x)&&!nn(x.name,f,t)).map(x=>x.name);if(y.length>0){let x="";throw h!=null&&(x=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${y}] from the provided inputs [${i}]. Consider providing the following inputs: [${u}]. ${x}`)}return f}processStack(e,t,n,s,i,a,o,c,l){const u=[];for(;t.length>0;){const h=t.pop();n.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&b("isConstant",h.node,s,n)&&([d]=Wn(h.node.name,n)),s[h.node.name]==null){const p=Dm(h.node,s,n,this._resourceManager);d||([d]=Wn(h.node.name,n));const f=n.currentContext;na(p)?u.push(p.then(m=>(s[d]=m,n.currentContext=f,this.checkTensorForDisposal(d,h.node,s,n,a,o,c),this.processChildNodes(h.node,t,n,s,i,l),m))):(s[d]=p,this.checkTensorForDisposal(d,h.node,s,n,a,o,c),this.processChildNodes(h.node,t,n,s,i,l))}else this.processChildNodes(h.node,t,n,s,i,l)}return u}processChildNodes(e,t,n,s,i,a){e.children.forEach(o=>{const[c]=Wn(o.name,n);i[c]||!a.has(o.name)||(o.op==="Merge"?o.inputNames.some(l=>!!nn(l,s,n))&&(i[c]=!0,t.push({contexts:n.currentContext,node:o})):o.inputNames.every(l=>!!nn(l,s,n))&&(i[c]=!0,t.push({contexts:n.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const n=e[t],[s]=fn(t),i=this.graph.nodes[s];if(i.attrParams.shape&&i.attrParams.shape.value){const a=i.attrParams.shape.value,o=a.length===n.shape.length&&n.shape.every((c,l)=>a[l]===-1||a[l]===c);z(o,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${a}], but was [${n.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&z(n.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){const t={};for(const n in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[n]!=null){const s=this._signature.inputs[n];t[s.name]=e[n]}else t[n]=e[n];return t}checkInputs(e){const t=Object.keys(e).filter(n=>{const[s]=fn(n);return this.graph.nodes[s]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{const[n]=fn(t);if(!this.graph.nodes[n])throw new Error(`The output '${t}' is not found in the graph`)})}}class Tv{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ev="?tfjs-format=file",Mv="model.json";class Av{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",t==null&&(this.loadOptions={}),this.resourceManager=new Tv}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=Mf(e,this.loadOptions);else{const t=_4(e,this.loadOptions);if(t.length===0)t.push(Mf(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?n=this.artifacts.userDefinedMetadata.signature:n=this.artifacts.signature,this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const s=o4(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Ao(Im.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(s),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const i=Im.Instance.transformGraph(e.modelInitializer);this.initializer=new Ao(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){const n=y4(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof At)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,n,s)=>(t[n]=e[s],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function ri(r,e={}){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&r.load==null&&(r.endsWith("/")||(r=r+"/"),r=`${r}${Mv}${Ev}`);const t=new Av(r,e);return await t.load(),t}/**
    * @license
    * Copyright 2021 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var Al=function(){return(Al=Object.assign||function(r){for(var e,t=1,n=arguments.length;t<n;t++)for(var s in e=arguments[t])Object.prototype.hasOwnProperty.call(e,s)&&(r[s]=e[s]);return r}).apply(this,arguments)};function rr(r,e,t,n){return new(t||(t=Promise))(function(s,i){function a(l){try{c(n.next(l))}catch(u){i(u)}}function o(l){try{c(n.throw(l))}catch(u){i(u)}}function c(l){var u;l.done?s(l.value):(u=l.value,u instanceof t?u:new t(function(h){h(u)})).then(a,o)}c((n=n.apply(r,e||[])).next())})}function sr(r,e){var t,n,s,i,a={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return i={next:o(0),throw:o(1),return:o(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function o(c){return function(l){return function(u){if(t)throw new TypeError("Generator is already executing.");for(;a;)try{if(t=1,n&&(s=2&u[0]?n.return:u[0]?n.throw||((s=n.return)&&s.call(n),0):n.next)&&!(s=s.call(n,u[1])).done)return s;switch(n=0,s&&(u=[2&u[0],s.value]),u[0]){case 0:case 1:s=u;break;case 4:return a.label++,{value:u[1],done:!1};case 5:a.label++,n=u[1],u=[0];continue;case 7:u=a.ops.pop(),a.trys.pop();continue;default:if(s=a.trys,!((s=s.length>0&&s[s.length-1])||u[0]!==6&&u[0]!==2)){a=0;continue}if(u[0]===3&&(!s||u[1]>s[0]&&u[1]<s[3])){a.label=u[1];break}if(u[0]===6&&a.label<s[1]){a.label=s[1],s=u;break}if(s&&a.label<s[2]){a.label=s[2],a.ops.push(u);break}s[2]&&a.ops.pop(),a.trys.pop();continue}u=e.call(r,a)}catch(h){u=[6,h],n=0}finally{t=s=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([c,l])}}}function si(r,e,t,n){return new(t||(t=Promise))(function(s,i){function a(l){try{c(n.next(l))}catch(u){i(u)}}function o(l){try{c(n.throw(l))}catch(u){i(u)}}function c(l){var u;l.done?s(l.value):(u=l.value,u instanceof t?u:new t(function(h){h(u)})).then(a,o)}c((n=n.apply(r,e||[])).next())})}function ii(r,e){var t,n,s,i,a={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return i={next:o(0),throw:o(1),return:o(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function o(c){return function(l){return function(u){if(t)throw new TypeError("Generator is already executing.");for(;a;)try{if(t=1,n&&(s=2&u[0]?n.return:u[0]?n.throw||((s=n.return)&&s.call(n),0):n.next)&&!(s=s.call(n,u[1])).done)return s;switch(n=0,s&&(u=[2&u[0],s.value]),u[0]){case 0:case 1:s=u;break;case 4:return a.label++,{value:u[1],done:!1};case 5:a.label++,n=u[1],u=[0];continue;case 7:u=a.ops.pop(),a.trys.pop();continue;default:if(!(s=(s=a.trys).length>0&&s[s.length-1])&&(u[0]===6||u[0]===2)){a=0;continue}if(u[0]===3&&(!s||u[1]>s[0]&&u[1]<s[3])){a.label=u[1];break}if(u[0]===6&&a.label<s[1]){a.label=s[1],s=u;break}if(s&&a.label<s[2]){a.label=s[2],a.ops.push(u);break}s[2]&&a.ops.pop(),a.trys.pop();continue}u=e.call(r,a)}catch(h){u=[6,h],n=0}finally{t=s=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([c,l])}}}var Bm=function(r){return{startEndTensor:r,startPoint:Qe(r,[0,0],[-1,2]),endPoint:Qe(r,[0,2],[-1,2])}},Iv={strides:[8,16],anchors:[2,6]};function zm(r,e){var t,n,s;if(r.topLeft instanceof At&&r.bottomRight instanceof At){var i=rt(function(){return[Jt([Qe(et(e-1,r.topLeft),0,1),Qe(r.topLeft,1,1)]),Jt([et(e-1,Qe(r.bottomRight,0,1)),Qe(r.bottomRight,1,1)])]});t=i[0],n=i[1],r.landmarks!=null&&(s=rt(function(){var p=et(Bt([e-1,0]),r.landmarks),f=Bt([1,-1]);return Ke(p,f)}))}else{var a=r.topLeft,o=a[0],c=a[1],l=r.bottomRight,u=l[0],h=l[1];t=[e-1-o,c],n=[e-1-u,h],r.landmarks!=null&&(s=r.landmarks.map(function(p){return[e-1-p[0],p[1]]}))}var d={topLeft:t,bottomRight:n};return s!=null&&(d.landmarks=s),r.probability!=null&&(d.probability=r.probability instanceof At?r.probability.clone():r.probability),d}function Um(r,e){return rt(function(){var t;return t=r.hasOwnProperty("box")?r.box:r,Bn(function(n,s){var i=Ke(n.startPoint,s),a=Ke(n.endPoint,s),o=Ff([i,a],1);return Bm(o)}(t,e).startEndTensor)})}var Nv=function(){function r(e,t,n,s,i,a){this.blazeFaceModel=e,this.width=t,this.height=n,this.maxFaces=s,this.anchorsData=function(o,c,l){for(var u=[],h=0;h<l.strides.length;h++)for(var d=l.strides[h],p=Math.floor((c+d-1)/d),f=Math.floor((o+d-1)/d),m=l.anchors[h],_=0;_<p;_++)for(var g=d*(_+.5),y=0;y<f;y++)for(var x=d*(y+.5),w=0;w<m;w++)u.push([x,g]);return u}(t,n,Iv),this.anchors=Cr(this.anchorsData),this.inputSizeData=[t,n],this.inputSize=Bt([t,n]),this.iouThreshold=i,this.scoreThreshold=a}return r.prototype.getBoundingBoxes=function(e,t,n){return n===void 0&&(n=!0),si(this,void 0,void 0,function(){var s,i,a,o,c,l,u,h,d,p,f,m,_,g,y=this;return ii(this,function(x){switch(x.label){case 0:return s=rt(function(){var w=Mn.resizeBilinear(e,[y.width,y.height]),T=Ke(et(kt(w,255),.5),2),M=y.blazeFaceModel.predict(T),S=Bn(M),R=function(O,A,Y){var B=Qe(O,[0,1],[-1,2]),H=Yt(B,A),U=Qe(O,[0,3],[-1,2]),j=kt(U,Y),K=kt(H,Y),se=kt(j,2),ue=et(K,se),Q=Yt(K,se),ee=Ke(ue,Y),ge=Ke(Q,Y);return Ff([ee,ge],1)}(S,y.anchors,y.inputSize),k=Qe(S,[0,0],[-1,1]);return[S,R,Bn(Yu(k))]}),i=s[0],a=s[1],o=s[2],c=console.warn,console.warn=function(){},l=Mn.nonMaxSuppression(a,o,this.maxFaces,this.iouThreshold,this.scoreThreshold),console.warn=c,[4,l.array()];case 1:return u=x.sent(),l.dispose(),h=u.map(function(w){return Qe(a,[w,0],[1,-1])}),t?[3,3]:[4,Promise.all(h.map(function(w){return si(y,void 0,void 0,function(){var T;return ii(this,function(M){switch(M.label){case 0:return[4,w.array()];case 1:return T=M.sent(),w.dispose(),[2,T]}})})}))];case 2:h=x.sent(),x.label=3;case 3:for(d=e.shape[1],p=e.shape[2],f=t?kt([p,d],this.inputSize):[p/this.inputSizeData[0],d/this.inputSizeData[1]],m=[],_=function(w){var T=h[w],M=rt(function(){var S=Bm(T instanceof At?T:Cr(T));if(!n)return S;var R,k=u[w];return R=t?Qe(y.anchors,[k,0],[1,2]):y.anchorsData[k],{box:S,landmarks:pe(Bn(Qe(i,[k,5],[1,-1])),[6,-1]),probability:Qe(o,[k],[1]),anchor:R}});m.push(M)},g=0;g<h.length;g++)_(g);return a.dispose(),o.dispose(),i.dispose(),[2,{boxes:m,scaleFactor:f}]}})})},r.prototype.estimateFaces=function(e,t,n,s){return t===void 0&&(t=!1),n===void 0&&(n=!1),s===void 0&&(s=!0),si(this,void 0,void 0,function(){var i,a,o,c,l,u,h=this;return ii(this,function(d){switch(d.label){case 0:return i=function(p){return p instanceof At?[p.shape[0],p.shape[1]]:[p.height,p.width]}(e),a=i[1],o=rt(function(){return e instanceof At||(e=Af(e)),er(vt(e,"float32"),0)}),[4,this.getBoundingBoxes(o,t,s)];case 1:return c=d.sent(),l=c.boxes,u=c.scaleFactor,o.dispose(),t?[2,l.map(function(p){var f=Um(p,u),m={topLeft:Qe(f,[0],[2]),bottomRight:Qe(f,[2],[2])};if(s){var _=p,g=_.landmarks,y=_.probability,x=_.anchor,w=Ke(Yt(g,x),u);m.landmarks=w,m.probability=y}return n&&(m=zm(m,a)),m})]:[2,Promise.all(l.map(function(p){return si(h,void 0,void 0,function(){var f,m,_,g,y,x,w,T,M,S,R,k=this;return ii(this,function(O){switch(O.label){case 0:return f=Um(p,u),s?[3,2]:[4,f.array()];case 1:return y=O.sent(),m={topLeft:y.slice(0,2),bottomRight:y.slice(2)},[3,4];case 2:return[4,Promise.all([p.landmarks,f,p.probability].map(function(A){return si(k,void 0,void 0,function(){return ii(this,function(Y){return[2,A.array()]})})}))];case 3:_=O.sent(),g=_[0],y=_[1],x=_[2],w=p.anchor,M=(T=u)[0],S=T[1],R=g.map(function(A){return[(A[0]+w[0])*M,(A[1]+w[1])*S]}),m={topLeft:y.slice(0,2),bottomRight:y.slice(2),landmarks:R,probability:x},function(A){A.startEndTensor.dispose(),A.startPoint.dispose(),A.endPoint.dispose()}(p.box),p.landmarks.dispose(),p.probability.dispose(),O.label=4;case 4:return f.dispose(),n&&(m=zm(m,a)),[2,m]}})})}))]}})})},r}();function Rv(r){var e=r===void 0?{}:r,t=e.maxFaces,n=t===void 0?10:t,s=e.inputWidth,i=s===void 0?128:s,a=e.inputHeight,o=a===void 0?128:a,c=e.iouThreshold,l=c===void 0?.3:c,u=e.scoreThreshold,h=u===void 0?.75:u,d=e.modelUrl;return si(this,void 0,void 0,function(){var p;return ii(this,function(f){switch(f.label){case 0:return d==null?[3,2]:[4,ri(d)];case 1:return p=f.sent(),[3,4];case 2:return[4,ri("https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1",{fromTFHub:!0})];case 3:p=f.sent(),f.label=4;case 4:return[2,new Nv(p,i,o,n,l,h)]}})})}var ir={silhouette:[10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109],lipsUpperOuter:[61,185,40,39,37,0,267,269,270,409,291],lipsLowerOuter:[146,91,181,84,17,314,405,321,375,291],lipsUpperInner:[78,191,80,81,82,13,312,311,310,415,308],lipsLowerInner:[78,95,88,178,87,14,317,402,318,324,308],rightEyeUpper0:[246,161,160,159,158,157,173],rightEyeLower0:[33,7,163,144,145,153,154,155,133],rightEyeUpper1:[247,30,29,27,28,56,190],rightEyeLower1:[130,25,110,24,23,22,26,112,243],rightEyeUpper2:[113,225,224,223,222,221,189],rightEyeLower2:[226,31,228,229,230,231,232,233,244],rightEyeLower3:[143,111,117,118,119,120,121,128,245],rightEyebrowUpper:[156,70,63,105,66,107,55,193],rightEyebrowLower:[35,124,46,53,52,65],rightEyeIris:[473,474,475,476,477],leftEyeUpper0:[466,388,387,386,385,384,398],leftEyeLower0:[263,249,390,373,374,380,381,382,362],leftEyeUpper1:[467,260,259,257,258,286,414],leftEyeLower1:[359,255,339,254,253,252,256,341,463],leftEyeUpper2:[342,445,444,443,442,441,413],leftEyeLower2:[446,261,448,449,450,451,452,453,464],leftEyeLower3:[372,340,346,347,348,349,350,357,465],leftEyebrowUpper:[383,300,293,334,296,336,285,417],leftEyebrowLower:[265,353,276,283,282,295],leftEyeIris:[468,469,470,471,472],midwayBetweenEyes:[168],noseTip:[1],noseBottom:[2],noseRightCorner:[98],noseLeftCorner:[327],rightCheek:[205],leftCheek:[425]};function Io(r){return[Math.abs(r.endPoint[0]-r.startPoint[0]),Math.abs(r.endPoint[1]-r.startPoint[1])]}function No(r){return[r.startPoint[0]+(r.endPoint[0]-r.startPoint[0])/2,r.startPoint[1]+(r.endPoint[1]-r.startPoint[1])/2]}function Il(r,e){e===void 0&&(e=1.5);var t=No(r),n=Io(r),s=[e*n[0]/2,e*n[1]/2];return{startPoint:[t[0]-s[0],t[1]-s[1]],endPoint:[t[0]+s[0],t[1]+s[1]],landmarks:r.landmarks}}function Nl(r){var e=No(r),t=Io(r),n=Math.max.apply(Math,t)/2;return{startPoint:[e[0]-n,e[1]-n],endPoint:[e[0]+n,e[1]+n],landmarks:r.landmarks}}var Cv=[[1,0,0],[0,1,0],[0,0,1]];function Lv(r,e){var t,n=Math.PI/2-Math.atan2(-(e[1]-r[1]),e[0]-r[0]);return(t=n)-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function Vm(r,e){return[[1,0,r],[0,1,e],[0,0,1]]}function ms(r,e){for(var t=0,n=0;n<r.length;n++)t+=r[n]*e[n];return t}function kv(r,e){for(var t=[],n=0;n<r.length;n++)t.push(r[n][e]);return t}function Hm(r,e){for(var t=[],n=r.length,s=0;s<n;s++){t.push([]);for(var i=0;i<n;i++)t[s].push(ms(r[s],kv(e,i)))}return t}function $m(r,e){var t=Math.cos(r),n=Math.sin(r),s=[[t,-n,0],[n,t,0],[0,0,1]],i=Hm(Vm(e[0],e[1]),s);return Hm(i,Vm(-e[0],-e[1]))}var Gm=[13,ir.midwayBetweenEyes[0]],Wm=[3,2],Rl=ir.leftEyeLower0,Cl=[Rl[0],Rl[Rl.length-1]],Ll=ir.rightEyeLower0,kl=[Ll[0],Ll[Ll.length-1]],jm=[{key:"EyeUpper0",indices:[9,10,11,12,13,14,15]},{key:"EyeUpper1",indices:[25,26,27,28,29,30,31]},{key:"EyeUpper2",indices:[41,42,43,44,45,46,47]},{key:"EyeLower0",indices:[0,1,2,3,4,5,6,7,8]},{key:"EyeLower1",indices:[16,17,18,19,20,21,22,23,24]},{key:"EyeLower2",indices:[32,33,34,35,36,37,38,39,40]},{key:"EyeLower3",indices:[54,55,56,57,58,59,60,61,62]},{key:"EyebrowUpper",indices:[63,64,65,66,67,68,69,70]},{key:"EyebrowLower",indices:[48,49,50,51,52,53]}];function Ro(r,e,t,n){for(var s=0;s<jm.length;s++){var i=jm[s],a=i.key,o=i.indices,c=ir[""+t+a];if(n==null||n.includes(a))for(var l=0;l<o.length;l++){var u=o[l];r[c[l]]=[e[u][0],e[u][1],(e[u][2]+r[c[l]][2])/2]}}}var Dv=function(){function r(e,t,n,s,i,a,o){this.regionsOfInterest=[],this.runsWithoutFaceDetector=0,this.boundingBoxDetector=e,this.meshDetector=t,this.irisModel=o,this.meshWidth=n,this.meshHeight=s,this.maxContinuousChecks=i,this.maxFaces=a}return r.prototype.transformRawCoords=function(e,t,n,s){var i,a,o,c,l=this,u=Io({startPoint:t.startPoint,endPoint:t.endPoint}),h=[u[0]/this.meshWidth,u[1]/this.meshHeight],d=e.map(function(y){return[h[0]*(y[0]-l.meshWidth/2),h[1]*(y[1]-l.meshHeight/2),y[2]]}),p=$m(n,[0,0]),f=d.map(function(y){return function(x,w){return[ms(x,w[0]),ms(x,w[1])]}(y,p).concat([y[2]])}),m=(a=[[(i=s)[0][0],i[1][0]],[i[0][1],i[1][1]]],o=[i[0][2],i[1][2]],c=[-ms(a[0],o),-ms(a[1],o)],[a[0].concat(c[0]),a[1].concat(c[1]),[0,0,1]]),_=No({startPoint:t.startPoint,endPoint:t.endPoint}).concat([1]),g=[ms(_,m[0]),ms(_,m[1])];return f.map(function(y){return[y[0]+g[0],y[1]+g[1],y[2]]})},r.prototype.getLeftToRightEyeDepthDifference=function(e){return e[Cl[0]][2]-e[kl[0]][2]},r.prototype.getEyeBox=function(e,t,n,s,i){i===void 0&&(i=!1);var a=Nl(Il(this.calculateLandmarksBoundingBox([e[n],e[s]]),2.3)),o=Io(a),c=Mn.cropAndResize(t,[[a.startPoint[1]/this.meshHeight,a.startPoint[0]/this.meshWidth,a.endPoint[1]/this.meshHeight,a.endPoint[0]/this.meshWidth]],[0],[64,64]);return i&&(c=Mn.flipLeftRight(c)),{box:a,boxSize:o,crop:c}},r.prototype.getEyeCoords=function(e,t,n,s){s===void 0&&(s=!1);for(var i=[],a=0;a<76;a++){var o=e[3*a],c=e[3*a+1],l=e[3*a+2];i.push([(s?1-o/64:o/64)*n[0]+t.startPoint[0],c/64*n[1]+t.startPoint[1],l])}return{rawCoords:i,iris:i.slice(71)}},r.prototype.getAdjustedIrisCoords=function(e,t,n){var s=e[ir[n+"EyeUpper0"][3]][2],i=e[ir[n+"EyeLower0"][4]][2],a=(s+i)/2;return t.map(function(o,c){var l=a;return c===2?l=s:c===4&&(l=i),[o[0],o[1],l]})},r.prototype.predict=function(e,t){return rr(this,void 0,void 0,function(){var n,s,i,a,o=this;return sr(this,function(c){switch(c.label){case 0:return this.shouldUpdateRegionsOfInterest()?[4,this.boundingBoxDetector.getBoundingBoxes(e,!1,!0)]:[3,2];case 1:return n=c.sent(),s=n.boxes,i=n.scaleFactor,s.length===0?(this.regionsOfInterest=[],[2,null]):(a=s.map(function(l){var u,h,d={startPoint:Bn(l.box.startPoint).arraySync(),endPoint:Bn(l.box.endPoint).arraySync()},p=Nl(Il((h=i,{startPoint:[(u=d).startPoint[0]*h[0],u.startPoint[1]*h[1]],endPoint:[u.endPoint[0]*h[0],u.endPoint[1]*h[1]]})));return Al({},p,{landmarks:l.landmarks.arraySync()})}),s.forEach(function(l){l!=null&&l.startPoint!=null&&(l.startEndTensor.dispose(),l.startPoint.dispose(),l.endPoint.dispose())}),this.updateRegionsOfInterest(a),this.runsWithoutFaceDetector=0,[3,3]);case 2:this.runsWithoutFaceDetector++,c.label=3;case 3:return[2,rt(function(){return o.regionsOfInterest.map(function(l,u){var h,d=l.landmarks.length>=468,p=Gm[0],f=Gm[1];d===!1&&(p=Wm[0],f=Wm[1]),h=Lv(l.landmarks[p],l.landmarks[f]);var m=No({startPoint:l.startPoint,endPoint:l.endPoint}),_=[m[0]/e.shape[2],m[1]/e.shape[1]],g=e,y=Cv;h!==0&&(g=Mn.rotateWithOffset(e,h,0,_),y=$m(-h,m));var x={startPoint:l.startPoint,endPoint:l.endPoint},w=kt(function(ie,me,Ie){var be=me.shape[1],Ge=me.shape[2],$e=[[ie.startPoint[1]/be,ie.startPoint[0]/Ge,ie.endPoint[1]/be,ie.endPoint[0]/Ge]];return Mn.cropAndResize(me,$e,[0],Ie,"bilinear",0)}(x,g,[o.meshHeight,o.meshWidth]),255),T=o.meshDetector.predict(w),M=T[1],S=T[2],R=pe(S,[-1,3]).arraySync();if(t){var k=o.getEyeBox(R,w,Cl[0],Cl[1],!0),O=k.box,A=k.boxSize,Y=k.crop,B=o.getEyeBox(R,w,kl[0],kl[1]),H=B.box,U=B.boxSize,j=B.crop,K=o.irisModel.predict(Jt([Y,j])).dataSync(),se=K.slice(0,228),ue=o.getEyeCoords(se,O,A,!0),Q=ue.rawCoords,ee=ue.iris,ge=K.slice(228),he=o.getEyeCoords(ge,H,U),Me=he.rawCoords,je=he.iris,ae=o.getLeftToRightEyeDepthDifference(R);Math.abs(ae)<30?(Ro(R,Q,"left"),Ro(R,Me,"right")):ae<1?Ro(R,Q,"left",["EyeUpper0","EyeLower0"]):Ro(R,Me,"right",["EyeUpper0","EyeLower0"]);var Ve=o.getAdjustedIrisCoords(R,ee,"left"),He=o.getAdjustedIrisCoords(R,je,"right");R=R.concat(Ve).concat(He)}var Re=o.transformRawCoords(R,l,h,y),ze=Cr(Re),Ye=Il(o.calculateLandmarksBoundingBox(Re)),te=Nl(Ye);return o.regionsOfInterest[u]=Al({},te,{landmarks:ze.arraySync()}),{coords:Cr(R,[R.length,3]),scaledCoords:ze,box:Ye,flag:Bn(M)}})})]}})})},r.prototype.updateRegionsOfInterest=function(e){for(var t=0;t<e.length;t++){var n=e[t],s=this.regionsOfInterest[t],i=0;if(s&&s.startPoint){var a=n.startPoint,o=a[0],c=a[1],l=n.endPoint,u=l[0],h=l[1],d=s.startPoint,p=d[0],f=d[1],m=s.endPoint,_=m[0],g=m[1],y=Math.max(o,p),x=Math.max(c,f),w=(Math.min(u,_)-y)*(Math.min(h,g)-x);i=w/((u-o)*(h-c)+(_-p)*(g-c)-w)}i<.25&&(this.regionsOfInterest[t]=n)}this.regionsOfInterest=this.regionsOfInterest.slice(0,e.length)},r.prototype.clearRegionOfInterest=function(e){this.regionsOfInterest[e]!=null&&(this.regionsOfInterest=this.regionsOfInterest.slice(0,e).concat(this.regionsOfInterest.slice(e+1)))},r.prototype.shouldUpdateRegionsOfInterest=function(){var e=this.regionsOfInterest.length,t=e===0;return this.maxFaces===1||t?t:e!==this.maxFaces&&this.runsWithoutFaceDetector>=this.maxContinuousChecks},r.prototype.calculateLandmarksBoundingBox=function(e){var t=e.map(function(s){return s[0]}),n=e.map(function(s){return s[1]});return{startPoint:[Math.min.apply(Math,t),Math.min.apply(Math,n)],endPoint:[Math.max.apply(Math,t),Math.max.apply(Math,n)]}},r}(),Pv=[[.499976992607117,.652534008026123],[.500025987625122,.547487020492554],[.499974012374878,.602371990680695],[.482113003730774,.471979022026062],[.500150978565216,.527155995368958],[.499909996986389,.498252987861633],[.499523013830185,.40106201171875],[.289712011814117,.380764007568359],[.499954998493195,.312398016452789],[.499987006187439,.269918978214264],[.500023007392883,.107050001621246],[.500023007392883,.666234016418457],[.5000159740448,.679224014282227],[.500023007392883,.692348003387451],[.499976992607117,.695277988910675],[.499976992607117,.70593398809433],[.499976992607117,.719385027885437],[.499976992607117,.737019002437592],[.499967992305756,.781370997428894],[.499816000461578,.562981009483337],[.473773002624512,.573909997940063],[.104906998574734,.254140973091125],[.365929991006851,.409575998783112],[.338757991790771,.41302502155304],[.311120003461838,.409460008144379],[.274657994508743,.389131009578705],[.393361985683441,.403706014156342],[.345234006643295,.344011008739471],[.370094001293182,.346076011657715],[.319321990013123,.347265005111694],[.297903001308441,.353591024875641],[.24779200553894,.410809993743896],[.396889001131058,.842755019664764],[.280097991228104,.375599980354309],[.106310002505779,.399955987930298],[.2099249958992,.391353011131287],[.355807989835739,.534406006336212],[.471751004457474,.65040397644043],[.474155008792877,.680191993713379],[.439785003662109,.657229006290436],[.414617002010345,.66654098033905],[.450374007225037,.680860996246338],[.428770989179611,.682690978050232],[.374971002340317,.727805018424988],[.486716985702515,.547628998756409],[.485300987958908,.527395009994507],[.257764995098114,.314490020275116],[.401223003864288,.455172002315521],[.429818987846375,.548614978790283],[.421351999044418,.533740997314453],[.276895999908447,.532056987285614],[.483370006084442,.499586999416351],[.33721199631691,.282882988452911],[.296391993761063,.293242990970612],[.169294998049736,.193813979625702],[.447580009698868,.302609980106354],[.392390012741089,.353887975215912],[.354490011930466,.696784019470215],[.067304998636246,.730105042457581],[.442739009857178,.572826027870178],[.457098007202148,.584792017936707],[.381974011659622,.694710969924927],[.392388999462128,.694203019142151],[.277076005935669,.271932005882263],[.422551989555359,.563233017921448],[.385919004678726,.281364023685455],[.383103013038635,.255840003490448],[.331431001424789,.119714021682739],[.229923993349075,.232002973556519],[.364500999450684,.189113974571228],[.229622006416321,.299540996551514],[.173287004232407,.278747975826263],[.472878992557526,.666198015213013],[.446828007698059,.668527007102966],[.422762006521225,.673889994621277],[.445307999849319,.580065965652466],[.388103008270264,.693961024284363],[.403039008378983,.706539988517761],[.403629004955292,.693953037261963],[.460041999816895,.557139039039612],[.431158006191254,.692366003990173],[.452181994915009,.692366003990173],[.475387006998062,.692366003990173],[.465828001499176,.779190003871918],[.472328990697861,.736225962638855],[.473087012767792,.717857003211975],[.473122000694275,.704625964164734],[.473033010959625,.695277988910675],[.427942007780075,.695277988910675],[.426479011774063,.703539967536926],[.423162013292313,.711845993995667],[.4183090031147,.720062971115112],[.390094995498657,.639572978019714],[.013953999616206,.560034036636353],[.499913990497589,.58014702796936],[.413199990987778,.69539999961853],[.409626007080078,.701822996139526],[.468080013990402,.601534962654114],[.422728985548019,.585985004901886],[.463079988956451,.593783974647522],[.37211999297142,.47341400384903],[.334562003612518,.496073007583618],[.411671012639999,.546965003013611],[.242175996303558,.14767599105835],[.290776997804642,.201445996761322],[.327338010072708,.256527006626129],[.399509996175766,.748921036720276],[.441727995872498,.261676013469696],[.429764986038208,.187834024429321],[.412198007106781,.108901023864746],[.288955003023148,.398952007293701],[.218936994671822,.435410976409912],[.41278201341629,.398970007896423],[.257135003805161,.355440020561218],[.427684992551804,.437960982322693],[.448339998722076,.536936044692993],[.178560003638268,.45755398273468],[.247308000922203,.457193970680237],[.286267012357712,.467674970626831],[.332827985286713,.460712015628815],[.368755996227264,.447206974029541],[.398963987827301,.432654976844788],[.476410001516342,.405806005001068],[.189241006970406,.523923993110657],[.228962004184723,.348950982093811],[.490725994110107,.562400996685028],[.404670000076294,.485132992267609],[.019469000399113,.401564002037048],[.426243007183075,.420431017875671],[.396993011236191,.548797011375427],[.266469985246658,.376977026462555],[.439121007919312,.51895797252655],[.032313998788595,.644356966018677],[.419054001569748,.387154996395111],[.462783008813858,.505746960639954],[.238978996872902,.779744982719421],[.198220998048782,.831938028335571],[.107550002634525,.540755033493042],[.183610007166862,.740257024765015],[.134409993886948,.333683013916016],[.385764002799988,.883153975009918],[.490967005491257,.579378008842468],[.382384985685349,.508572995662689],[.174399003386497,.397670984268188],[.318785011768341,.39623498916626],[.343364000320435,.400596976280212],[.396100014448166,.710216999053955],[.187885001301765,.588537991046906],[.430987000465393,.944064974784851],[.318993002176285,.898285031318665],[.266247987747192,.869701027870178],[.500023007392883,.190576016902924],[.499976992607117,.954452991485596],[.366169989109039,.398822009563446],[.393207013607025,.39553701877594],[.410373002290726,.391080021858215],[.194993004202843,.342101991176605],[.388664990663528,.362284004688263],[.365961998701096,.355970978736877],[.343364000320435,.355356991291046],[.318785011768341,.35834002494812],[.301414996385574,.363156020641327],[.058132998645306,.319076001644135],[.301414996385574,.387449026107788],[.499987989664078,.618434011936188],[.415838003158569,.624195992946625],[.445681989192963,.566076993942261],[.465844005346298,.620640993118286],[.49992299079895,.351523995399475],[.288718998432159,.819945991039276],[.335278987884521,.852819979190826],[.440512001514435,.902418971061707],[.128294005990028,.791940987110138],[.408771991729736,.373893976211548],[.455606997013092,.451801002025604],[.499877005815506,.908990025520325],[.375436991453171,.924192011356354],[.11421000212431,.615022003650665],[.448662012815475,.695277988910675],[.4480200111866,.704632043838501],[.447111994028091,.715808033943176],[.444831997156143,.730794012546539],[.430011987686157,.766808986663818],[.406787008047104,.685672998428345],[.400738000869751,.681069016456604],[.392399996519089,.677703022956848],[.367855995893478,.663918972015381],[.247923001646996,.601333022117615],[.452769994735718,.420849978923798],[.43639200925827,.359887003898621],[.416164010763168,.368713974952698],[.413385987281799,.692366003990173],[.228018000721931,.683571994304657],[.468268007040024,.352671027183533],[.411361992359161,.804327011108398],[.499989002943039,.469825029373169],[.479153990745544,.442654013633728],[.499974012374878,.439637005329132],[.432112008333206,.493588984012604],[.499886006116867,.866917014122009],[.49991300702095,.821729004383087],[.456548988819122,.819200992584229],[.344549000263214,.745438992977142],[.37890899181366,.574010014533997],[.374292999505997,.780184984207153],[.319687992334366,.570737957954407],[.357154995203018,.604269981384277],[.295284003019333,.621580958366394],[.447750002145767,.862477004528046],[.410986006259918,.508723020553589],[.31395098567009,.775308012962341],[.354128003120422,.812552988529205],[.324548006057739,.703992962837219],[.189096003770828,.646299958229065],[.279776990413666,.71465802192688],[.1338230073452,.682700991630554],[.336768001317978,.644733011722565],[.429883986711502,.466521978378296],[.455527991056442,.548622965812683],[.437114000320435,.558896005153656],[.467287987470627,.529924988746643],[.414712011814117,.335219979286194],[.37704598903656,.322777986526489],[.344107985496521,.320150971412659],[.312875986099243,.32233202457428],[.283526003360748,.333190023899078],[.241245999932289,.382785975933075],[.102986000478268,.468762993812561],[.267612010240555,.424560010433197],[.297879010438919,.433175981044769],[.333433985710144,.433878004550934],[.366427004337311,.426115989685059],[.396012008190155,.416696012020111],[.420121014118195,.41022801399231],[.007561000064015,.480777025222778],[.432949006557465,.569517970085144],[.458638995885849,.479089021682739],[.473466008901596,.545744001865387],[.476087987422943,.563830018043518],[.468472003936768,.555056989192963],[.433990985155106,.582361996173859],[.483518004417419,.562983989715576],[.482482999563217,.57784903049469],[.42645001411438,.389798998832703],[.438998997211456,.39649498462677],[.450067013502121,.400434017181396],[.289712011814117,.368252992630005],[.276670008897781,.363372981548309],[.517862021923065,.471948027610779],[.710287988185883,.380764007568359],[.526226997375488,.573909997940063],[.895093023777008,.254140973091125],[.634069979190826,.409575998783112],[.661242008209229,.41302502155304],[.688880026340485,.409460008144379],[.725341975688934,.389131009578705],[.606630027294159,.40370500087738],[.654766023159027,.344011008739471],[.629905998706818,.346076011657715],[.680678009986877,.347265005111694],[.702096998691559,.353591024875641],[.75221198797226,.410804986953735],[.602918028831482,.842862963676453],[.719901978969574,.375599980354309],[.893692970275879,.399959981441498],[.790081977844238,.391354024410248],[.643998026847839,.534487962722778],[.528249025344849,.65040397644043],[.525849997997284,.680191040039062],[.560214996337891,.657229006290436],[.585384011268616,.66654098033905],[.549625992774963,.680860996246338],[.57122802734375,.682691991329193],[.624852001667023,.72809898853302],[.513050019741058,.547281980514526],[.51509702205658,.527251958847046],[.742246985435486,.314507007598877],[.598631024360657,.454979002475739],[.570338010787964,.548575043678284],[.578631997108459,.533622980117798],[.723087012767792,.532054007053375],[.516445994377136,.499638974666595],[.662801027297974,.282917976379395],[.70362401008606,.293271005153656],[.830704987049103,.193813979625702],[.552385985851288,.302568018436432],[.607609987258911,.353887975215912],[.645429015159607,.696707010269165],[.932694971561432,.730105042457581],[.557260990142822,.572826027870178],[.542901992797852,.584792017936707],[.6180260181427,.694710969924927],[.607590973377228,.694203019142151],[.722943007946014,.271963000297546],[.577413976192474,.563166975975037],[.614082992076874,.281386971473694],[.616907000541687,.255886018276215],[.668509006500244,.119913995265961],[.770092010498047,.232020974159241],[.635536015033722,.189248979091644],[.77039098739624,.299556016921997],[.826722025871277,.278755009174347],[.527121007442474,.666198015213013],[.553171992301941,.668527007102966],[.577238023281097,.673889994621277],[.554691970348358,.580065965652466],[.611896991729736,.693961024284363],[.59696102142334,.706539988517761],[.596370995044708,.693953037261963],[.539958000183105,.557139039039612],[.568841993808746,.692366003990173],[.547818005084991,.692366003990173],[.52461302280426,.692366003990173],[.534089982509613,.779141008853912],[.527670979499817,.736225962638855],[.526912987232208,.717857003211975],[.526877999305725,.704625964164734],[.526966989040375,.695277988910675],[.572058022022247,.695277988910675],[.573521018028259,.703539967536926],[.57683801651001,.711845993995667],[.581691026687622,.720062971115112],[.609944999217987,.639909982681274],[.986046016216278,.560034036636353],[.5867999792099,.69539999961853],[.590372025966644,.701822996139526],[.531915009021759,.601536989212036],[.577268004417419,.585934996604919],[.536915004253387,.593786001205444],[.627542972564697,.473352015018463],[.665585994720459,.495950996875763],[.588353991508484,.546862006187439],[.757824003696442,.14767599105835],[.709249973297119,.201507985591888],[.672684013843536,.256581008434296],[.600408971309662,.74900496006012],[.55826598405838,.261672019958496],[.570303976535797,.187870979309082],[.588165998458862,.109044015407562],[.711045026779175,.398952007293701],[.781069993972778,.435405015945435],[.587247014045715,.398931980133057],[.742869973182678,.355445981025696],[.572156012058258,.437651991844177],[.55186802148819,.536570012569427],[.821442008018494,.457556009292603],[.752701997756958,.457181990146637],[.71375697851181,.467626988887787],[.66711300611496,.460672974586487],[.631101012229919,.447153985500336],[.6008620262146,.432473003864288],[.523481011390686,.405627012252808],[.810747981071472,.523926019668579],[.771045982837677,.348959028720856],[.509127020835876,.562718033790588],[.595292985439301,.485023975372314],[.980530977249146,.401564002037048],[.573499977588654,.420000016689301],[.602994978427887,.548687994480133],[.733529984951019,.376977026462555],[.560611009597778,.519016981124878],[.967685997486115,.644356966018677],[.580985009670258,.387160003185272],[.537728011608124,.505385041236877],[.760966002941132,.779752969741821],[.801778972148895,.831938028335571],[.892440974712372,.54076099395752],[.816350996494293,.740260004997253],[.865594983100891,.333687007427216],[.614073991775513,.883246004581451],[.508952975273132,.579437971115112],[.617941975593567,.508316040039062],[.825608015060425,.397674977779388],[.681214988231659,.39623498916626],[.656635999679565,.400596976280212],[.603900015354156,.710216999053955],[.81208598613739,.588539004325867],[.56801301240921,.944564998149872],[.681007981300354,.898285031318665],[.733752012252808,.869701027870178],[.633830010890961,.398822009563446],[.606792986392975,.39553701877594],[.589659988880157,.391062021255493],[.805015981197357,.342108011245728],[.611334979534149,.362284004688263],[.634037971496582,.355970978736877],[.656635999679565,.355356991291046],[.681214988231659,.35834002494812],[.698584973812103,.363156020641327],[.941866993904114,.319076001644135],[.698584973812103,.387449026107788],[.584177017211914,.624107003211975],[.554318010807037,.566076993942261],[.534153997898102,.62064003944397],[.711217999458313,.819975018501282],[.664629995822906,.852871000766754],[.559099972248077,.902631998062134],[.871706008911133,.791940987110138],[.591234028339386,.373893976211548],[.544341027736664,.451583981513977],[.624562978744507,.924192011356354],[.88577002286911,.615028977394104],[.551338016986847,.695277988910675],[.551980018615723,.704632043838501],[.552887976169586,.715808033943176],[.555167973041534,.730794012546539],[.569944024085999,.767035007476807],[.593203008174896,.685675978660583],[.599261999130249,.681069016456604],[.607599973678589,.677703022956848],[.631937980651855,.663500010967255],[.752032995223999,.601315021514893],[.547226011753082,.420395016670227],[.563543975353241,.359827995300293],[.583841025829315,.368713974952698],[.586614012718201,.692366003990173],[.771915018558502,.683578014373779],[.531597018241882,.352482974529266],[.588370978832245,.804440975189209],[.52079701423645,.442565023899078],[.567984998226166,.493479013442993],[.543282985687256,.819254994392395],[.655317008495331,.745514988899231],[.621008992195129,.574018001556396],[.625559985637665,.78031200170517],[.680198013782501,.570719003677368],[.64276397228241,.604337990283966],[.704662978649139,.621529996395111],[.552012026309967,.862591981887817],[.589071989059448,.508637011051178],[.685944974422455,.775357007980347],[.645735025405884,.812640011310577],[.675342977046967,.703978002071381],[.810858011245728,.646304965019226],[.72012197971344,.714666962623596],[.866151988506317,.682704985141754],[.663187026977539,.644596993923187],[.570082008838654,.466325998306274],[.544561982154846,.548375964164734],[.562758982181549,.558784961700439],[.531987011432648,.530140042304993],[.585271000862122,.335177004337311],[.622952997684479,.32277899980545],[.655896008014679,.320163011550903],[.687132000923157,.322345972061157],[.716481983661652,.333200991153717],[.758756995201111,.382786989212036],[.897013008594513,.468769013881683],[.732392013072968,.424547016620636],[.70211398601532,.433162987232208],[.66652500629425,.433866024017334],[.633504986763,.426087975502014],[.603875994682312,.416586995124817],[.579657971858978,.409945011138916],[.992439985275269,.480777025222778],[.567192018032074,.569419980049133],[.54136598110199,.478899002075195],[.526564002037048,.546118021011353],[.523913025856018,.563830018043518],[.531529009342194,.555056989192963],[.566035985946655,.582329034805298],[.51631098985672,.563053965568542],[.5174720287323,.577877044677734],[.573594987392426,.389806985855103],[.560697972774506,.395331978797913],[.549755990505219,.399751007556915],[.710287988185883,.368252992630005],[.723330020904541,.363372981548309]];function Fv(r){return rr(this,void 0,void 0,function(){var e,t,n,s,i,a,o,c,l,u,h,d,p,f,m,_;return sr(this,function(g){switch(g.label){case 0:return e=r.maxContinuousChecks,t=e===void 0?5:e,n=r.detectionConfidence,s=n===void 0?.9:n,i=r.maxFaces,a=i===void 0?10:i,o=r.iouThreshold,c=o===void 0?.3:o,l=r.scoreThreshold,u=l===void 0?.75:l,h=r.shouldLoadIrisModel,d=h===void 0||h,p=r.modelUrl,f=r.detectorModelUrl,m=r.irisModelUrl,d?[4,Promise.all([qm(f,a,c,u),Km(p),Ov(m)])]:[3,2];case 1:return _=g.sent(),[3,4];case 2:return[4,Promise.all([qm(f,a,c,u),Km(p)])];case 3:_=g.sent(),g.label=4;case 4:return[2,new Bv(_[0],_[1],t,s,a,d?_[2]:null)]}})})}function qm(r,e,t,n){return rr(this,void 0,void 0,function(){return sr(this,function(s){return[2,Rv({modelUrl:r,maxFaces:e,iouThreshold:t,scoreThreshold:n})]})})}function Km(r){return rr(this,void 0,void 0,function(){return sr(this,function(e){return r!=null?[2,ri(r)]:[2,ri("https://tfhub.dev/mediapipe/tfjs-model/facemesh/1/default/1",{fromTFHub:!0})]})})}function Ov(r){return rr(this,void 0,void 0,function(){return sr(this,function(e){return r!=null?[2,ri(r)]:[2,ri("https://tfhub.dev/mediapipe/tfjs-model/iris/1/default/2",{fromTFHub:!0})]})})}function Xm(r,e){if(r.mesh instanceof At){var t=rt(function(){var o=Bt([e-1,0,0]),c=Bt([1,-1,1]);return rt(function(){return[Jt([et(e-1,Qe(r.boundingBox.topLeft,0,1)),Qe(r.boundingBox.topLeft,1,1)]),Jt([et(e-1,Qe(r.boundingBox.bottomRight,0,1)),Qe(r.boundingBox.bottomRight,1,1)]),Ke(et(o,r.mesh),c),Ke(et(o,r.scaledMesh),c)]})}),n=t[0],s=t[1],i=t[2],a=t[3];return Object.assign({},r,{boundingBox:{topLeft:n,bottomRight:s},mesh:i,scaledMesh:a})}return Object.assign({},r,{boundingBox:{topLeft:[e-1-r.boundingBox.topLeft[0],r.boundingBox.topLeft[1]],bottomRight:[e-1-r.boundingBox.bottomRight[0],r.boundingBox.bottomRight[1]]},mesh:r.mesh.map(function(o){var c=o.slice(0);return c[0]=e-1-o[0],c}),scaledMesh:r.scaledMesh.map(function(o){var c=o.slice(0);return c[0]=e-1-o[0],c})})}var ma,Bv=function(){function r(e,t,n,s,i,a){this.kind="MediaPipeFaceMesh",this.pipeline=new Dv(e,t,192,192,n,i,a),this.detectionConfidence=s}return r.getAnnotations=function(){return ir},r.getUVCoords=function(){return Pv},r.prototype.estimateFaces=function(e){return rr(this,void 0,void 0,function(){var t,n,s,i,a,o,c,l,u,h,d,p,f=this;return sr(this,function(m){switch(m.label){case 0:if(t=e.returnTensors,n=t!==void 0&&t,s=e.flipHorizontal,i=s!==void 0&&s,a=e.predictIrises,o=a===void 0||a,c=e.input,o&&this.pipeline.irisModel==null)throw new Error("The iris model was not loaded as part of facemesh. Please initialize the model with facemesh.load({shouldLoadIrisModel: true}).");return l=function(_){return _ instanceof At?[_.shape[0],_.shape[1]]:[_.height,_.width]}(c),u=l[1],h=rt(function(){return c instanceof At||(c=Af(c)),er(vt(c,"float32"),0)}),a9()!=="webgl"?[3,2]:(p=nt().get("WEBGL_PACK_DEPTHWISECONV"),nt().set("WEBGL_PACK_DEPTHWISECONV",!0),[4,this.pipeline.predict(h,o)]);case 1:return d=m.sent(),nt().set("WEBGL_PACK_DEPTHWISECONV",p),[3,4];case 2:return[4,this.pipeline.predict(h,o)];case 3:d=m.sent(),m.label=4;case 4:return h.dispose(),d!=null&&d.length>0?[2,Promise.all(d.map(function(_,g){return rr(f,void 0,void 0,function(){var y,x,w,T,M,S,R,k,O,A,Y,B,H,U,j=this;return sr(this,function(K){switch(K.label){case 0:return y=_.coords,x=_.scaledCoords,w=_.box,T=_.flag,M=[T],n||(M=M.concat([y,x])),[4,Promise.all(M.map(function(se){return rr(j,void 0,void 0,function(){return sr(this,function(ue){return[2,se.array()]})})}))];case 1:if(S=K.sent(),R=S[0],T.dispose(),R<this.detectionConfidence&&this.pipeline.clearRegionOfInterest(g),n)return k={kind:"MediaPipePredictionTensors",faceInViewConfidence:R,mesh:y,scaledMesh:x,boundingBox:{topLeft:Bt(w.startPoint),bottomRight:Bt(w.endPoint)}},i?[2,Xm(k,u)]:[2,k];for(U in O=S.slice(1),A=O[0],Y=O[1],x.dispose(),y.dispose(),B={kind:"MediaPipePredictionValues",faceInViewConfidence:R,boundingBox:{topLeft:w.startPoint,bottomRight:w.endPoint},mesh:A,scaledMesh:Y},i&&(B=Xm(B,u)),H={},ir)(o||U.includes("Iris")===!1)&&(H[U]=ir[U].map(function(se){return B.scaledMesh[se]}));return B.annotations=H,[2,B]}})})}))]:[2,[]]}})})},r}();function zv(r,e){return r===void 0&&(r=ma.mediapipeFacemesh),e===void 0&&(e={}),rr(this,void 0,void 0,function(){return sr(this,function(t){if(r===ma.mediapipeFacemesh)return[2,Fv(e)];throw new Error(r+" is not a valid package name.")})})}(function(r){r.mediapipeFacemesh="mediapipe-facemesh"})(ma||(ma={}));async function Uv(){return(await navigator.mediaDevices.enumerateDevices()).filter(t=>t.kind==="videoinput")}async function Vv(r,e,t){try{return await navigator.mediaDevices.getUserMedia({video:{deviceId:r,width:e,height:t}})}catch(n){return Promise.reject(n)}}function Hv(r){var e;(e=r.srcObject)==null||e.getTracks().forEach(t=>{t.stop()}),r.autoplay=!0,r.playsInline=!0}function $v(r,e,t){return new Promise(async n=>{const s=await Uv();if(s.length){const i=await Vv(s[0].deviceId,e,t);Hv(r),r.onloadeddata=n,r.srcObject=i}})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Et;(function(r){r[r.float32=0]="float32",r[r.int32=1]="int32",r[r.bool=2]="bool",r[r.string=3]="string",r[r.complex64=4]="complex64"})(Et||(Et={}));var ga;(function(r){r[r.linear=0]="linear",r[r.relu=1]="relu",r[r.relu6=2]="relu6",r[r.prelu=3]="prelu",r[r.leakyrelu=4]="leakyrelu",r[r.sigmoid=5]="sigmoid",r[r.elu=6]="elu"})(ga||(ga={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ym;function Gv(r){Ym=r.wasm.cwrap(lo,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function Wv(r){const{inputs:e,backend:t,attrs:n}=r,{a:s,b:i,bias:a,preluActivationWeights:o}=e;if(s.dtype!=="float32"||i.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");const{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:h}=n,d=t.dataIdMap.get(s.dataId).id,p=t.dataIdMap.get(i.dataId).id;let f=0;if(a!=null){const R=t.dataIdMap.get(a.dataId);if(R.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${R.shape.length}.`);f=R.id}const m=o==null?0:t.dataIdMap.get(o.dataId).id,_=ga[u];if(_==null)throw new Error(`${u} activation not yet supported for FusedConv2D in the wasm backend.`);const g=c?s.shape[2]:s.shape[1],y=l?i.shape[1]:i.shape[2],x=Lt(s.shape.slice(0,-2),i.shape.slice(0,-2)),w=t.makeOutput([...x,g,y],s.dtype),T=t.dataIdMap.get(w.dataId).id,M=new Uint8Array(new Int32Array(s.shape).buffer),S=new Uint8Array(new Int32Array(i.shape).buffer);return Ym(d,M,s.shape.length,p,S,i.shape.length,c,l,_,f,m,h||0,T),w}const jv={kernelName:lo,backendName:"wasm",setupFunc:Gv,kernelFunc:Wv};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qt(r,e){let t;function n(i){t=i.wasm.cwrap(r,null,["number","number","number"])}function s(i){const{backend:a,inputs:{x:o}}=i,c=a.dataIdMap.get(o.dataId).id,l=a.makeOutput(o.shape,e||o.dtype),u=a.dataIdMap.get(l.dataId).id;return Ne(l.shape)===0||t(c,Et[o.dtype],u),l}return{kernelName:r,backendName:"wasm",setupFunc:n,kernelFunc:s}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qv=qt(Zd);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rn(r,e,t){let n;function s(a){n=a.wasm.cwrap(r,null,["number","array","number","number","array","number","number","number"])}function i(a){const{backend:o,inputs:c}=a,{a:l,b:u}=c,h=o.dataIdMap.get(l.dataId).id,d=o.dataIdMap.get(u.dataId).id,p=t!=null?t:l.dtype,f=Lt(l.shape,u.shape),m=o.makeOutput(f,p);if(Ne(f)===0)return m;const _=new Uint8Array(new Int32Array(l.shape).buffer),g=new Uint8Array(new Int32Array(u.shape).buffer),y=o.dataIdMap.get(m.dataId).id;return(()=>n(h,_,l.shape.length,d,g,u.shape.length,Et[l.dtype],y))(),m}return{kernelName:r,backendName:"wasm",setupFunc:s,kernelFunc:i}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kv=rn(Uc);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Jm;function Xv(r){Jm=r.wasm.cwrap(Vc,null,["array","number","number","number"])}function Yv(r){const{inputs:e,backend:t}=r,n=t.makeOutput(e[0].shape,e[0].dtype);if(Ne(n.shape)===0)return n;const s=e.map(o=>t.dataIdMap.get(o.dataId).id),i=new Uint8Array(new Int32Array(s).buffer),a=t.dataIdMap.get(n.dataId).id;return Jm(i,s.length,Et[n.dtype],a),n}const Jv={kernelName:Vc,backendName:"wasm",setupFunc:Xv,kernelFunc:Yv};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Co(r){const{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype),s=t.typedArrayFromHeap(e);return t.typedArrayFromHeap(n).set(s),n}const Zv={kernelName:su,backendName:"wasm",kernelFunc:Co};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Zm;function Qv(r){Zm=r.wasm.cwrap(Au,null,["number","array","number","number","number","array","number"])}function ai(r){const{inputs:e,backend:t,attrs:n}=r,[s,i]=t7(e.x.shape,n.perm);let a=!0;for(let f=0;f<i.length;f++)i[f]!==f&&(a=!1);const o=e7(e.x.shape,n.perm),c={dataId:e.x.dataId,shape:s,dtype:e.x.dtype};if(a){const f=Co({inputs:e,backend:t});return f.shape=o,f}const l=t.makeOutput(o,c.dtype),u=t.dataIdMap.get(c.dataId).id,h=t.dataIdMap.get(l.dataId).id,d=new Uint8Array(new Int32Array(i).buffer),p=new Uint8Array(new Int32Array(c.shape).buffer);return Zm(u,p,c.shape.length,Et[c.dtype],h,d,i.length),l}function e7(r,e){const t=new Array(r.length);for(let n=0;n<t.length;n++)t[n]=r[e[n]];return t}function t7(r,e){const t=[],n=[];for(let s=0;s<r.length;++s)r[s]!==1&&t.push(r[s]),r[e[s]]!==1&&n.push(e[s]);for(let s=0;s<n.length;++s){let i=-1;for(let a=0;a<n.length;++a)n[a]>=s&&(i===-1||n[i]>n[a])&&(i=a);n[i]=s}return[t,n]}const n7={kernelName:Au,backendName:"wasm",kernelFunc:ai,setupFunc:Qv};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kr(r,e,t){const n=r.shape,s=r.shape.length,i=wr(e,n);let a=i;const o=jf(a,s);let c=null,l=!1;if(o!=null){const u=new Array(s);for(let p=0;p<u.length;p++)u[p]=n[o[p]];a=ha(a.length,s),c=ai({inputs:{x:r},attrs:{perm:o},backend:t});const h=t.dataIdMap.get(r.dataId).id;t.dataIdMap.get(c.dataId).id!==h&&(l=!0)}return{transposed:c,originalAxes:i,axes:a,inputWasTransposed:l}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Qm;function r7(r){Qm=r.wasm.cwrap(Hc,null,["number, number, number"])}function s7(r){const{backend:e,inputs:t,attrs:n}=r,{axis:s,keepDims:i}=n,{x:a}=t;let c=e.dataIdMap.get(a.dataId).id,l=a;const{transposed:u,axes:h,originalAxes:d,inputWasTransposed:p}=kr(a,s,e);if(p){const x=e.dataIdMap.get(u.dataId).id;l=u,c=x}const f=l.shape.length;Rr("all",h,f);const[m,_]=ds(l.shape,h),g=Ne(_),y=e.makeOutput(m,a.dtype);if(Ne(l.shape)!==0){const x=e.dataIdMap.get(y.dataId).id;Qm(c,g,x)}if(p&&e.disposeData(u.dataId),i){const x=Gn(y.shape,d);y.shape=x}return y}const i7={kernelName:Hc,backendName:"wasm",setupFunc:r7,kernelFunc:s7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let e0;function a7(r){e0=r.wasm.cwrap($c,null,["number, number, number"])}function o7(r){const{backend:e,inputs:t,attrs:n}=r,{axis:s,keepDims:i}=n,{x:a}=t;let c=e.dataIdMap.get(a.dataId).id,l=a;const{transposed:u,axes:h,originalAxes:d,inputWasTransposed:p}=kr(a,s,e);if(p){const x=e.dataIdMap.get(u.dataId).id;l=u,c=x}const f=l.shape.length;Rr("any",h,f);const[m,_]=ds(l.shape,h),g=Ne(_),y=e.makeOutput(m,a.dtype);if(Ne(l.shape)!==0){const x=e.dataIdMap.get(y.dataId).id;e0(c,g,x)}if(p&&e.disposeData(u.dataId),i){const x=Gn(y.shape,d);y.shape=x}return y}const c7={kernelName:$c,backendName:"wasm",setupFunc:a7,kernelFunc:o7};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let t0;function u7(r){t0=r.wasm.cwrap(Gc,null,["number","number","number","number","number"])}function l7(r){const{backend:e,inputs:t,attrs:n}=r,{axis:s}=n,{x:i}=t,a=e.dataIdMap.get(i.dataId).id;let o=a,c=i;const{transposed:l,axes:u,inputWasTransposed:h}=kr(i,s,e);if(h){const g=e.dataIdMap.get(l.dataId).id;g!==a&&(c=l,o=g)}const d=c.shape.slice(0,-1),p=e.makeOutput(d,"int32"),f=e.dataIdMap.get(p.dataId).id,m=Ne(p.shape),_=c.shape[u[0]];return t0(o,Et[c.dtype],m,_,f),h&&e.disposeData(l.dataId),p}const h7={kernelName:Gc,backendName:"wasm",kernelFunc:l7,setupFunc:u7};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let n0;function d7(r){n0=r.wasm.cwrap(Wc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function p7(r){const{inputs:e,attrs:t,backend:n}=r,s=e.x,i=n.dataIdMap.get(s.dataId).id,{filterSize:a,strides:o,pad:c,dimRoundingMode:l}=t,u=Lf(s.shape,a,o,1,c,l),h=u.filterHeight,d=u.filterWidth,p=u.padInfo.top,f=u.padInfo.right,m=u.padInfo.bottom,_=u.padInfo.left,g=u.strideHeight,y=u.strideWidth,x=u.inChannels;if(u.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);if(u.dilationWidth!==1||u.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${u.dilationHeight}, ${u.dilationWidth}].`);const w=n.makeOutput(u.outShape,"float32"),T=n.dataIdMap.get(w.dataId).id;return n0(i,s.shape[0],s.shape[1],s.shape[2],h,d,p,f,m,_,g,y,x,T),w}const f7={kernelName:Wc,backendName:"wasm",setupFunc:d7,kernelFunc:p7};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ln(r){const{inputs:e,attrs:t}=r,{x:n}=e,{shape:s}=t,i=Ne(n.shape),a=L3(s,i);return z(i===Ne(a),()=>`new shape: ${a}, old shape: ${n.shape}. New shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:a,dtype:n.dtype}}const m7={kernelName:Np,backendName:"wasm",kernelFunc:ln};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let r0;function g7(r){r0=r.wasm.cwrap(jc,null,["number","array","number","number","array","number","number","number","number"])}function y7(r){const{inputs:e,backend:t,attrs:n}=r,{a:s,b:i}=e,{transposeA:a,transposeB:o}=n;if(s.dtype!=="float32"||i.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");const c=s.shape.length,l=i.shape.length,u=a?s.shape[c-2]:s.shape[c-1],h=o?i.shape[l-1]:i.shape[l-2],d=a?s.shape[c-1]:s.shape[c-2],p=o?i.shape[l-2]:i.shape[l-1],f=s.shape.slice(0,-2),m=i.shape.slice(0,-2),_=Ne(f),g=Ne(m),x=Lt(s.shape.slice(0,-2),i.shape.slice(0,-2)).concat([d,p]);z(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${s.shape} and ${i.shape} and transposeA=${a} and transposeB=${o} must match.`);const w=a?[_,u,d]:[_,d,u],T=o?[g,p,h]:[g,h,p],M=ln({inputs:{x:s},backend:t,attrs:{shape:w}}),S=ln({inputs:{x:i},backend:t,attrs:{shape:T}}),R=t.dataIdMap.get(M.dataId).id,k=t.dataIdMap.get(S.dataId).id,O=a?M.shape[2]:M.shape[1],A=o?S.shape[1]:S.shape[2],Y=Math.max(_,g),B=t.makeOutput([Y,O,A],M.dtype),H=t.dataIdMap.get(B.dataId).id,U=new Uint8Array(new Int32Array(M.shape).buffer),j=new Uint8Array(new Int32Array(S.shape).buffer);return r0(R,U,M.shape.length,k,j,S.shape.length,a,o,H),t.disposeData(M.dataId),t.disposeData(S.dataId),B.shape=x,B}const _7={kernelName:jc,backendName:"wasm",setupFunc:g7,kernelFunc:y7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x7(r,e,t,n){const s=Gd(t,Ne(e));if(n&&t!=="string"){let i=0;r.forEach(a=>{const o=Ne(a.shape);s.set(a.vals,i),i+=o})}else{let i=0;r.forEach(a=>{const o=t==="string"?Tm(a.vals):a.vals;let c=0;for(let l=0;l<a.shape[0];++l){const u=l*e[1]+i;for(let h=0;h<a.shape[1];++h)s[u+h]=o[c++]}i+=a.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b7(r,e,t,n){const s=r===e,i=r<e&&t<0,a=e<r&&t>1;if(s||i||a)return ta(0,n);const o=Math.abs(Math.ceil((e-r)/t)),c=ta(o,n);e<r&&t===1&&(t=-1),c[0]=r;for(let l=1;l<c.length;l++)c[l]=c[l-1]+t;return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s0(r,e,t,n,s){const i=If(n,e,t),a=Ne(t),o=Xt(n);if(i){const h=Nf(e,o);return s==="string"?r.slice(h,h+a):r.subarray(h,h+a)}const c=s==="string"?Tm(r):r,l=Mr(n,s,c),u=Mr(t,s);for(let h=0;h<u.size;++h){const d=u.indexToLoc(h),p=d.map((f,m)=>f+e[m]);u.set(l.get(...p),...d)}return s==="string"?Em(u.values):u.values}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gs(r){const{inputs:{x:e},attrs:{begin:t,size:n},backend:s}=r,[i,a]=e9(e,t,n),o=If(e.shape,i,a),c=s.readSync(e.dataId),l=s.makeOutput(a,e.dtype),u=Xt(e.shape),h=s.dataIdMap.get(l.dataId);if(o){const f=Nf(i,u);return e.dtype==="string"?h.stringBytes=c.slice(f,f+Ne(a)):s.typedArrayFromHeap(l).set(c.subarray(f,f+Ne(a))),l}if(e.dtype==="string"){const f=s0(c,i,a,e.shape,e.dtype);return h.stringBytes=f,l}const d=s.typedArrayFromHeap(l),p=e.shape.length;if(p===2)v7(c,u[0],d,i,a);else if(p===3)w7(c,u[0],u[1],d,i,a);else if(p===4)S7(c,u[0],u[1],u[2],d,i,a);else{const f=s0(c,i,a,e.shape,e.dtype);d.set(f)}return l}function v7(r,e,t,n,s){let i=0;const a=n[0],o=n[1],c=a+s[0];for(let l=a;l<c;l++){const u=l*e+o;t.set(r.subarray(u,u+s[1]),i),i+=s[1]}}function w7(r,e,t,n,s,i){let a=0;const o=s[0],c=s[1],l=s[2],u=o+i[0],h=c+i[1];for(let d=o;d<u;d++)for(let p=c;p<h;p++){const f=d*e+p*t+l;n.set(r.subarray(f,f+i[2]),a),a+=i[2]}}function S7(r,e,t,n,s,i,a){let o=0;const c=i[0],l=i[1],u=i[2],h=c+a[0],d=l+a[1],p=u+a[2],f=i[3];for(let m=c;m<h;m++)for(let _=l;_<d;_++)for(let g=u;g<p;g++){const y=m*e+_*t+g*n+f;s.set(r.subarray(y,y+a[3]),o),o+=a[3]}}const T7={kernelName:Dp,backendName:"wasm",kernelFunc:gs};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E7(r){const{inputs:e,backend:t,attrs:n}=r,{x:s}=e,{blockShape:i,crops:a}=n,o=i.reduce((g,y)=>g*y),c=bm(s.shape,i,o),l=vm(c.length,i.length),u=wm(s.shape,i,o),h=$x(a,i.length),d=Gx(u,a,i.length),p=ln({inputs:{x:s},backend:t,attrs:{shape:c}}),f=ai({inputs:{x:p},backend:t,attrs:{perm:l}}),m=ln({inputs:{x:f},backend:t,attrs:{shape:u}}),_=gs({inputs:{x:m},backend:t,attrs:{begin:h,size:d}});return t.disposeData(p.dataId),t.disposeData(f.dataId),t.disposeData(p.dataId),_}const M7={kernelName:Qd,backendName:"wasm",kernelFunc:E7};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ya(r){const{inputs:{x:e},attrs:{dtype:t},backend:n}=r,s=n.makeOutput(e.shape,t),i=n.typedArrayFromHeap(e);return n.typedArrayFromHeap(s).set(i),s}const A7={kernelName:qc,backendName:"wasm",kernelFunc:ya};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I7=qt(ep);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let i0;function N7(r){i0=r.wasm.cwrap(Kc,null,["number","number","number","number"])}function R7(r){const{inputs:e,backend:t,attrs:n}=r,{x:s}=e,{clipValueMin:i,clipValueMax:a}=n,o=t.dataIdMap.get(s.dataId).id,c=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(c.dataId).id;return i0(o,i,a,l),c}const C7={kernelName:Kc,backendName:"wasm",setupFunc:N7,kernelFunc:R7};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a0(r){const{inputs:e,backend:t}=r,n=wr(r.attrs.axis,e[0].shape)[0];let s=pl(e.map(p=>p.shape),n);const i=e.filter(p=>Ne(p.shape)>0);if(i.length===1)return Co({inputs:{x:i[0]},backend:t});const a=t.makeOutput(s,e[0].dtype);if(Ne(s)===0)return a;const o=i.map(p=>p.shape);if(Vx(o,n),i[0].dtype==="string"){const p=i.map(x=>{const w=Ne(x.shape.slice(n));return ln({inputs:{x},backend:t,attrs:{shape:[-1,w]}})}),f=p.map(x=>({vals:t.readSync(x.dataId),shape:x.shape}));s=pl(p.map(x=>x.shape),1);const m=p[0].shape[0]===1,_=x7(f,s,e[0].dtype,m),g=pl(i.map(x=>x.shape),n);a.shape=g;const y=t.dataIdMap.get(a.dataId);return y.stringBytes=Em(_),p.forEach(x=>t.disposeData(x.dataId)),a}const c=Ne(i[0].shape.slice(0,n));let l=0;const u=i.map(p=>{const f=Ne(p.shape.slice(n));return l+=f,f}),h=i.map(p=>t.typedArrayFromHeap(p)),d=t.typedArrayFromHeap(a);for(let p=0;p<c;p++){let f=p*l;for(let m=0;m<h.length;m++){const _=u[m],g=p*_,y=h[m].subarray(g,g+_);d.set(y,f),f+=_}}return a}const L7={kernelName:tp,backendName:"wasm",kernelFunc:a0};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let o0;function k7(r){o0=r.wasm.cwrap(Xc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function D7(r){const{inputs:e,attrs:t,backend:n}=r,{x:s,filter:i}=e,a=n.dataIdMap.get(s.dataId).id,o=n.dataIdMap.get(i.dataId).id,{strides:c,dilations:l,pad:u,dimRoundingMode:h,dataFormat:d}=t,p=kf(d),f=Ir(s.shape,i.shape,c,l,u,h,!1,p),m=f.filterHeight,_=f.filterWidth,g=f.padInfo.top,y=f.padInfo.right,x=f.padInfo.bottom,w=f.padInfo.left,T=f.dilationHeight,M=f.dilationWidth,S=f.strideHeight,R=f.strideWidth,k=f.inChannels,O=f.outChannels,A=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);const Y=n.makeOutput(f.outShape,"float32"),B=n.dataIdMap.get(Y.dataId).id;return o0(a,s.shape[0],s.shape[1],s.shape[2],o,m,_,g,y,x,w,A,T,M,S,R,k,O,B),Y}const P7={kernelName:Xc,backendName:"wasm",setupFunc:k7,kernelFunc:D7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let c0;function F7(r){c0=r.wasm.cwrap(Yc,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function O7(r){const{backend:e,inputs:t,attrs:n}=r,{dy:s,filter:i}=t,{strides:a,pad:o,dataFormat:c,dimRoundingMode:l,inputShape:u}=n,h=1,d=kf(c),p=Ir(u,i.shape,a,h,o,l,!1,d),{batchSize:f,filterHeight:m,filterWidth:_,inChannels:g,inHeight:y,inWidth:x,outChannels:w,outHeight:T,outWidth:M,strideHeight:S,strideWidth:R}=p,k=m-1-p.padInfo.top,O=_-1-p.padInfo.left,A=p.dataFormat==="channelsLast",Y=Xt(p.inShape),B=Xt(s.shape),[H,U,j]=Xt(i.shape),K=Y[0],se=A?Y[1]:Y[2],ue=A?Y[2]:1,Q=A?1:Y[1],ee=B[0],ge=A?B[1]:B[2],he=A?B[2]:1,Me=A?1:B[1],je=e.makeOutput(p.inShape,"float32"),ae=e.dataIdMap.get(je.dataId).id,Ve=e.dataIdMap.get(s.dataId).id,He=e.dataIdMap.get(i.dataId).id;return c0(Ve,He,f,m,_,y,x,g,T,M,w,S,R,k,O,H,U,j,K,se,ue,Q,ee,ge,he,Me,ae),je}const B7={kernelName:Yc,backendName:"wasm",setupFunc:F7,kernelFunc:O7};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z7=qt(np);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U7=qt(rp);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Dl;(function(r){r[r.bilinear=0]="bilinear",r[r.nearest=1]="nearest"})(Dl||(Dl={}));let u0;function V7(r){u0=r.wasm.cwrap(Zc,null,["number","number","number","number","array","number","number","number","number","number"])}function H7(r){const{backend:e,inputs:t,attrs:n}=r,{method:s,extrapolationValue:i,cropSize:a}=n,{image:o,boxes:c,boxInd:l}=t,u=c.shape[0],[h,d]=a,p=[u,h,d,o.shape[3]];let f=e.dataIdMap.get(o.dataId),m;o.dtype!=="float32"&&(m=ya({backend:e,inputs:{x:o},attrs:{dtype:"float32"}}),f=e.dataIdMap.get(m.dataId));const _=f.id,g=e.dataIdMap.get(c.dataId).id,y=e.dataIdMap.get(l.dataId).id,x=e.makeOutput(p,"float32"),w=e.dataIdMap.get(x.dataId).id,T=new Uint8Array(new Int32Array(o.shape).buffer);return u0(_,g,y,u,T,h,d,Dl[s],i,w),m!=null&&e.disposeData(m.dataId),x}const $7={kernelName:Zc,backendName:"wasm",setupFunc:V7,kernelFunc:H7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let l0;function G7(r){l0=r.wasm.cwrap(Jc,null,["number","number","number","number","number","number"])}function W7(r){const{inputs:e,backend:t,attrs:n}=r,{x:s}=e,{axis:i,exclusive:a,reverse:o}=n,c=s.shape.length;z(s.dtype==="float32"||s.dtype==="int32",()=>`cumsum does not support ${s.dtype} tensors in the WASM backend`);const l=jf([i],c);let u=s;l!==null&&(u=ai({inputs:{x:s},attrs:{perm:l},backend:t}));const h=ha(1,c)[0];Rr("cumsum",[h],c);const d=t.makeOutput(u.shape,u.dtype),p=u.shape[h],f=t.dataIdMap.get(u.dataId).id,m=t.dataIdMap.get(d.dataId).id;l0(f,a?1:0,o?1:0,p,m,Et[s.dtype]);let _=d;if(l!==null){const g=x_(l);_=ai({inputs:{x:d},attrs:{perm:g},backend:t}),t.disposeData(u.dataId),t.disposeData(d.dataId)}return _}const j7={kernelName:Jc,backendName:"wasm",setupFunc:G7,kernelFunc:W7};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let h0;function q7(r){h0=r.wasm.cwrap(Qc,null,["number","number","number","array","number","array","array","number","number"])}function K7(r){const{backend:e,inputs:t,attrs:n}=r,{x:s}=t,{blockSize:i,dataFormat:a}=n,o=s.shape[0],c=a==="NHWC"?s.shape[1]:s.shape[2],l=a==="NHWC"?s.shape[2]:s.shape[3],u=a==="NHWC"?s.shape[3]:s.shape[1],h=c*i,d=l*i,p=u/(i*i),f=a==="NHWC"?[o,h,d,p]:[o,p,h,d],m=e.makeOutput(f,"float32"),g=e.dataIdMap.get(s.dataId).id,y=new Uint8Array(new Int32Array(Xt(s.shape)).buffer),x=new Uint8Array(new Int32Array(f).buffer),w=new Uint8Array(new Int32Array(Xt(f)).buffer),T=e.dataIdMap.get(m.dataId).id;return h0(g,i,a==="NHWC"?1:0,y,s.shape.length-1,x,w,f.length,T),m}const X7={kernelName:Qc,backendName:"wasm",setupFunc:q7,kernelFunc:K7};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let d0;function Y7(r){d0=r.wasm.cwrap(eu,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function J7(r){const{inputs:e,attrs:t,backend:n}=r,{x:s,filter:i}=e,a=n.dataIdMap.get(s.dataId).id,o=n.dataIdMap.get(i.dataId).id,{strides:c,dilations:l,pad:u,dimRoundingMode:h}=t,d=l==null?[1,1]:l,p=Ir(s.shape,i.shape,c,d,u,h,!0),f=p.filterHeight,m=p.filterWidth,_=p.padInfo.top,g=p.padInfo.right,y=p.padInfo.bottom,x=p.padInfo.left,w=p.dilationHeight,T=p.dilationWidth,M=p.strideHeight,S=p.strideWidth,R=p.inChannels,k=p.outChannels,O=p.padInfo.type==="SAME"?1:0;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);const A=n.makeOutput(p.outShape,"float32"),Y=n.dataIdMap.get(A.dataId).id;return d0(a,s.shape[0],s.shape[1],s.shape[2],o,f,m,_,g,y,x,O,w,T,M,S,R,k,Y),A}const Z7={kernelName:eu,backendName:"wasm",setupFunc:Y7,kernelFunc:J7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q7=qt(ip);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ew=!1,tw=rn(ap,ew,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nw=qt(op,"float32");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pl(r){const{inputs:e,attrs:t,backend:n}=r,{input:s}=e,{dim:i}=t,a=s.shape.length,o=s.shape.slice();let c=i;return i<0&&(z(-(a+1)<=i,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),c=a+i+1),o.splice(c,0,1),ln({inputs:{x:s},backend:n,attrs:{shape:o}})}const rw={kernelName:cp,backendName:"wasm",kernelFunc:Pl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p0(r){const{attrs:{shape:e,value:t,dtype:n},backend:s}=r,i=s.makeOutput(e,n);return s.typedArrayFromHeap(i).fill(t),i}const sw={kernelName:up,backendName:"wasm",kernelFunc:p0};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let f0;function iw(r){f0=r.wasm.cwrap(tu,null,["number","number","number","number","number","number"])}function aw(r){const{inputs:e,backend:t}=r,{image:n}=e,s=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(n.dataId).id,a=t.dataIdMap.get(s.dataId).id,[o,c,l,u]=n.shape;return f0(i,o,c,l,u,a),s}const ow={kernelName:tu,backendName:"wasm",kernelFunc:aw,setupFunc:iw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cw=qt(lp);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uw=rn(hp);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let m0;function lw(r){m0=r.wasm.cwrap(nu,null,["number","number","number","number","number","number","number"])}function hw(r){const{backend:e,inputs:t,attrs:n}=r,{varianceEpsilon:s}=n,{x:i,mean:a,variance:o,offset:c,scale:l}=t,u=e.dataIdMap.get(i.dataId).id,h=e.dataIdMap.get(a.dataId).id,d=e.dataIdMap.get(o.dataId).id,p=c!=null?e.dataIdMap.get(c.dataId).id:0,f=l!=null?e.dataIdMap.get(l.dataId).id:0,m=e.makeOutput(i.shape,i.dtype);if(Ne(i.shape)===0)return m;const _=e.dataIdMap.get(m.dataId).id;return m0(u,h,d,p,f,s,_),m}const dw={kernelName:nu,backendName:"wasm",setupFunc:lw,kernelFunc:hw};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let g0;function pw(r){g0=r.wasm.cwrap(ho,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function fw(r){const{inputs:e,attrs:t,backend:n}=r,{x:s,filter:i,bias:a,preluActivationWeights:o}=e,{strides:c,pad:l,dilations:u,dataFormat:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=t,m=Ir(s.shape,i.shape,c,u,l,d),_=ga[p];if(_==null)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);const g=n.dataIdMap.get(s.dataId).id,y=n.dataIdMap.get(i.dataId).id,x=m.outChannels;let w=0;if(a!=null){const he=n.dataIdMap.get(a.dataId);if(he.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${he.shape.length}.`);if(he.shape[0]!==x)throw new Error(`FusedConv2D bias shape (${he.shape}) does not match the number of output channels (${x})`);w=he.id}const T=m.filterHeight,M=m.filterWidth,S=m.padInfo.top,R=m.padInfo.right,k=m.padInfo.bottom,O=m.padInfo.left,A=m.dilationHeight,Y=m.dilationWidth,B=m.strideHeight,H=m.strideWidth,U=m.inChannels,j=m.padInfo.type==="SAME"?1:0,K=m.batchSize,se=m.inHeight,ue=m.inWidth;if(h!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);const Q=n.makeOutput(m.outShape,"float32"),ee=n.dataIdMap.get(Q.dataId).id,ge=o==null?0:n.dataIdMap.get(o.dataId).id;return g0(g,K,se,ue,y,T,M,w,S,R,k,O,j,A,Y,B,H,U,x,_,ge,f||0,ee),Q}const mw={kernelName:ho,backendName:"wasm",setupFunc:pw,kernelFunc:fw};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let y0;function gw(r){y0=r.wasm.cwrap(po,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function yw(r){const{inputs:e,attrs:t,backend:n}=r,{x:s,filter:i,bias:a,preluActivationWeights:o}=e,{strides:c,pad:l,dilations:u,dataFormat:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=t,m=Ir(s.shape,i.shape,c,u,l,d,!0),_=ga[p];if(_==null)throw new Error(`${p} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);const g=n.dataIdMap.get(s.dataId).id,y=n.dataIdMap.get(i.dataId).id,x=m.outChannels;let w=0;if(a!=null){const he=n.dataIdMap.get(a.dataId);if(he.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${he.shape.length}.`);if(he.shape[0]!==x)throw new Error(`FusedDepthwiseConv2D bias shape (${he.shape}) does not match the number of output channels (${x})`);w=he.id}const T=m.filterHeight,M=m.filterWidth,S=m.padInfo.top,R=m.padInfo.right,k=m.padInfo.bottom,O=m.padInfo.left,A=m.dilationHeight,Y=m.dilationWidth,B=m.strideHeight,H=m.strideWidth,U=m.inChannels,j=m.padInfo.type==="SAME"?1:0,K=m.batchSize,se=m.inHeight,ue=m.inWidth;if(h!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${h}'. Please use 'NHWC'.`);const Q=n.makeOutput(m.outShape,"float32"),ee=n.dataIdMap.get(Q.dataId).id,ge=o==null?0:n.dataIdMap.get(o.dataId).id;return y0(g,K,se,ue,y,T,M,w,S,R,k,O,j,A,Y,B,H,U,x,_,ge,f||0,ee),Q}const _w={kernelName:po,backendName:"wasm",setupFunc:gw,kernelFunc:yw};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _0;function xw(r){_0=r.wasm.cwrap(ru,null,["number","number","number","number","number","number","array","number"])}function bw(r){const{backend:e,inputs:t}=r,{params:n,indices:s}=t,[i,a,o,c]=K4(n,s),l=e.makeOutput(i,n.dtype);if(a===0)return l;const u=s.shape,h=u[u.length-1],p=e.dataIdMap.get(n.dataId).id,m=e.dataIdMap.get(s.dataId).id,_=new Uint8Array(new Int32Array(c).buffer),g=e.dataIdMap.get(l.dataId).id;return _0(p,Et[n.dtype],m,a,h,o,_,g),l}const vw={kernelName:ru,backendName:"wasm",setupFunc:xw,kernelFunc:bw};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let x0;function ww(r){x0=r.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function Sw(r){const{backend:e,inputs:t,attrs:n}=r,{x:s,indices:i}=t,{axis:a,batchDims:o}=n,c=wr(a,s.shape)[0],l=e.readSync(i.dataId),u=s.shape[c];for(let k=0;k<l.length;++k){const O=l[k];z(O<=u-1&&O>=0,()=>`GatherV2: the index value ${O} is not in [0, ${u-1}]`)}const h=rb(s,i,c,o),d=ln({inputs:{x:s},attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]},backend:e}),p=Ne(i.shape),f=ln({inputs:{x:i},attrs:{shape:[h.batchSize,p/h.batchSize]},backend:e}),m=[h.batchSize,h.outerSize,p/h.batchSize,h.sliceSize],_=e.makeOutput(m,s.dtype);if(Ne(s.shape)===0)return _;const g=d.shape.length-1,x=e.dataIdMap.get(d.dataId).id,T=e.dataIdMap.get(f.dataId).id,M=e.dataIdMap.get(_.dataId).id,S=new Uint8Array(new Int32Array(Xt(d.shape)).buffer),R=new Uint8Array(new Int32Array(Xt(m)).buffer);return x0(x,Et[s.dtype],S,g,T,h.batchSize,R,M),e.disposeData(d.dataId),e.disposeData(f.dataId),_.shape=h.outputShape,_}const Tw={kernelName:dp,backendName:"wasm",setupFunc:ww,kernelFunc:Sw};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ew=!1,Mw=rn(pp,Ew,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aw=!1,Iw=rn(fp,Aw,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let b0;function Nw(r){b0=r.wasm.cwrap(iu,null,["number","number","number","number"])}function Rw(r){const{inputs:{x:e},attrs:{alpha:t},backend:n}=r,s=n.dataIdMap.get(e.dataId).id,i=n.makeOutput(e.shape,"float32");if(Ne(e.shape)!==0){const a=n.dataIdMap.get(i.dataId).id;b0(s,Et[e.dtype],t,a)}return i}const Cw={kernelName:iu,backendName:"wasm",setupFunc:Nw,kernelFunc:Rw};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lw=!1,kw=rn(mp,Lw,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dw=!1,Pw=rn(gp,Dw,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fw=qt(yp);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ow=!1,Bw=rn(_p,Ow,"bool");/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let v0;function zw(r){v0=r.wasm.cwrap(au,null,["number","number","number","number"])}function Uw(r){const{backend:e,inputs:t,attrs:n}=r,{reductionIndices:s,keepDims:i}=n,{x:a}=t;let c=e.dataIdMap.get(a.dataId).id,l=a;const{transposed:u,axes:h,originalAxes:d,inputWasTransposed:p}=kr(a,s,e);if(p){const x=e.dataIdMap.get(u.dataId).id;l=u,c=x}const f=l.shape.length;Rr("max",h,f);const[m,_]=ds(l.shape,h),g=Ne(_),y=e.makeOutput(m,a.dtype);if(Ne(l.shape)!==0){const x=e.dataIdMap.get(y.dataId).id;v0(c,Et[a.dtype],g,x)}if(p&&e.disposeData(u.dataId),i){const x=Gn(y.shape,d);y.shape=x}return y}const Vw={kernelName:au,backendName:"wasm",setupFunc:zw,kernelFunc:Uw};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hw=rn(xp);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let w0;function $w(r){w0=r.wasm.cwrap(ou,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Gw(r){const{inputs:e,attrs:t,backend:n}=r,s=e.x,i=n.dataIdMap.get(s.dataId).id;z(s.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${s.dtype}.`);const{filterSize:a,strides:o,pad:c,dimRoundingMode:l}=t,u=Lf(s.shape,a,o,1,c,l),h=u.filterHeight,d=u.filterWidth,p=u.padInfo.top,f=u.padInfo.right,m=u.padInfo.bottom,_=u.padInfo.left,g=u.dilationHeight,y=u.dilationWidth,x=u.strideHeight,w=u.strideWidth,T=u.inChannels,M=u.outChannels;if(u.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${u.dataFormat}'. Please use 'channelsLast'.`);const S=n.makeOutput(u.outShape,"float32"),R=n.dataIdMap.get(S.dataId).id;return w0(i,s.shape[0],s.shape[1],s.shape[2],h,d,p,f,m,_,g,y,x,w,T,M,R),S}const Ww={kernelName:ou,backendName:"wasm",setupFunc:$w,kernelFunc:Gw};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let S0;function jw(r){S0=r.wasm.cwrap(cu,null,["number, number, number"])}function qw(r){const{backend:e,inputs:t,attrs:n}=r,{axis:s,keepDims:i}=n,{x:a}=t,o=e.dataIdMap.get(a.dataId).id;let c=o,l=a;const{transposed:u,axes:h,originalAxes:d,inputWasTransposed:p}=kr(a,s,e);let f=h;if(p){const w=e.dataIdMap.get(u.dataId).id;w!==o&&(l=u,c=w,f=ha(f.length,l.shape.length))}Rr("mean",f,l.shape.length);const[m,_]=ds(l.shape,f),g=Ne(_);let y=l;l.dtype!=="float32"&&(y=ya({backend:e,inputs:{x:l},attrs:{dtype:"float32"}}),c=e.dataIdMap.get(y.dataId).id);const x=e.makeOutput(m,"float32");if(Ne(l.shape)!==0){const w=e.dataIdMap.get(x.dataId).id;S0(c,g,w)}if(p&&e.disposeData(u.dataId),i){const w=Gn(x.shape,d);x.shape=w}return l.dtype!=="float32"&&e.disposeData(y.dataId),x}const Kw={kernelName:cu,backendName:"wasm",setupFunc:jw,kernelFunc:qw};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let T0;function Xw(r){T0=r.wasm.cwrap(uu,null,["number","number","number","number"])}function Yw(r){const{backend:e,inputs:t,attrs:n}=r,{axis:s,keepDims:i}=n,{x:a}=t,o=e.dataIdMap.get(a.dataId).id;let c=o,l=a;const{transposed:u,axes:h,originalAxes:d,inputWasTransposed:p}=kr(a,s,e);if(p){const x=e.dataIdMap.get(u.dataId).id;x!==o&&(l=u,c=x)}const f=l.shape.length;Rr("min",h,f);const[m,_]=ds(l.shape,h),g=Ne(_),y=e.makeOutput(m,l.dtype);if(Ne(l.shape)!==0){const x=e.dataIdMap.get(y.dataId).id;T0(c,Et[a.dtype],g,x)}if(p&&e.disposeData(u.dataId),i){const x=Gn(y.shape,d);y.shape=x}return y}const Jw={kernelName:uu,backendName:"wasm",setupFunc:Xw,kernelFunc:Yw};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zw=rn(bp);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Fl;(function(r){r[r.reflect=0]="reflect",r[r.symmetric=1]="symmetric"})(Fl||(Fl={}));let E0;function Qw(r){E0=r.wasm.cwrap(lu,null,["number","array","number","number","array","array","number","number"])}function eS(r){const{inputs:{x:e},backend:t,attrs:{paddings:n,mode:s}}=r,i=n.map((f,m)=>f[0]+e.shape[m]+f[1]),a=t.dataIdMap.get(e.dataId).id,o=t.makeOutput(i,e.dtype),c=t.dataIdMap.get(o.dataId).id,l=new Uint8Array(new Int32Array(e.shape).buffer),u=n.map(f=>f[0]),h=n.map(f=>f[1]),d=new Uint8Array(new Int32Array(u).buffer),p=new Uint8Array(new Int32Array(h).buffer);return E0(a,l,e.shape.length,Et[e.dtype],d,p,Fl[s],c),o}const tS={kernelName:lu,backendName:"wasm",kernelFunc:eS,setupFunc:Qw};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nS=rn(vp);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rS=qt(wp);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ol(r,e){const t=new Int32Array(r.wasm.HEAPU8.buffer,e,4),n=t[0],s=t[1],i=t[2],a=t[3];return r.wasm._free(e),{pSelectedIndices:n,selectedSize:s,pSelectedScores:i,pValidOutputs:a}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let M0;function sS(r){M0=r.wasm.cwrap(hu,"number",["number","number","number","number","number"])}function iS(r){const{backend:e,inputs:t,attrs:n}=r,{iouThreshold:s,maxOutputSize:i,scoreThreshold:a}=n,{boxes:o,scores:c}=t,l=e.dataIdMap.get(o.dataId).id,u=e.dataIdMap.get(c.dataId).id,h=M0(l,u,i,s,a),{pSelectedIndices:d,selectedSize:p,pSelectedScores:f,pValidOutputs:m}=Ol(e,h);return e.wasm._free(f),e.wasm._free(m),e.makeOutput([p],"int32",d)}const aS={kernelName:hu,backendName:"wasm",setupFunc:sS,kernelFunc:iS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let A0;function oS(r){A0=r.wasm.cwrap(du,"number",["number","number","number","number","number","bool"])}function cS(r){const{backend:e,inputs:t,attrs:n}=r,{iouThreshold:s,maxOutputSize:i,scoreThreshold:a,padToMaxOutputSize:o}=n,{boxes:c,scores:l}=t,u=e.dataIdMap.get(c.dataId).id,h=e.dataIdMap.get(l.dataId).id,d=A0(u,h,i,s,a,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:_}=Ol(e,d);e.wasm._free(m);const g=e.makeOutput([f],"int32",p),y=e.makeOutput([],"int32",_);return[g,y]}const uS={kernelName:du,backendName:"wasm",setupFunc:oS,kernelFunc:cS};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let I0;function lS(r){I0=r.wasm.cwrap(pu,"number",["number","number","number","number","number","number"])}function hS(r){const{backend:e,inputs:t,attrs:n}=r,{iouThreshold:s,maxOutputSize:i,scoreThreshold:a,softNmsSigma:o}=n,{boxes:c,scores:l}=t,u=e.dataIdMap.get(c.dataId).id,h=e.dataIdMap.get(l.dataId).id,d=I0(u,h,i,s,a,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:_}=Ol(e,d);e.wasm._free(_);const g=e.makeOutput([f],"int32",p),y=e.makeOutput([f],"float32",m);return[g,y]}const dS={kernelName:pu,backendName:"wasm",setupFunc:lS,kernelFunc:hS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pS=!1,fS=rn(Sp,pS,"bool");/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let N0;function mS(r){N0=r.wasm.cwrap(fu,null,["number","number","number","number","number"])}function gS(r){const{inputs:e,backend:t,attrs:n}=r,{indices:s}=e,{depth:i,onValue:a,offValue:o}=n,c=t.makeOutput([...s.shape,i],"int32"),l=t.dataIdMap.get(c.dataId).id,h=t.dataIdMap.get(s.dataId).id;return N0(h,i,a,o,l),c}const yS={kernelName:fu,backendName:"wasm",setupFunc:mS,kernelFunc:gS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _S(r){const{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(n).fill(1),n}const xS={kernelName:Tp,backendName:"wasm",kernelFunc:_S};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bS(r){const{inputs:e,backend:t,attrs:n}=r,{axis:s}=n;if(e.length===1)return Pl({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const i=e[0].shape,a=e[0].dtype;e.forEach(u=>{Pn(i,u.shape,"All tensors passed to stack must have matching shapes"),z(a===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],c=e.map(u=>{const h=Pl({inputs:{input:u},backend:t,attrs:{dim:s}});return o.push(h),h}),l=a0({inputs:c,backend:t,attrs:{axis:s}});return o.forEach(u=>t.disposeData(u.dataId)),l}const vS={kernelName:Ep,backendName:"wasm",kernelFunc:bS};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let R0;function wS(r){R0=r.wasm.cwrap(mu,null,["number","array","number","number","array","array","number","number"])}function SS(r){const{inputs:{x:e},backend:t,attrs:{paddings:n,constantValue:s}}=r,i=n.map((m,_)=>m[0]+e.shape[_]+m[1]);if(Ne(e.shape)===0)return p0({backend:t,attrs:{shape:i,value:s,dtype:e.dtype}});const a=t.dataIdMap.get(e.dataId).id,o=t.makeOutput(i,e.dtype),l=t.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(e.shape).buffer),h=n.map(m=>m[0]),d=n.map(m=>m[1]),p=new Uint8Array(new Int32Array(h).buffer),f=new Uint8Array(new Int32Array(d).buffer);return R0(a,u,e.shape.length,Et[e.dtype],p,f,s,l),o}const C0={kernelName:mu,backendName:"wasm",kernelFunc:SS,setupFunc:wS};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TS=rn(Mp);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let L0;function ES(r){L0=r.wasm.cwrap(gu,null,["number","number","number"])}function MS(r){const{inputs:e,backend:t}=r,{x:n,alpha:s}=e,i=t.dataIdMap.get(n.dataId).id,a=t.dataIdMap.get(s.dataId).id;let o=i;const c=n;let l=c;c.dtype!=="float32"&&(l=ya({backend:t,inputs:{x:n},attrs:{dtype:"float32"}}),o=t.dataIdMap.get(l.dataId).id);const u=t.makeOutput(n.shape,"float32"),h=t.dataIdMap.get(u.dataId).id;return L0(o,a,h),c.dtype!=="float32"&&t.disposeData(l.dataId),u}const AS={kernelName:gu,backendName:"wasm",setupFunc:ES,kernelFunc:MS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let k0;function IS(r){k0=r.wasm.cwrap(yu,null,["number","number","number","number"])}function NS(r){const{backend:e,inputs:t,attrs:n}=r,{axis:s,keepDims:i}=n,{x:a}=t,o=e.dataIdMap.get(a.dataId).id;let c=o,l=a;const{transposed:u,axes:h,originalAxes:d,inputWasTransposed:p}=kr(a,s,e);let f=h;if(p){const x=e.dataIdMap.get(u.dataId).id;x!==o&&(l=u,c=x,f=ha(f.length,l.shape.length))}Rr("prod",f,l.shape.length);const[m,_]=ds(l.shape,f),g=Ne(_),y=e.makeOutput(m,l.dtype);if(Ne(l.shape)!==0){const x=e.dataIdMap.get(y.dataId).id;k0(c,g,Et[y.dtype],x)}if(p&&e.disposeData(u.dataId),i){const x=Gn(y.shape,d);y.shape=x}return y}const RS={kernelName:yu,backendName:"wasm",setupFunc:IS,kernelFunc:NS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CS=r=>{const{backend:e,attrs:t}=r,{start:n,stop:s,step:i,dtype:a}=t,o=b7(n,s,i,a),c=e.makeOutput([o.length],a);return e.typedArrayFromHeap(c).set(o),c},LS={kernelName:Ap,backendName:"wasm",kernelFunc:CS};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kS=rn(sp);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DS=qt(Ip);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PS=qt(Rp);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let D0;function FS(r){D0=r.wasm.cwrap(_u,null,["number","number","number","number","number","number","number","number","number","number"])}function OS(r){const{backend:e,inputs:t,attrs:n}=r,{images:s}=t,{alignCorners:i,halfPixelCenters:a,size:o}=n,[c,l]=o,[u,h,d,p]=s.shape,f=[u,c,l,p];let m=e.dataIdMap.get(s.dataId),_;m.dtype!=="float32"&&(_=ya({backend:e,inputs:{x:s},attrs:{dtype:"float32"}}),m=e.dataIdMap.get(_.dataId));const g=m.id,y=e.makeOutput(f,"float32");if(Ne(s.shape)===0)return y;const x=e.dataIdMap.get(y.dataId).id;return D0(g,u,h,d,p,c,l,i?1:0,a?1:0,x),_!=null&&e.disposeData(_.dataId),y}const BS={kernelName:_u,backendName:"wasm",setupFunc:FS,kernelFunc:OS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let P0;function zS(r){P0=r.wasm.cwrap(xu,null,["number","array","number","array","number","number"])}function US(r){const{inputs:e,backend:t,attrs:n}=r,{x:s}=e,{dims:i}=n,a=wr(i,s.shape);if(s.shape.length===0)return Co({inputs:{x:s},backend:t});const o=t.makeOutput(s.shape,s.dtype),c=t.dataIdMap.get(s.dataId).id,l=t.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(a).buffer),h=new Uint8Array(new Int32Array(s.shape).buffer);P0(c,u,a.length,h,s.shape.length,l);const d=ln({inputs:{x:o},attrs:{shape:s.shape},backend:t});return t.disposeData(o.dataId),d}const VS={kernelName:xu,backendName:"wasm",kernelFunc:US,setupFunc:zS};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let F0;function HS(r){F0=r.wasm.cwrap(Nu,null,["number","number","number","number","number","number","number","number","array","number","number"])}function $S(r){const{inputs:e,backend:t,attrs:n}=r,{image:s}=e,{radians:i,fillValue:a,center:o}=n,c=t.makeOutput(s.shape,s.dtype),l=t.dataIdMap.get(s.dataId).id,u=t.dataIdMap.get(c.dataId).id,[h,d,p,f]=s.shape,[m,_]=Hx(o,d,p),g=a===0,y=255,x=typeof a=="number"?[a,a,a,g?0:y]:[...a,y],w=new Uint8Array(new Int32Array(x).buffer);return F0(l,h,d,p,f,i,m,_,w,x.length,u),c}const GS={kernelName:Nu,backendName:"wasm",kernelFunc:$S,setupFunc:HS};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WS=qt(Cp);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jS=qt(Lp);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let O0;function qS(r){O0=r.wasm.cwrap(bu,null,["number","number","number","number","number","number","array","number","number"])}function KS(r){const{backend:e,inputs:t,attrs:n}=r,{indices:s,updates:i}=t,{shape:a}=n,o=e.makeOutput(a,i.dtype);if(Ne(a)===0)return o;const{sliceRank:c,numUpdates:l,sliceSize:u,strides:h,outputSize:d}=J4(i,s,a),f=e.dataIdMap.get(s.dataId).id,_=e.dataIdMap.get(i.dataId).id,g=new Uint8Array(new Int32Array(h).buffer),y=e.dataIdMap.get(o.dataId).id;return O0(f,_,Et[i.dtype],c,l,u,g,d,y),o}const XS={kernelName:bu,backendName:"wasm",setupFunc:qS,kernelFunc:KS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let B0;function YS(r){B0=r.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function JS(r){const{inputs:e,backend:t}=r,{condition:n,t:s,e:i}=e,a=t.dataIdMap.get(n.dataId).id,o=t.dataIdMap.get(s.dataId).id,c=t.dataIdMap.get(i.dataId).id,l=t.makeOutput(s.shape,s.dtype),u=t.dataIdMap.get(l.dataId).id,h=n.shape.length,d=s.shape.length,p=h===0||h>1||d===1?1:Ne(s.shape.slice(1));return B0(a,o,c,p,u),l}const ZS={kernelName:kp,backendName:"wasm",kernelFunc:JS,setupFunc:YS};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let z0;function QS(r){z0=r.wasm.cwrap(Fp,null,["number","number"])}function eT(r){const{backend:e,inputs:{x:t}}=r,n=e.dataIdMap.get(t.dataId).id,s=e.makeOutput(t.shape,t.dtype),i=e.dataIdMap.get(s.dataId).id;return Ne(s.shape)===0||z0(n,i),s}const tT={kernelName:"Sigmoid",backendName:"wasm",setupFunc:QS,kernelFunc:eT};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nT=qt(Pp);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let U0;function rT(r){U0=r.wasm.cwrap(wu,null,["number","number","number","number"])}function sT(r){const{backend:e,inputs:{logits:t},attrs:{dim:n}}=r,s=e.dataIdMap.get(t.dataId).id,i=e.makeOutput(t.shape,t.dtype),a=e.dataIdMap.get(i.dataId).id,o=t.shape[n],c=Ne(t.shape)/o;return Ne(i.shape)===0||U0(s,a,o,c),i}const iT={kernelName:wu,backendName:"wasm",setupFunc:rT,kernelFunc:sT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aT(r){const{inputs:e,backend:t,attrs:n}=r,{x:s}=e,{blockShape:i,paddings:a}=n,o=Ne(i),c=[[0,0]];c.push(...a);for(let M=1+i.length;M<s.shape.length;++M)c.push([0,0]);const l=C0.kernelFunc({inputs:{x:s},backend:t,attrs:{paddings:c,constantValue:0}}),u=bm(l.shape,i,o,!1),h=vm(u.length,i.length,!1),d=wm(l.shape,i,o,!1),m=ln({inputs:{x:l},backend:t,attrs:{shape:u}}),y=ai({inputs:{x:m},backend:t,attrs:{perm:h}}),T=ln({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeData(l.dataId),t.disposeData(m.dataId),t.disposeData(y.dataId),T}const oT={kernelName:Bp,backendName:"wasm",kernelFunc:aT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let V0;function cT(r){V0=r.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function uT(r){const{backend:e,inputs:t}=r,{indices:n,values:s,denseShape:i,defaultValue:a}=t,o=n.shape[0],c=n.shape[1],l=e.readSync(i.dataId)[0],u=[o+l,c],h=e.dataIdMap.get(n.dataId).id,d=e.dataIdMap.get(s.dataId).id,p=e.dataIdMap.get(a.dataId).id,f=e.makeOutput(u,n.dtype),m=e.dataIdMap.get(f.dataId).id,_=e.makeOutput(u.slice(0,1),s.dtype),g=e.dataIdMap.get(_.dataId).id,y=e.makeOutput([l],"bool"),x=e.dataIdMap.get(y.dataId).id,w=e.makeOutput([o],n.dtype),T=e.dataIdMap.get(w.dataId).id,M=e.makeOutput([4],"int32"),S=e.dataIdMap.get(M.dataId).id,R=V0(h,d,Et[s.dtype],o,l,c,p,m,g,x,T,S),k=e.readSync(M.dataId);let O;switch(k[0]){case 1:{O=jx(k[1]);break}case 2:{O=qx(k[1],k[2]);break}case 3:O=Kx(k[1],k[2],k[3]);break;default:O=""}if(e.disposeData(M.dataId),O)throw e.disposeData(f.dataId),e.disposeData(_.dataId),e.disposeData(y.dataId),e.disposeData(w.dataId),new Error(O);let A=f,Y=_;return R!==u[0]&&(A=gs({inputs:{x:f},attrs:{begin:0,size:[R,c]},backend:e}),Y=gs({inputs:{x:_},attrs:{begin:0,size:R},backend:e}),e.disposeData(f.dataId),e.disposeData(_.dataId)),[A,Y,y,w]}const lT={kernelName:Up,backendName:"wasm",setupFunc:cT,kernelFunc:uT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let H0;function hT(r){H0=r.wasm.cwrap(Su,null,["number","number","number","number","number","number","number"])}function dT(r){const{backend:e,inputs:t}=r,{inputIndices:n,inputShape:s,newShape:i}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=e.dataIdMap.get(n.dataId).id,o=e.dataIdMap.get(s.dataId).id,c=e.dataIdMap.get(i.dataId).id,l=n.shape[0],u=Ne(i.shape),h=e.makeOutput([l,u],n.dtype),d=e.dataIdMap.get(h.dataId).id,p=e.makeOutput([u],i.dtype),f=e.dataIdMap.get(p.dataId).id,m=e.makeOutput([3],"int32"),_=e.dataIdMap.get(m.dataId).id;H0(a,o,c,l,d,f,_);const g=e.readSync(m.dataId);let y;switch(g[0]){case 0:{y=Xx(g[1],g[2]);break}case 1:{y=Yx(g[1],g[2]);break}case 2:y=Jx();break;case 3:{const x=Array.from(e.readSync(s.dataId)),w=Array.from(e.readSync(p.dataId));y=Zx(x,w);break}case 4:{const x=Array.from(e.readSync(s.dataId)),w=Array.from(e.readSync(p.dataId));y=Qx(x,w);break}default:y=""}if(e.disposeData(m.dataId),y)throw e.disposeData(h.dataId),e.disposeData(p.dataId),new Error(y);return[h,p]}const pT={kernelName:Su,backendName:"wasm",setupFunc:hT,kernelFunc:dT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let $0;function G0(r){$0=r.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function W0(r,e){const{backend:t,inputs:n}=r,{data:s,indices:i,segmentIds:a}=n,o=i.shape[0],c=t.readSync(a.dataId,o-1,o)[0],u=o>0?c+1:0;if(u<0)throw new Error(Sm());const h=s.shape.slice();h[0]=u;const d=t.dataIdMap.get(s.dataId).id,p=t.dataIdMap.get(i.dataId).id,f=t.dataIdMap.get(a.dataId).id,m=t.makeOutput(h,s.dtype),_=t.dataIdMap.get(m.dataId).id,g=t.makeOutput([4],"int32"),y=t.dataIdMap.get(g.dataId).id;$0(d,Et[s.dtype],s.shape[0],p,f,_,y,e,0);const x=t.readSync(g.dataId);let w;switch(x[0]){case 0:{w=Sm();break}case 1:{w=eb();break}case 2:w=tb(x[1],x[2]);break;case 3:w=nb(x[1],x[2],x[3]);break;default:w=""}if(t.disposeData(g.dataId),w)throw t.disposeData(m.dataId),new Error(w);return m}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fT(r){return W0(r,!0)}const mT={kernelName:Vp,backendName:"wasm",setupFunc:G0,kernelFunc:fT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gT(r){return W0(r,!1)}const yT={kernelName:Hp,backendName:"wasm",setupFunc:G0,kernelFunc:gT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _T(r){const{inputs:e,attrs:t,backend:n}=r,{x:s}=e,{numOrSizeSplits:i,axis:a}=t,o=wr(a,s.shape)[0],c=Wx(s,i,o),l=new Array(s.shape.length).fill(0),u=s.shape.slice();return c.map(h=>{const d=[...u];d[o]=h;const p=gs({inputs:{x:s},attrs:{begin:l,size:d},backend:n});return l[o]+=h,p})}const xT={kernelName:zp,backendName:"wasm",kernelFunc:_T};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bT=qt(Op);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vT=qt(Dy);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wT=rn($p);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let j0;function ST(r){j0=r.wasm.cwrap(Iu,null,["number","number","number","number"])}function TT(r){const{backend:e,inputs:t,attrs:n}=r,{alpha:s}=n,{x:i}=t,a=e.dataIdMap.get(i.dataId).id,o=e.makeOutput(i.shape,i.dtype),c=e.dataIdMap.get(o.dataId).id;return j0(a,s,Et[i.dtype],c),o}const ET={kernelName:Iu,backendName:"wasm",setupFunc:ST,kernelFunc:TT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let q0;function MT(r){q0=r.wasm.cwrap(Tu,null,["number","array","number","array","array","array","array","array","number","number"])}function AT(r){const{backend:e,inputs:t,attrs:n}=r,{x:s}=t,{begin:i,end:a,strides:o,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=n,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:_,isSimpleSlice:g,begin:y,end:x,strides:w}=t9(s.shape,i,a,o,c,l,u,h,d);let T;if(m)T=ln({inputs:{x:s},backend:e,attrs:{shape:f}});else if(_||g){z(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const M=Q4(y,x,w),S=gs({inputs:{x:s},backend:e,attrs:{begin:y,size:M}});T=ln({inputs:{x:S},backend:e,attrs:{shape:f}}),e.disposeData(S.dataId)}else{const M=e.makeOutput(p,"float32"),S=e.dataIdMap.get(s.dataId).id,R=new Uint8Array(new Int32Array(Xt(s.shape)).buffer),k=new Uint8Array(new Int32Array(y).buffer),O=new Uint8Array(new Int32Array(x).buffer),A=new Uint8Array(new Int32Array(w).buffer),Y=new Uint8Array(new Int32Array(p).buffer),B=new Uint8Array(new Int32Array(Xt(p)).buffer),H=e.dataIdMap.get(M.dataId).id;q0(S,R,s.shape.length,k,O,A,Y,B,p.length,H),T=ln({inputs:{x:M},backend:e,attrs:{shape:f}}),e.disposeData(M.dataId)}return T}const IT={kernelName:Tu,backendName:"wasm",setupFunc:MT,kernelFunc:AT};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NT=rn(Gp);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let K0;function RT(r){K0=r.wasm.cwrap(vu,null,["number","number","number","number"])}function CT(r){const{backend:e,inputs:t,attrs:n}=r,{axis:s,keepDims:i}=n,{x:a}=t,o=e.dataIdMap.get(a.dataId).id;let c=o,l=a;const{transposed:u,axes:h,originalAxes:d,inputWasTransposed:p}=kr(a,s,e);let f=h;if(p){const x=e.dataIdMap.get(u.dataId).id;x!==o&&(l=u,c=x,f=ha(f.length,l.shape.length))}Rr("sum",f,l.shape.length);const[m,_]=ds(l.shape,f),g=Ne(_),y=e.makeOutput(m,l.dtype);if(Ne(l.shape)!==0){const x=e.dataIdMap.get(y.dataId).id;K0(c,g,Et[y.dtype],x)}if(p&&e.disposeData(u.dataId),i){const x=Gn(y.shape,d);y.shape=x}return y}const LT={kernelName:vu,backendName:"wasm",setupFunc:RT,kernelFunc:CT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kT=qt(Wp);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DT=qt(jp);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let X0;function PT(r){X0=r.wasm.cwrap(uo,null,["number","array","number","array","number","number"])}function FT(r){const{inputs:e,backend:t,attrs:n}=r,{x:s}=e,i=t.dataIdMap.get(s.dataId).id,{reps:a}=n,o=new Array(s.shape.length);for(let d=0;d<o.length;d++)o[d]=s.shape[d]*a[d];const c=new Uint8Array(new Int32Array(s.shape).buffer),l=new Uint8Array(new Int32Array(o).buffer),u=t.makeOutput(o,s.dtype),h=t.dataIdMap.get(u.dataId).id;return X0(i,c,s.shape.length,l,o.length,Et[u.dtype],h),u}const OT={kernelName:uo,backendName:"wasm",setupFunc:PT,kernelFunc:FT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Y0;function BT(r){Y0=r.wasm.cwrap(Eu,null,["number","array","number","number","number","bool","number","number"])}const zT=({inputs:r,backend:e,attrs:t})=>{const{x:n}=r,{k:s,sorted:i}=t,a=e.dataIdMap.get(n.dataId).id,o=new Uint8Array(new Int32Array(n.shape).buffer),c=n.shape.slice();c[c.length-1]=s;const l=e.makeOutput(c,n.dtype),u=e.dataIdMap.get(l.dataId).id,h=e.makeOutput(c,"int32"),d=e.dataIdMap.get(h.dataId).id;return Y0(a,o,n.shape.length,Et[n.dtype],s,i,u,d),[l,h]},UT={kernelName:Eu,backendName:"wasm",setupFunc:BT,kernelFunc:zT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let J0;function VT(r){J0=r.wasm.cwrap(Mu,null,["number","number","bool","number","number","number","number","number","number","array","number","number","number","number","number"])}function HT(r){const{backend:e,inputs:t,attrs:n}=r,{image:s,transforms:i}=t,{interpolation:a,fillMode:o,fillValue:c,outputShape:l}=n,[u,h,d,p]=s.shape,[f,m]=l!=null?l:[h,d],_=[u,f,m,p],g=new Uint8Array(new Int32Array(Xt(s.shape)).buffer),y=e.makeOutput(_,s.dtype),x=e.dataIdMap.get(y.dataId).id,T=e.dataIdMap.get(s.dataId).id,S=e.dataIdMap.get(i.dataId).id,R=a==="nearest"?1:2;let k;switch(o){case"constant":k=1;break;case"reflect":k=2;break;case"wrap":k=3;break;case"nearest":k=4;break;default:k=1;break}return J0(T,S,i.shape[0]>1,u,f,m,p,d,h,g,s.shape.length-1,R,k,c,x),y}const $T={kernelName:Mu,backendName:"wasm",setupFunc:VT,kernelFunc:HT};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GT(r){const{inputs:e,backend:t,attrs:n}=r,{value:s}=e;let{axis:i}=n;i<0&&(i+=s.shape.length);const a=s.shape[i],o=s.shape.length,c=new Array(o-1);let l=0;for(let p=0;p<o;p++)p!==i&&(c[l++]=s.shape[p]);const u=new Array(a),h=new Array(o).fill(0),d=s.shape.slice();d[i]=1;for(let p=0;p<u.length;p++)h[i]=p,u[p]=gs({inputs:{x:s},attrs:{begin:h,size:d},backend:t});return u.map(({dataId:p,dtype:f})=>({dataId:p,dtype:f,shape:c}))}const WT={kernelName:qp,backendName:"wasm",kernelFunc:GT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jT(r){const{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(n).fill(0),n}const qT={kernelName:Kp,backendName:"wasm",kernelFunc:jT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KT=[qv,Kv,Jv,i7,c7,h7,f7,_7,M7,A7,I7,C7,L7,P7,B7,z7,U7,$7,j7,X7,Z7,Q7,tw,nw,rw,sw,ow,cw,uw,jv,dw,mw,_w,vw,Tw,Mw,Iw,Zv,Cw,kw,Pw,Fw,Bw,Vw,Hw,Ww,Kw,Jw,Zw,tS,nS,rS,aS,uS,dS,fS,yS,xS,vS,C0,TS,AS,RS,LS,kS,DS,PS,m7,BS,VS,GS,jS,WS,XS,ZS,tT,nT,T7,iT,oT,lT,pT,mT,yT,xT,bT,vT,wT,ET,IT,NT,LT,kT,DT,OT,UT,$T,n7,WT,qT];for(const r of KT)Uy(r);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bl=nt();Bl.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])));Bl.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(Bl.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var Z0={exports:{}},XT={},YT=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",default:XT}),jn=x3(YT);(function(r,e){var t=function(){var n=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(n=n||__filename),function(s){s=s||{};function i(){return ue.buffer!=ie&&We(ue.buffer),me}function a(){return ue.buffer!=ie&&We(ue.buffer),Ie}function o(){return ue.buffer!=ie&&We(ue.buffer),be}function c(){return ue.buffer!=ie&&We(ue.buffer),Ge}function l(){return ue.buffer!=ie&&We(ue.buffer),$e}var u=typeof s!="undefined"?s:{},h,d;u.ready=new Promise(function(v,E){h=v,d=E});var p;typeof process!="undefined"&&process.listeners&&(p={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f={},m;for(m in u)u.hasOwnProperty(m)&&(f[m]=u[m]);var _=function(v,E){throw E},g=!1,y=!1,x=!1,w=!1;g=typeof window=="object",y=typeof importScripts=="function",x=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",w=!g&&!x&&!y;var T=u.ENVIRONMENT_IS_PTHREAD||!1;T&&(ie=u.buffer);var M="";function S(v){return u.locateFile?u.locateFile(v,M):M+v}var R,k,O,A,Y;if(x){y?M=jn.dirname(M)+"/":M=__dirname+"/",R=function(E,P){return A||(A=jn),Y||(Y=jn),E=Y.normalize(E),A.readFileSync(E,P?null:"utf8")},O=function(E){var P=R(E,!0);return P.buffer||(P=new Uint8Array(P)),ge(P.buffer),P},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(v){if(!(v instanceof ea))throw v}),process.on("unhandledRejection",Je),_=function(v){process.exit(v)},u.inspect=function(){return"[Emscripten Module object]"};var B;try{B=require("worker_threads")}catch(v){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),v}vr.Worker=B.Worker}else w?(typeof read!="undefined"&&(R=function(E){return read(E)}),O=function(E){var P;return typeof readbuffer=="function"?new Uint8Array(readbuffer(E)):(P=read(E,"binary"),ge(typeof P=="object"),P)},typeof scriptArgs!="undefined"&&scriptArgs,typeof quit=="function"&&(_=function(v){quit(v)}),typeof print!="undefined"&&(typeof console=="undefined"&&(console={}),console.log=print,console.warn=console.error=typeof printErr!="undefined"?printErr:print)):(g||y)&&(y?M=self.location.href:typeof document!="undefined"&&document.currentScript&&(M=document.currentScript.src),typeof n!="undefined"&&n&&(M=n),M.indexOf("blob:")!==0?M=M.substr(0,M.lastIndexOf("/")+1):M="",x?(R=function(E,P){return A||(A=jn),Y||(Y=jn),E=Y.normalize(E),A.readFileSync(E,P?null:"utf8")},O=function(E){var P=R(E,!0);return P.buffer||(P=new Uint8Array(P)),ge(P.buffer),P}):(R=function(v){var E=new XMLHttpRequest;return E.open("GET",v,!1),E.send(null),E.responseText},y&&(O=function(v){var E=new XMLHttpRequest;return E.open("GET",v,!1),E.responseType="arraybuffer",E.send(null),new Uint8Array(E.response)}),k=function(v,E,P){var X=new XMLHttpRequest;X.open("GET",v,!0),X.responseType="arraybuffer",X.onload=function(){if(X.status==200||X.status==0&&X.response){E(X.response);return}P()},X.onerror=P,X.send(null)}));x&&typeof performance=="undefined"&&(vr.performance=jn.performance);var H=u.print||console.log.bind(console),U=u.printErr||console.warn.bind(console);for(m in f)f.hasOwnProperty(m)&&(u[m]=f[m]);f=null,u.arguments,u.thisProgram,u.quit&&(_=u.quit);function j(v){j.shown||(j.shown={}),j.shown[v]||(j.shown[v]=1,U(v))}var K;u.wasmBinary&&(K=u.wasmBinary);var se=u.noExitRuntime||!0;typeof WebAssembly!="object"&&Je("no native wasm support detected");var ue,Q,ee=!1;function ge(v,E){v||Je("Assertion failed: "+E)}function he(v){var E=u["_"+v];return ge(E,"Cannot call unknown function "+v+", make sure it is exported"),E}function Me(v,E,P,X,xe){var ye={string:function(tn){var $s=0;if(tn!=null&&tn!==0){var Pd=(tn.length<<2)+1;$s=Us(Pd),Re(tn,$s,Pd)}return $s},array:function(tn){var $s=Us(tn.length);return Ye(tn,$s),$s}};function _e(tn){return E==="string"?Ve(tn):E==="boolean"?Boolean(tn):tn}var De=he(v),at=[],Pt=0;if(X)for(var Ct=0;Ct<X.length;Ct++){var br=ye[P[Ct]];br?(Pt===0&&(Pt=Qi()),at[Ct]=br(X[Ct])):at[Ct]=X[Ct]}var Hs=De.apply(null,at);return Hs=_e(Hs),Pt!==0&&zs(Pt),Hs}function je(v,E,P,X){P=P||[];var xe=P.every(function(_e){return _e==="number"}),ye=E!=="string";return ye&&xe&&!X?he(v):function(){return Me(v,E,P,arguments)}}function ae(v,E,P){for(var X=E+P,xe="";!(E>=X);){var ye=v[E++];if(!ye)return xe;if(!(ye&128)){xe+=String.fromCharCode(ye);continue}var _e=v[E++]&63;if((ye&224)==192){xe+=String.fromCharCode((ye&31)<<6|_e);continue}var De=v[E++]&63;if((ye&240)==224?ye=(ye&15)<<12|_e<<6|De:ye=(ye&7)<<18|_e<<12|De<<6|v[E++]&63,ye<65536)xe+=String.fromCharCode(ye);else{var at=ye-65536;xe+=String.fromCharCode(55296|at>>10,56320|at&1023)}}return xe}function Ve(v,E){return v?ae(a(),v,E):""}function He(v,E,P,X){if(!(X>0))return 0;for(var xe=P,ye=P+X-1,_e=0;_e<v.length;++_e){var De=v.charCodeAt(_e);if(De>=55296&&De<=57343){var at=v.charCodeAt(++_e);De=65536+((De&1023)<<10)|at&1023}if(De<=127){if(P>=ye)break;E[P++]=De}else if(De<=2047){if(P+1>=ye)break;E[P++]=192|De>>6,E[P++]=128|De&63}else if(De<=65535){if(P+2>=ye)break;E[P++]=224|De>>12,E[P++]=128|De>>6&63,E[P++]=128|De&63}else{if(P+3>=ye)break;E[P++]=240|De>>18,E[P++]=128|De>>12&63,E[P++]=128|De>>6&63,E[P++]=128|De&63}}return E[P]=0,P-xe}function Re(v,E,P){return He(v,a(),E,P)}function ze(v){for(var E=0,P=0;P<v.length;++P){var X=v.charCodeAt(P);X>=55296&&X<=57343&&(X=65536+((X&1023)<<10)|v.charCodeAt(++P)&1023),X<=127?++E:X<=2047?E+=2:X<=65535?E+=3:E+=4}return E}function Ye(v,E){i().set(v,E)}function te(v,E){return v%E>0&&(v+=E-v%E),v}var ie,me,Ie,be,Ge,$e;function We(v){ie=v,u.HEAP8=me=new Int8Array(v),u.HEAP16=new Int16Array(v),u.HEAP32=be=new Int32Array(v),u.HEAPU8=Ie=new Uint8Array(v),u.HEAPU16=new Uint16Array(v),u.HEAPU32=Ge=new Uint32Array(v),u.HEAPF32=new Float32Array(v),u.HEAPF64=$e=new Float64Array(v)}var ot=u.INITIAL_MEMORY||16777216;if(T)ue=u.wasmMemory,ie=u.buffer;else if(u.wasmMemory)ue=u.wasmMemory;else if(ue=new WebAssembly.Memory({initial:ot/65536,maximum:2147483648/65536,shared:!0}),!(ue.buffer instanceof SharedArrayBuffer))throw U("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),x&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");ue&&(ie=ue.buffer),ot=ie.byteLength,We(ie);var D,I=[],oe=[],ce=[],ke=[];T||oe.push({func:function(){Sd()}});function Pe(){if(!T){if(u.preRun)for(typeof u.preRun=="function"&&(u.preRun=[u.preRun]);u.preRun.length;)Se(u.preRun.shift());Dn(I)}}function $(){T||Dn(oe)}function de(){T||Dn(ce)}function le(){if(!T){if(u.postRun)for(typeof u.postRun=="function"&&(u.postRun=[u.postRun]);u.postRun.length;)ve(u.postRun.shift());Dn(ke)}}function Se(v){I.unshift(v)}function ve(v){ke.unshift(v)}var Ee=0,Ce=null;function qe(v){ge(!T,"addRunDependency cannot be used in a pthread worker"),Ee++,u.monitorRunDependencies&&u.monitorRunDependencies(Ee)}function _t(v){if(Ee--,u.monitorRunDependencies&&u.monitorRunDependencies(Ee),Ee==0&&Ce){var E=Ce;Ce=null,E()}}u.preloadedImages={},u.preloadedAudios={};function Je(v){u.onAbort&&u.onAbort(v),T&&console.error("Pthread aborting at "+new Error().stack),v+="",U(v),ee=!0,v="abort("+v+"). Build with -s ASSERTIONS=1 for more info.";var E=new WebAssembly.RuntimeError(v);throw d(E),E}function en(v,E){return String.prototype.startsWith?v.startsWith(E):v.indexOf(E)===0}var Gt="data:application/octet-stream;base64,";function Ds(v){return en(v,Gt)}var Ps="file://";function Qr(v){return en(v,Ps)}var St="tfjs-backend-wasm-threaded-simd.wasm";Ds(St)||(St=S(St));function es(v){try{if(v==St&&K)return new Uint8Array(K);if(O)return O(v);throw"both async and sync fetching of the wasm failed"}catch(E){Je(E)}}function Fs(){if(!K&&(g||y)){if(typeof fetch=="function"&&!Qr(St))return fetch(St,{credentials:"same-origin"}).then(function(v){if(!v.ok)throw"failed to load wasm binary file at '"+St+"'";return v.arrayBuffer()}).catch(function(){return es(St)});if(k)return new Promise(function(v,E){k(St,function(P){v(new Uint8Array(P))},E)})}return Promise.resolve().then(function(){return es(St)})}function Ji(){var v={a:p3};function E(_e,De){var at=_e.exports;if(u.asm=at,D=u.asm.I,Q=De,!T){var Pt=F.unusedWorkers.length;F.unusedWorkers.forEach(function(Ct){F.loadWasmModuleToWorker(Ct,function(){--Pt||_t()})})}}T||qe();function P(_e){E(_e.instance,_e.module)}function X(_e){return Fs().then(function(De){return WebAssembly.instantiate(De,v)}).then(_e,function(De){U("failed to asynchronously prepare wasm: "+De),Je(De)})}function xe(){return!K&&typeof WebAssembly.instantiateStreaming=="function"&&!Ds(St)&&!Qr(St)&&typeof fetch=="function"?fetch(St,{credentials:"same-origin"}).then(function(_e){var De=WebAssembly.instantiateStreaming(_e,v);return De.then(P,function(at){return U("wasm streaming compile failed: "+at),U("falling back to ArrayBuffer instantiation"),X(P)})}):X(P)}if(u.instantiateWasm)try{var ye=u.instantiateWasm(v,E);return ye}catch(_e){return U("Module.instantiateWasm callback failed with error: "+_e),!1}return xe().catch(d),{}}var Zn={10664:function(){throw"Canceled!"},10682:function(v,E){setTimeout(function(){Nd(v,E)},0)}};function Os(){F.initRuntime()}function Dn(v){for(;v.length>0;){var E=v.shift();if(typeof E=="function"){E(u);continue}var P=E.func;typeof P=="number"?E.arg===void 0?D.get(P)():D.get(P)(E.arg):P(E.arg===void 0?null:E.arg)}}var Sn={EPERM:63,ENOENT:44,ESRCH:71,EINTR:27,EIO:29,ENXIO:60,E2BIG:1,ENOEXEC:45,EBADF:8,ECHILD:12,EAGAIN:6,EWOULDBLOCK:6,ENOMEM:48,EACCES:2,EFAULT:21,ENOTBLK:105,EBUSY:10,EEXIST:20,EXDEV:75,ENODEV:43,ENOTDIR:54,EISDIR:31,EINVAL:28,ENFILE:41,EMFILE:33,ENOTTY:59,ETXTBSY:74,EFBIG:22,ENOSPC:51,ESPIPE:70,EROFS:69,EMLINK:34,EPIPE:64,EDOM:18,ERANGE:68,ENOMSG:49,EIDRM:24,ECHRNG:106,EL2NSYNC:156,EL3HLT:107,EL3RST:108,ELNRNG:109,EUNATCH:110,ENOCSI:111,EL2HLT:112,EDEADLK:16,ENOLCK:46,EBADE:113,EBADR:114,EXFULL:115,ENOANO:104,EBADRQC:103,EBADSLT:102,EDEADLOCK:16,EBFONT:101,ENOSTR:100,ENODATA:116,ETIME:117,ENOSR:118,ENONET:119,ENOPKG:120,EREMOTE:121,ENOLINK:47,EADV:122,ESRMNT:123,ECOMM:124,EPROTO:65,EMULTIHOP:36,EDOTDOT:125,EBADMSG:9,ENOTUNIQ:126,EBADFD:127,EREMCHG:128,ELIBACC:129,ELIBBAD:130,ELIBSCN:131,ELIBMAX:132,ELIBEXEC:133,ENOSYS:52,ENOTEMPTY:55,ENAMETOOLONG:37,ELOOP:32,EOPNOTSUPP:138,EPFNOSUPPORT:139,ECONNRESET:15,ENOBUFS:42,EAFNOSUPPORT:5,EPROTOTYPE:67,ENOTSOCK:57,ENOPROTOOPT:50,ESHUTDOWN:140,ECONNREFUSED:14,EADDRINUSE:3,ECONNABORTED:13,ENETUNREACH:40,ENETDOWN:38,ETIMEDOUT:73,EHOSTDOWN:142,EHOSTUNREACH:23,EINPROGRESS:26,EALREADY:7,EDESTADDRREQ:17,EMSGSIZE:35,EPROTONOSUPPORT:66,ESOCKTNOSUPPORT:137,EADDRNOTAVAIL:4,ENETRESET:39,EISCONN:30,ENOTCONN:53,ETOOMANYREFS:141,EUSERS:136,EDQUOT:19,ESTALE:72,ENOTSUP:138,ENOMEDIUM:148,EILSEQ:25,EOVERFLOW:61,ECANCELED:11,ENOTRECOVERABLE:56,EOWNERDEAD:62,ESTRPIPE:135};function yr(v,E){if(v<=0||v>i().length||v&!0||E<0)return-28;if(E==0)return 0;E>=2147483647&&(E=1/0);var P=Atomics.load(o(),Vs>>2),X=0;if(P==v){var xe=Atomics.compareExchange(o(),Vs>>2,P,0);if(xe==P&&(--E,X=1,E<=0))return 1}var ye=Atomics.notify(o(),v>>2,E);if(ye>=0)return ye+X;throw"Atomics.notify returned an unexpected value "+ye}u._emscripten_futex_wake=yr;function ts(v){if(T)throw"Internal Error! killThread() can only ever be called from main application thread!";if(!v)throw"Internal Error! Null pthread_ptr in killThread!";o()[v+12>>2]=0;var E=F.pthreads[v];E.worker.terminate(),F.freeThreadData(E),F.runningWorkers.splice(F.runningWorkers.indexOf(E.worker),1),E.worker.pthread=void 0}function _r(v){if(T)throw"Internal Error! cancelThread() can only ever be called from main application thread!";if(!v)throw"Internal Error! Null pthread_ptr in cancelThread!";var E=F.pthreads[v];E.worker.postMessage({cmd:"cancel"})}function N(v){if(T)throw"Internal Error! cleanupThread() can only ever be called from main application thread!";if(!v)throw"Internal Error! Null pthread_ptr in cleanupThread!";var E=F.pthreads[v];if(E){o()[v+12>>2]=0;var P=E.worker;F.returnWorkerToPool(P)}}var F={unusedWorkers:[],runningWorkers:[],initMainThreadBlock:function(){for(var v=8,E=0;E<v;++E)F.allocateUnusedWorker()},initRuntime:function(){for(var v=rs(228),E=0;E<228/4;++E)c()[v/4+E]=0;o()[v+12>>2]=v;var P=v+152;o()[P>>2]=P;for(var X=rs(512),E=0;E<128;++E)c()[X/4+E]=0;Atomics.store(c(),v+100>>2,X),Atomics.store(c(),v+40>>2,v),Rc(v,!y,1),Ad(v)},initWorker:function(){},pthreads:{},threadExitHandlers:[],setThreadStatus:function(){},runExitHandlers:function(){for(;F.threadExitHandlers.length>0;)F.threadExitHandlers.pop()();T&&xr()&&Md()},runExitHandlersAndDeinitThread:function(v,E){Atomics.store(c(),v+56>>2,1),Atomics.store(c(),v+60>>2,0),F.runExitHandlers(),Atomics.store(c(),v+4>>2,E),Atomics.store(c(),v+0>>2,1),yr(v+0,2147483647),Rc(0,0,0)},threadExit:function(v){var E=xr();E&&(F.runExitHandlersAndDeinitThread(E,v),T&&postMessage({cmd:"exit"}))},threadCancel:function(){F.runExitHandlersAndDeinitThread(xr(),-1),postMessage({cmd:"cancelDone"})},terminateAllThreads:function(){for(var v in F.pthreads){var E=F.pthreads[v];E&&E.worker&&F.returnWorkerToPool(E.worker)}F.pthreads={};for(var P=0;P<F.unusedWorkers.length;++P){var X=F.unusedWorkers[P];X.terminate()}F.unusedWorkers=[];for(var P=0;P<F.runningWorkers.length;++P){var X=F.runningWorkers[P],E=X.pthread;F.freeThreadData(E),X.terminate()}F.runningWorkers=[]},freeThreadData:function(v){if(!!v){if(v.threadInfoStruct){var E=o()[v.threadInfoStruct+100>>2];o()[v.threadInfoStruct+100>>2]=0,Zi(E),Zi(v.threadInfoStruct)}v.threadInfoStruct=0,v.allocatedOwnStack&&v.stackBase&&Zi(v.stackBase),v.stackBase=0,v.worker&&(v.worker.pthread=null)}},returnWorkerToPool:function(v){F.runWithoutMainThreadQueuedCalls(function(){delete F.pthreads[v.pthread.threadInfoStruct],F.unusedWorkers.push(v),F.runningWorkers.splice(F.runningWorkers.indexOf(v),1),F.freeThreadData(v.pthread),v.pthread=void 0})},runWithoutMainThreadQueuedCalls:function(v){o()[Dd>>2]=0;try{v()}finally{o()[Dd>>2]=1}},receiveObjectTransfer:function(v){},loadWasmModuleToWorker:function(v,E){v.onmessage=function(P){var X=P.data,xe=X.cmd;if(v.pthread&&(F.currentProxiedOperationCallerThread=v.pthread.threadInfoStruct),X.targetThread&&X.targetThread!=xr()){var ye=F.pthreads[X.targetThread];ye?ye.worker.postMessage(P.data,X.transferList):console.error('Internal error! Worker sent a message "'+xe+'" to target pthread '+X.targetThread+", but that thread no longer exists!"),F.currentProxiedOperationCallerThread=void 0;return}if(xe==="processQueuedMainThreadWork")to();else if(xe==="spawnThread")vd(P.data);else if(xe==="cleanupThread")N(X.thread);else if(xe==="killThread")ts(X.thread);else if(xe==="cancelThread")_r(X.thread);else if(xe==="loaded")v.loaded=!0,E&&E(v),v.runPthread&&(v.runPthread(),delete v.runPthread);else if(xe==="print")H("Thread "+X.threadId+": "+X.text);else if(xe==="printErr")U("Thread "+X.threadId+": "+X.text);else if(xe==="alert")alert("Thread "+X.threadId+": "+X.text);else if(xe==="exit"){var _e=v.pthread&&Atomics.load(c(),v.pthread.threadInfoStruct+64>>2);_e&&F.returnWorkerToPool(v)}else if(xe==="exitProcess")try{f3(X.returnCode)}catch(De){if(De instanceof ea)return;throw De}else xe==="cancelDone"?F.returnWorkerToPool(v):xe==="objectTransfer"?F.receiveObjectTransfer(P.data):P.data.target==="setimmediate"?v.postMessage(P.data):U("worker sent an unknown command "+xe);F.currentProxiedOperationCallerThread=void 0},v.onerror=function(P){U("pthread sent an error! "+P.filename+":"+P.lineno+": "+P.message)},x&&(v.on("message",function(P){v.onmessage({data:P})}),v.on("error",function(P){v.onerror(P)}),v.on("exit",function(P){})),v.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||n,wasmMemory:ue,wasmModule:Q})},allocateUnusedWorker:function(){var v=S("tfjs-backend-wasm-threaded-simd.worker.js");F.unusedWorkers.push(new Worker(v))},getNewWorker:function(){return F.unusedWorkers.length==0&&(F.allocateUnusedWorker(),F.loadWasmModuleToWorker(F.unusedWorkers[0])),F.unusedWorkers.length>0?F.unusedWorkers.pop():null},busySpinWait:function(v){for(var E=performance.now()+v;performance.now()<E;);}};function Z(v,E){Ld(v,E),zs(v)}u.establishStackSpace=Z;function J(){return se}u.getNoExitRuntime=J;function re(v,E){return D.get(v)(E)}u.invokeEntryPoint=re;function V(v,E,P,X){Je("Assertion failed: "+Ve(v)+", at: "+[E?Ve(E):"unknown filename",P,X?Ve(X):"unknown function"])}function q(v,E){_main(v,E)}var ne;x?ne=function(){var v=process.hrtime();return v[0]*1e3+v[1]/1e6}:T?ne=function(){return performance.now()-u.__performance_now_clock_drift}:typeof dateNow!="undefined"?ne=dateNow:ne=function(){return performance.now()};function we(v){return o()[Td()>>2]=v,v}function Ue(v,E){if(T)return Wt(1,1,v,E)}function Fe(v,E){if(v==E)postMessage({cmd:"processQueuedMainThreadWork"});else if(T)postMessage({targetThread:v,cmd:"processThreadQueue"});else{var P=F.pthreads[v],X=P&&P.worker;if(!X)return;X.postMessage({cmd:"processThreadQueue"})}return 1}function Ae(){Je()}function Oe(v,E,P){var X=xn(E,P);return Zn[v].apply(null,X)}function ft(v,E){}function Xe(v,E,P){if(v<=0||v>i().length||v&!0)return-28;if(g){if(Atomics.load(o(),v>>2)!=E)return-6;for(var xe=performance.now(),ye=xe+P,_e=Atomics.exchange(o(),Vs>>2,v);;){if(xe=performance.now(),xe>ye)return _e=Atomics.exchange(o(),Vs>>2,0),-73;if(_e=Atomics.exchange(o(),Vs>>2,0),_e==0)break;if(to(),Atomics.load(o(),v>>2)!=E)return-6;_e=Atomics.exchange(o(),Vs>>2,v)}return 0}else{var X=Atomics.wait(o(),v>>2,E,P);if(X==="timed-out")return-73;if(X==="not-equal")return-6;if(X==="ok")return 0;throw"Atomics.wait returned an unexpected value "+X}}function cn(v,E,P){a().copyWithin(v,E,E+P)}function ct(){return x?jn.cpus().length:navigator.hardwareConcurrency}function Wt(v,E){for(var P=arguments.length-2,X=Qi(),xe=P,ye=Us(xe*8),_e=ye>>3,De=0;De<P;De++){var at=arguments[2+De];l()[_e+De]=at}var Pt=Cd(v,xe,ye,E);return zs(X),Pt}var xt=[],jt=[];function xn(v,E){jt.length=0;var P;for(E>>=2;P=a()[v++];){var X=P<105;X&&E&1&&E++,jt.push(X?l()[E++>>1]:o()[E]),++E}return jt}function bt(v,E,P){xt.length=E;for(var X=P>>3,xe=0;xe<E;xe++)xt[xe]=l()[X+xe];var ye=v<0,_e=ye?Zn[-v-1]:d3[v];return _e.apply(null,xt)}function ns(){return a().length}function bn(v){try{return ue.grow(v-ie.byteLength+65535>>>16),We(ue.buffer),1}catch{}}function H2(v){var E=ns();if(v<=E)return!1;var P=2147483648;if(v>P)return!1;for(var X=1;X<=4;X*=2){var xe=E*(1+.2/X);xe=Math.min(xe,v+100663296);var ye=Math.min(P,te(Math.max(v,xe),65536)),_e=bn(ye);if(_e)return!0}return!1}var Ze={inEventHandler:0,removeAllEventListeners:function(){for(var v=Ze.eventHandlers.length-1;v>=0;--v)Ze._removeHandler(v);Ze.eventHandlers=[],Ze.deferredCalls=[]},registerRemoveEventListeners:function(){Ze.removeEventListenersRegistered||(Ze.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(v,E,P){function X(_e,De){if(_e.length!=De.length)return!1;for(var at in _e)if(_e[at]!=De[at])return!1;return!0}for(var xe in Ze.deferredCalls){var ye=Ze.deferredCalls[xe];if(ye.targetFunction==v&&X(ye.argsList,P))return}Ze.deferredCalls.push({targetFunction:v,precedence:E,argsList:P}),Ze.deferredCalls.sort(function(_e,De){return _e.precedence<De.precedence})},removeDeferredCalls:function(v){for(var E=0;E<Ze.deferredCalls.length;++E)Ze.deferredCalls[E].targetFunction==v&&(Ze.deferredCalls.splice(E,1),--E)},canPerformEventHandlerRequests:function(){return Ze.inEventHandler&&Ze.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(!!Ze.canPerformEventHandlerRequests())for(var v=0;v<Ze.deferredCalls.length;++v){var E=Ze.deferredCalls[v];Ze.deferredCalls.splice(v,1),--v,E.targetFunction.apply(null,E.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(v,E){for(var P=0;P<Ze.eventHandlers.length;++P)Ze.eventHandlers[P].target==v&&(!E||E==Ze.eventHandlers[P].eventTypeString)&&Ze._removeHandler(P--)},_removeHandler:function(v){var E=Ze.eventHandlers[v];E.target.removeEventListener(E.eventTypeString,E.eventListenerFunc,E.useCapture),Ze.eventHandlers.splice(v,1)},registerOrRemoveHandler:function(v){var E=function(xe){++Ze.inEventHandler,Ze.currentEventHandler=v,Ze.runDeferredCalls(),v.handlerFunc(xe),Ze.runDeferredCalls(),--Ze.inEventHandler};if(v.callbackfunc)v.eventListenerFunc=E,v.target.addEventListener(v.eventTypeString,E,v.useCapture),Ze.eventHandlers.push(v),Ze.registerRemoveEventListeners();else for(var P=0;P<Ze.eventHandlers.length;++P)Ze.eventHandlers[P].target==v.target&&Ze.eventHandlers[P].eventTypeString==v.eventTypeString&&Ze._removeHandler(P--)},queueEventHandlerOnThread_iiii:function(v,E,P,X,xe){var ye=Qi(),_e=Us(12);o()[_e>>2]=P,o()[_e+4>>2]=X,o()[_e+8>>2]=xe,Nc(0,v,637534208,E,X,_e),zs(ye)},getTargetThreadForEventCallback:function(v){switch(v){case 1:return 0;case 2:return F.currentProxiedOperationCallerThread;default:return v}},getNodeNameForTarget:function(v){return v?v==window?"#window":v==screen?"#screen":v&&v.nodeName?v.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function $2(v){var E=ze(v)+1,P=rs(E);return Re(v,P,E),P}function G2(v,E,P,X){var xe=Qi(),ye=Us(12),_e=0;E&&(_e=$2(E)),o()[ye>>2]=_e,o()[ye+4>>2]=P,o()[ye+8>>2]=X,Nc(0,v,657457152,0,_e,ye),zs(xe)}function W2(v,E,P,X){E=E?Ve(E):"",G2(v,E,P,X)}function j2(v){return v>2?Ve(v):v}var q2=[0,typeof document!="undefined"?document:0,typeof window!="undefined"?window:0];function K2(v){v=j2(v);var E=q2[v]||(typeof document!="undefined"?document.querySelector(v):void 0);return E}function Ic(v){return K2(v)}function gd(v,E,P){var X=Ic(v);if(!X)return-4;if(X.canvasSharedPtr&&(o()[X.canvasSharedPtr>>2]=E,o()[X.canvasSharedPtr+4>>2]=P),X.offscreenCanvas||!X.controlTransferredOffscreen){X.offscreenCanvas&&(X=X.offscreenCanvas);var xe=!1;if(X.GLctxObject&&X.GLctxObject.GLctx){var ye=X.GLctxObject.GLctx.getParameter(2978);xe=ye[0]===0&&ye[1]===0&&ye[2]===X.width&&ye[3]===X.height}X.width=E,X.height=P,xe&&X.GLctxObject.GLctx.viewport(0,0,E,P)}else if(X.canvasSharedPtr){var _e=o()[X.canvasSharedPtr+8>>2];return W2(_e,v,E,P),1}else return-4;return 0}function yd(v,E,P){return T?Wt(2,1,v,E,P):gd(v,E,P)}function X2(v,E,P){var X=Ic(v);return X?gd(v,E,P):yd(v,E,P)}function Y2(v){}function J2(v,E){}function Z2(v){var E=v.getExtension("ANGLE_instanced_arrays");if(E)return v.vertexAttribDivisor=function(P,X){E.vertexAttribDivisorANGLE(P,X)},v.drawArraysInstanced=function(P,X,xe,ye){E.drawArraysInstancedANGLE(P,X,xe,ye)},v.drawElementsInstanced=function(P,X,xe,ye,_e){E.drawElementsInstancedANGLE(P,X,xe,ye,_e)},1}function Q2(v){var E=v.getExtension("OES_vertex_array_object");if(E)return v.createVertexArray=function(){return E.createVertexArrayOES()},v.deleteVertexArray=function(P){E.deleteVertexArrayOES(P)},v.bindVertexArray=function(P){E.bindVertexArrayOES(P)},v.isVertexArray=function(P){return E.isVertexArrayOES(P)},1}function e3(v){var E=v.getExtension("WEBGL_draw_buffers");if(E)return v.drawBuffers=function(P,X){E.drawBuffersWEBGL(P,X)},1}function t3(v){return!!(v.multiDrawWebgl=v.getExtension("WEBGL_multi_draw"))}var ut={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],uniforms:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},timerQueriesEXT:[],programInfos:{},stringCache:{},unpackAlignment:4,recordError:function(E){ut.lastError||(ut.lastError=E)},getNewId:function(v){for(var E=ut.counter++,P=v.length;P<E;P++)v[P]=null;return E},getSource:function(v,E,P,X){for(var xe="",ye=0;ye<E;++ye){var _e=X?o()[X+ye*4>>2]:-1;xe+=Ve(o()[P+ye*4>>2],_e<0?void 0:_e)}return xe},createContext:function(v,E){var P=v.getContext("webgl",E);if(!P)return 0;var X=ut.registerContext(P,E);return X},registerContext:function(v,E){var P=rs(8);o()[P+4>>2]=xr();var X={handle:P,attributes:E,version:E.majorVersion,GLctx:v};return v.canvas&&(v.canvas.GLctxObject=X),ut.contexts[P]=X,(typeof E.enableExtensionsByDefault=="undefined"||E.enableExtensionsByDefault)&&ut.initExtensions(X),P},makeContextCurrent:function(v){return ut.currentContext=ut.contexts[v],u.ctx=Bs=ut.currentContext&&ut.currentContext.GLctx,!(v&&!Bs)},getContext:function(v){return ut.contexts[v]},deleteContext:function(v){ut.currentContext===ut.contexts[v]&&(ut.currentContext=null),typeof Ze=="object"&&Ze.removeAllHandlersOnTarget(ut.contexts[v].GLctx.canvas),ut.contexts[v]&&ut.contexts[v].GLctx.canvas&&(ut.contexts[v].GLctx.canvas.GLctxObject=void 0),Zi(ut.contexts[v].handle),ut.contexts[v]=null},initExtensions:function(v){if(v||(v=ut.currentContext),!v.initExtensionsDone){v.initExtensionsDone=!0;var E=v.GLctx;Z2(E),Q2(E),e3(E),E.disjointTimerQueryExt=E.getExtension("EXT_disjoint_timer_query"),t3(E);var P=E.getSupportedExtensions()||[];P.forEach(function(X){X.indexOf("lose_context")<0&&X.indexOf("debug")<0&&E.getExtension(X)})}},populateUniformTable:function(v){for(var E=ut.programs[v],P=ut.programInfos[v]={uniforms:{},maxUniformLength:0,maxAttributeLength:-1,maxUniformBlockNameLength:-1},X=P.uniforms,xe=Bs.getProgramParameter(E,35718),ye=0;ye<xe;++ye){var _e=Bs.getActiveUniform(E,ye),De=_e.name;P.maxUniformLength=Math.max(P.maxUniformLength,De.length+1),De.slice(-1)=="]"&&(De=De.slice(0,De.lastIndexOf("[")));var at=Bs.getUniformLocation(E,De);if(at){var Pt=ut.getNewId(ut.uniforms);X[De]=[_e.size,Pt],ut.uniforms[Pt]=at;for(var Ct=1;Ct<_e.size;++Ct){var br=De+"["+Ct+"]";at=Bs.getUniformLocation(E,br),Pt=ut.getNewId(ut.uniforms),ut.uniforms[Pt]=at}}}}},n3=["default","low-power","high-performance"];function r3(v,E){var P=E>>2,X=o()[P+(24>>2)],xe={alpha:!!o()[P+(0>>2)],depth:!!o()[P+(4>>2)],stencil:!!o()[P+(8>>2)],antialias:!!o()[P+(12>>2)],premultipliedAlpha:!!o()[P+(16>>2)],preserveDrawingBuffer:!!o()[P+(20>>2)],powerPreference:n3[X],failIfMajorPerformanceCaveat:!!o()[P+(28>>2)],majorVersion:o()[P+(32>>2)],minorVersion:o()[P+(36>>2)],enableExtensionsByDefault:o()[P+(40>>2)],explicitSwapControl:o()[P+(44>>2)],proxyContextToMainThread:o()[P+(48>>2)],renderViaOffscreenBackBuffer:o()[P+(52>>2)]},ye=Ic(v);if(!ye||xe.explicitSwapControl)return 0;var _e=ut.createContext(ye,xe);return _e}function s3(v,E){return r3(v,E)}var eo={mappings:{},buffers:[null,[],[]],printChar:function(v,E){var P=eo.buffers[v];E===0||E===10?((v===1?H:U)(ae(P,0)),P.length=0):P.push(E)},varargs:void 0,get:function(){eo.varargs+=4;var v=o()[eo.varargs-4>>2];return v},getStr:function(v){var E=Ve(v);return E},get64:function(v,E){return v}};function _d(v){return T?Wt(3,1,v):0}function xd(v,E,P,X,xe){if(T)return Wt(4,1,v,E,P,X,xe)}function bd(v,E,P,X){if(T)return Wt(5,1,v,E,P,X);for(var xe=0,ye=0;ye<P;ye++){for(var _e=o()[E+ye*8>>2],De=o()[E+(ye*8+4)>>2],at=0;at<De;at++)eo.printChar(v,a()[_e+at]);xe+=De}return o()[X>>2]=xe,0}function i3(v){var E=F.threadExitHandlers.pop();v&&E()}function a3(v,E){F.threadExitHandlers.push(function(){D.get(v)(E)})}function vd(v){if(T)throw"Internal Error! spawnThread() can only ever be called from main application thread!";var E=F.getNewWorker();if(E.pthread!==void 0)throw"Internal error!";if(!v.pthread_ptr)throw"Internal error, no pthread ptr!";F.runningWorkers.push(E);for(var P=rs(128*4),X=0;X<128;++X)o()[P+X*4>>2]=0;var xe=v.stackBase+v.stackSize,ye=F.pthreads[v.pthread_ptr]={worker:E,stackBase:v.stackBase,stackSize:v.stackSize,allocatedOwnStack:v.allocatedOwnStack,threadInfoStruct:v.pthread_ptr},_e=ye.threadInfoStruct>>2;Atomics.store(c(),_e+(64>>2),v.detached),Atomics.store(c(),_e+(100>>2),P),Atomics.store(c(),_e+(40>>2),ye.threadInfoStruct),Atomics.store(c(),_e+(80>>2),v.stackSize),Atomics.store(c(),_e+(76>>2),xe),Atomics.store(c(),_e+(104>>2),v.stackSize),Atomics.store(c(),_e+(104+8>>2),xe),Atomics.store(c(),_e+(104+12>>2),v.detached);var De=Ed(),at=De+40;Atomics.store(c(),_e+(172>>2),at),E.pthread=ye;var Pt={cmd:"run",start_routine:v.startRoutine,arg:v.arg,threadInfoStruct:v.pthread_ptr,stackBase:v.stackBase,stackSize:v.stackSize};E.runPthread=function(){Pt.time=performance.now(),E.postMessage(Pt,v.transferList)},E.loaded&&(E.runPthread(),delete E.runPthread)}function o3(v,E,P,X){if(typeof SharedArrayBuffer=="undefined")return U("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;if(!v)return U("pthread_create called with a null thread pointer!"),28;var xe=[],ye=0;if(T&&(xe.length===0||ye))return Rd(687865856,v,E,P,X);var _e=0,De=0,at=0;E&&E!=-1?(_e=o()[E>>2],_e+=81920,De=o()[E+8>>2],at=o()[E+12>>2]!==0):_e=2097152;var Pt=De==0;Pt?De=kd(16,_e):(De-=_e,ge(De>0));for(var Ct=rs(228),br=0;br<228>>2;++br)c()[(Ct>>2)+br]=0;o()[v>>2]=Ct,o()[Ct+12>>2]=Ct;var Hs=Ct+152;o()[Hs>>2]=Hs;var tn={stackBase:De,stackSize:_e,allocatedOwnStack:Pt,detached:at,startRoutine:P,pthread_ptr:Ct,arg:X,transferList:xe};return T?(tn.cmd="spawnThread",postMessage(tn,xe)):vd(tn),0}function c3(){if(!!T){var v=xr();if(!!v){var E=Atomics.load(c(),v+56>>2);if(!E){var P=Atomics.load(c(),v+0>>2);if(P==2)throw"Canceled!"}}}}function u3(){x||y||j("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function l3(v,E,P){if(!v)return U("pthread_join attempted on a null thread pointer!"),Sn.ESRCH;if(T&&xr()==v)return U("PThread "+v+" is attempting to join to itself!"),Sn.EDEADLK;if(!T&&Id()==v)return U("Main thread "+v+" is attempting to join to itself!"),Sn.EDEADLK;var X=o()[v+12>>2];if(X!==v)return U("pthread_join attempted on thread "+v+", which does not point to a valid thread, or does not exist anymore!"),Sn.ESRCH;var xe=Atomics.load(c(),v+64>>2);if(xe)return U("Attempted to join thread "+v+", which was already detached!"),Sn.EINVAL;for(P&&u3();;){var ye=Atomics.load(c(),v+0>>2);if(ye==1){var _e=Atomics.load(c(),v+4>>2);return E&&(o()[E>>2]=_e),Atomics.store(c(),v+64>>2,1),T?postMessage({cmd:"cleanupThread",thread:v}):N(v),0}if(!P)return Sn.EBUSY;c3(),T||to(),Xe(v+0,ye,T?100:1)}}function h3(v,E){return l3(v,E,!0)}function wd(v){if(T)return Wt(6,1,v);switch(v){case 30:return 16384;case 85:var E=2147483648;return E/16384;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:case 80:case 81:case 79:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return typeof navigator=="object"&&navigator.hardwareConcurrency||1}return we(28),-1}T||F.initMainThreadBlock();var Bs,d3=[null,Ue,yd,_d,xd,bd,wd],p3={e:V,r:q,x:Fe,b:Ae,y:Oe,j:ft,d:Xe,c:yr,f:ne,p:cn,A:ct,u:bt,q:H2,v:X2,i:Y2,s:J2,w:s3,l:_d,n:xd,g:bd,o:Os,a:ue||u.wasmMemory,z:i3,k:a3,h:o3,m:h3,t:wd};Ji();var Sd=u.___wasm_call_ctors=function(){return(Sd=u.___wasm_call_ctors=u.asm.B).apply(null,arguments)};u._init=function(){return(u._init=u.asm.C).apply(null,arguments)},u._init_with_threads_count=function(){return(u._init_with_threads_count=u.asm.D).apply(null,arguments)},u._get_threads_count=function(){return(u._get_threads_count=u.asm.E).apply(null,arguments)},u._register_tensor=function(){return(u._register_tensor=u.asm.F).apply(null,arguments)},u._dispose_data=function(){return(u._dispose_data=u.asm.G).apply(null,arguments)},u._dispose=function(){return(u._dispose=u.asm.H).apply(null,arguments)},u._Abs=function(){return(u._Abs=u.asm.J).apply(null,arguments)},u._Add=function(){return(u._Add=u.asm.K).apply(null,arguments)},u._AddN=function(){return(u._AddN=u.asm.L).apply(null,arguments)},u._All=function(){return(u._All=u.asm.M).apply(null,arguments)},u._Any=function(){return(u._Any=u.asm.N).apply(null,arguments)},u._ArgMax=function(){return(u._ArgMax=u.asm.O).apply(null,arguments)},u._AvgPool=function(){return(u._AvgPool=u.asm.P).apply(null,arguments)},u._BatchMatMul=function(){return(u._BatchMatMul=u.asm.Q).apply(null,arguments)},u._Ceil=function(){return(u._Ceil=u.asm.R).apply(null,arguments)},u._ClipByValue=function(){return(u._ClipByValue=u.asm.S).apply(null,arguments)},u._Conv2D=function(){return(u._Conv2D=u.asm.T).apply(null,arguments)},u._Conv2DBackpropInput=function(){return(u._Conv2DBackpropInput=u.asm.U).apply(null,arguments)},u._Cos=function(){return(u._Cos=u.asm.V).apply(null,arguments)},u._Cosh=function(){return(u._Cosh=u.asm.W).apply(null,arguments)},u._CropAndResize=function(){return(u._CropAndResize=u.asm.X).apply(null,arguments)},u._Cumsum=function(){return(u._Cumsum=u.asm.Y).apply(null,arguments)},u._DepthToSpace=function(){return(u._DepthToSpace=u.asm.Z).apply(null,arguments)},u._DepthwiseConv2dNative=function(){return(u._DepthwiseConv2dNative=u.asm._).apply(null,arguments)},u._Elu=function(){return(u._Elu=u.asm.$).apply(null,arguments)},u._Equal=function(){return(u._Equal=u.asm.aa).apply(null,arguments)},u._Exp=function(){return(u._Exp=u.asm.ba).apply(null,arguments)},u._FlipLeftRight=function(){return(u._FlipLeftRight=u.asm.ca).apply(null,arguments)},u._Floor=function(){return(u._Floor=u.asm.da).apply(null,arguments)},u._FloorDiv=function(){return(u._FloorDiv=u.asm.ea).apply(null,arguments)},u._FusedBatchNorm=function(){return(u._FusedBatchNorm=u.asm.fa).apply(null,arguments)},u._FusedConv2D=function(){return(u._FusedConv2D=u.asm.ga).apply(null,arguments)},u._FusedDepthwiseConv2D=function(){return(u._FusedDepthwiseConv2D=u.asm.ha).apply(null,arguments)},u._Gather=function(){return(u._Gather=u.asm.ia).apply(null,arguments)},u._GatherNd=function(){return(u._GatherNd=u.asm.ja).apply(null,arguments)},u._Greater=function(){return(u._Greater=u.asm.ka).apply(null,arguments)},u._GreaterEqual=function(){return(u._GreaterEqual=u.asm.la).apply(null,arguments)},u._LeakyRelu=function(){return(u._LeakyRelu=u.asm.ma).apply(null,arguments)},u._Less=function(){return(u._Less=u.asm.na).apply(null,arguments)},u._LessEqual=function(){return(u._LessEqual=u.asm.oa).apply(null,arguments)},u._Log=function(){return(u._Log=u.asm.pa).apply(null,arguments)},u._LogicalAnd=function(){return(u._LogicalAnd=u.asm.qa).apply(null,arguments)},u._Max=function(){return(u._Max=u.asm.ra).apply(null,arguments)},u._MaxPool=function(){return(u._MaxPool=u.asm.sa).apply(null,arguments)},u._Maximum=function(){return(u._Maximum=u.asm.ta).apply(null,arguments)},u._Mean=function(){return(u._Mean=u.asm.ua).apply(null,arguments)},u._Min=function(){return(u._Min=u.asm.va).apply(null,arguments)},u._Minimum=function(){return(u._Minimum=u.asm.wa).apply(null,arguments)},u._MirrorPad=function(){return(u._MirrorPad=u.asm.xa).apply(null,arguments)},u._Multiply=function(){return(u._Multiply=u.asm.ya).apply(null,arguments)},u._Neg=function(){return(u._Neg=u.asm.za).apply(null,arguments)},u._NonMaxSuppressionV3=function(){return(u._NonMaxSuppressionV3=u.asm.Aa).apply(null,arguments)},u._NonMaxSuppressionV4=function(){return(u._NonMaxSuppressionV4=u.asm.Ba).apply(null,arguments)},u._NonMaxSuppressionV5=function(){return(u._NonMaxSuppressionV5=u.asm.Ca).apply(null,arguments)},u._NotEqual=function(){return(u._NotEqual=u.asm.Da).apply(null,arguments)},u._OneHot=function(){return(u._OneHot=u.asm.Ea).apply(null,arguments)},u._PadV2=function(){return(u._PadV2=u.asm.Fa).apply(null,arguments)},u._Pow=function(){return(u._Pow=u.asm.Ga).apply(null,arguments)},u._Prelu=function(){return(u._Prelu=u.asm.Ha).apply(null,arguments)},u._Prod=function(){return(u._Prod=u.asm.Ia).apply(null,arguments)},u._RealDiv=function(){return(u._RealDiv=u.asm.Ja).apply(null,arguments)},u._Relu=function(){return(u._Relu=u.asm.Ka).apply(null,arguments)},u._Relu6=function(){return(u._Relu6=u.asm.La).apply(null,arguments)},u._ResizeBilinear=function(){return(u._ResizeBilinear=u.asm.Ma).apply(null,arguments)},u._Reverse=function(){return(u._Reverse=u.asm.Na).apply(null,arguments)},u._RotateWithOffset=function(){return(u._RotateWithOffset=u.asm.Oa).apply(null,arguments)},u._Round=function(){return(u._Round=u.asm.Pa).apply(null,arguments)},u._Rsqrt=function(){return(u._Rsqrt=u.asm.Qa).apply(null,arguments)},u._ScatterNd=function(){return(u._ScatterNd=u.asm.Ra).apply(null,arguments)},u._SelectV2=function(){return(u._SelectV2=u.asm.Sa).apply(null,arguments)},u._Sigmoid=function(){return(u._Sigmoid=u.asm.Ta).apply(null,arguments)},u._Sin=function(){return(u._Sin=u.asm.Ua).apply(null,arguments)},u._Softmax=function(){return(u._Softmax=u.asm.Va).apply(null,arguments)},u._SparseFillEmptyRows=function(){return(u._SparseFillEmptyRows=u.asm.Wa).apply(null,arguments)},u._SparseReshape=function(){return(u._SparseReshape=u.asm.Xa).apply(null,arguments)},u._SparseSegmentReduction=function(){return(u._SparseSegmentReduction=u.asm.Ya).apply(null,arguments)},u._Sqrt=function(){return(u._Sqrt=u.asm.Za).apply(null,arguments)},u._Square=function(){return(u._Square=u.asm._a).apply(null,arguments)},u._SquaredDifference=function(){return(u._SquaredDifference=u.asm.$a).apply(null,arguments)},u._Step=function(){return(u._Step=u.asm.ab).apply(null,arguments)},u._StridedSlice=function(){return(u._StridedSlice=u.asm.bb).apply(null,arguments)},u._Sub=function(){return(u._Sub=u.asm.cb).apply(null,arguments)},u._Sum=function(){return(u._Sum=u.asm.db).apply(null,arguments)},u._Tan=function(){return(u._Tan=u.asm.eb).apply(null,arguments)},u._Tanh=function(){return(u._Tanh=u.asm.fb).apply(null,arguments)},u._Tile=function(){return(u._Tile=u.asm.gb).apply(null,arguments)},u._TopK=function(){return(u._TopK=u.asm.hb).apply(null,arguments)},u._Transform=function(){return(u._Transform=u.asm.ib).apply(null,arguments)},u._Transpose=function(){return(u._Transpose=u.asm.jb).apply(null,arguments)},u.__FusedMatMul=function(){return(u.__FusedMatMul=u.asm.kb).apply(null,arguments)};var rs=u._malloc=function(){return(rs=u._malloc=u.asm.lb).apply(null,arguments)},Zi=u._free=function(){return(Zi=u._free=u.asm.mb).apply(null,arguments)},Td=u.___errno_location=function(){return(Td=u.___errno_location=u.asm.nb).apply(null,arguments)},Ed=u._emscripten_get_global_libc=function(){return(Ed=u._emscripten_get_global_libc=u.asm.ob).apply(null,arguments)},xr=u._pthread_self=function(){return(xr=u._pthread_self=u.asm.pb).apply(null,arguments)},Md=u.___pthread_tsd_run_dtors=function(){return(Md=u.___pthread_tsd_run_dtors=u.asm.qb).apply(null,arguments)},to=u._emscripten_main_thread_process_queued_calls=function(){return(to=u._emscripten_main_thread_process_queued_calls=u.asm.rb).apply(null,arguments)};u._emscripten_current_thread_process_queued_calls=function(){return(u._emscripten_current_thread_process_queued_calls=u.asm.sb).apply(null,arguments)};var Ad=u._emscripten_register_main_browser_thread_id=function(){return(Ad=u._emscripten_register_main_browser_thread_id=u.asm.tb).apply(null,arguments)},Id=u._emscripten_main_browser_thread_id=function(){return(Id=u._emscripten_main_browser_thread_id=u.asm.ub).apply(null,arguments)},Nd=u.__emscripten_do_dispatch_to_thread=function(){return(Nd=u.__emscripten_do_dispatch_to_thread=u.asm.vb).apply(null,arguments)},Rd=u._emscripten_sync_run_in_main_thread_4=function(){return(Rd=u._emscripten_sync_run_in_main_thread_4=u.asm.wb).apply(null,arguments)},Cd=u._emscripten_run_in_main_runtime_thread_js=function(){return(Cd=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},Nc=u.__emscripten_call_on_thread=function(){return(Nc=u.__emscripten_call_on_thread=u.asm.yb).apply(null,arguments)};u._emscripten_tls_init=function(){return(u._emscripten_tls_init=u.asm.zb).apply(null,arguments)};var Rc=u.__emscripten_thread_init=function(){return(Rc=u.__emscripten_thread_init=u.asm.Ab).apply(null,arguments)},Qi=u.stackSave=function(){return(Qi=u.stackSave=u.asm.Bb).apply(null,arguments)},zs=u.stackRestore=function(){return(zs=u.stackRestore=u.asm.Cb).apply(null,arguments)},Us=u.stackAlloc=function(){return(Us=u.stackAlloc=u.asm.Db).apply(null,arguments)},Ld=u._emscripten_stack_set_limits=function(){return(Ld=u._emscripten_stack_set_limits=u.asm.Eb).apply(null,arguments)},kd=u._memalign=function(){return(kd=u._memalign=u.asm.Fb).apply(null,arguments)},Dd=u.__emscripten_allow_main_runtime_queued_calls=10656,Vs=u.__emscripten_main_thread_futex=12292;u.cwrap=je,u.PThread=F,u.PThread=F,u.wasmMemory=ue,u.ExitStatus=ea;var no;function ea(v){this.name="ExitStatus",this.message="Program terminated with exit("+v+")",this.status=v}Ce=function v(){no||Cc(),no||(Ce=v)};function Cc(v){if(Ee>0)return;if(T){h(u),$(),postMessage({cmd:"loaded"});return}if(Pe(),Ee>0)return;function E(){no||(no=!0,u.calledRun=!0,!ee&&($(),de(),h(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),le()))}u.setStatus?(u.setStatus("Running..."),setTimeout(function(){setTimeout(function(){u.setStatus("")},1),E()},1)):E()}u.run=Cc;function f3(v,E){if(!(E&&se&&v===0)){if(!E&&T)throw postMessage({cmd:"exitProcess",returnCode:v}),new ea(v);se||(F.terminateAllThreads(),u.onExit&&u.onExit(v),ee=!0),_(v,new ea(v))}}if(u.preInit)for(typeof u.preInit=="function"&&(u.preInit=[u.preInit]);u.preInit.length>0;)u.preInit.pop()();T&&(se=!1,F.initWorker()),Cc();var ro;p&&(ro={uncaughtException:process.listeners("uncaughtException").filter(function(v){return!p.uncaughtException.indexOf(v)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(v){return!p.unhandledRejection.indexOf(v)>-1})});var so;if(typeof WasmBackendModule!="undefined")so=WasmBackendModule;else if(typeof s!="undefined")so=s;else throw new Error("Could not find wasm module in post.js");if(ro){var m3=so._dispose;so._dispose=function(){m3(),ro.uncaughtException.forEach(function(v){process.removeListener("uncaughtException",v)}),ro.unhandledRejection.forEach(function(v){process.removeListener("unhandledRejection",v)})}}return s.ready}}();r.exports=t})(Z0);var Q0=Z0.exports;const JT='var Module={};function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;this.alert=threadAlert;Module["instantiateWasm"]=function(info,receiveInstance){var instance=new WebAssembly.Instance(Module["wasmModule"],info);Module["wasmModule"]=null;receiveInstance(instance);return instance.exports};function moduleLoaded(){}this.onmessage=function(e){try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance;moduleLoaded()})}else if(e.data.cmd==="objectTransfer"){Module["PThread"].receiveObjectTransfer(e.data)}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0);var max=e.data.stackBase;var top=e.data.stackBase+e.data.stackSize;Module["establishStackSpace"](top,max);Module["_emscripten_tls_init"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].setThreadStatus(Module["_pthread_self"](),1);try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(!Module["getNoExitRuntime"]())Module["PThread"].threadExit(result)}catch(ex){if(ex==="Canceled!"){Module["PThread"].threadCancel()}else if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["getNoExitRuntime"]()){}else{Module["PThread"].threadExit(ex.status)}}else{Module["PThread"].threadExit(-2);throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["PThread"].threadCancel()}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);throw ex}};if(typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string"){self={location:{href:__filename}};var onmessage=this.onmessage;var nodeWorkerThreads=require("worker_threads");global.Worker=nodeWorkerThreads.Worker;var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var nodeFS=require("fs");var nodeRead=function(filename){return nodeFS.readFileSync(filename,"utf8")};function globalEval(x){global.require=require;global.Module=Module;eval.call(null,x)}importScripts=function(f){globalEval(nodeRead(f))};postMessage=function(msg){parentPort.postMessage(msg)};if(typeof performance==="undefined"){performance={now:function(){return Date.now()}}}}';var e1={exports:{}};(function(r,e){var t=function(){var n=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(n=n||__filename),function(s){s=s||{};var i=typeof s!="undefined"?s:{},a,o;i.ready=new Promise(function(V,q){a=V,o=q});var c;typeof process!="undefined"&&process.listeners&&(c={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var l={},u;for(u in i)i.hasOwnProperty(u)&&(l[u]=i[u]);var h=!1,d=!1,p=!1,f=!1;h=typeof window=="object",d=typeof importScripts=="function",p=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",f=!h&&!p&&!d;var m="";function _(V){return i.locateFile?i.locateFile(V,m):m+V}var g,y,x,w,T;p?(d?m=jn.dirname(m)+"/":m=__dirname+"/",g=function(q,ne){return w||(w=jn),T||(T=jn),q=T.normalize(q),w.readFileSync(q,ne?null:"utf8")},x=function(q){var ne=g(q,!0);return ne.buffer||(ne=new Uint8Array(ne)),A(ne.buffer),ne},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(V){if(!(V instanceof N))throw V}),process.on("unhandledRejection",I),i.inspect=function(){return"[Emscripten Module object]"}):f?(typeof read!="undefined"&&(g=function(q){return read(q)}),x=function(q){var ne;return typeof readbuffer=="function"?new Uint8Array(readbuffer(q)):(ne=read(q,"binary"),A(typeof ne=="object"),ne)},typeof scriptArgs!="undefined"&&scriptArgs,typeof print!="undefined"&&(typeof console=="undefined"&&(console={}),console.log=print,console.warn=console.error=typeof printErr!="undefined"?printErr:print)):(h||d)&&(d?m=self.location.href:typeof document!="undefined"&&document.currentScript&&(m=document.currentScript.src),n&&(m=n),m.indexOf("blob:")!==0?m=m.substr(0,m.lastIndexOf("/")+1):m="",g=function(V){var q=new XMLHttpRequest;return q.open("GET",V,!1),q.send(null),q.responseText},d&&(x=function(V){var q=new XMLHttpRequest;return q.open("GET",V,!1),q.responseType="arraybuffer",q.send(null),new Uint8Array(q.response)}),y=function(V,q,ne){var we=new XMLHttpRequest;we.open("GET",V,!0),we.responseType="arraybuffer",we.onload=function(){if(we.status==200||we.status==0&&we.response){q(we.response);return}ne()},we.onerror=ne,we.send(null)});var M=i.print||console.log.bind(console),S=i.printErr||console.warn.bind(console);for(u in l)l.hasOwnProperty(u)&&(i[u]=l[u]);l=null,i.arguments,i.thisProgram,i.quit;var R;i.wasmBinary&&(R=i.wasmBinary),i.noExitRuntime,typeof WebAssembly!="object"&&I("no native wasm support detected");var k,O=!1;function A(V,q){V||I("Assertion failed: "+q)}function Y(V){var q=i["_"+V];return A(q,"Cannot call unknown function "+V+", make sure it is exported"),q}function B(V,q,ne,we,Ue){var Fe={string:function(xt){var jt=0;if(xt!=null&&xt!==0){var xn=(xt.length<<2)+1;jt=ts(xn),ue(xt,jt,xn)}return jt},array:function(xt){var jt=ts(xt.length);return Q(xt,jt),jt}};function Ae(xt){return q==="string"?K(xt):q==="boolean"?Boolean(xt):xt}var Oe=Y(V),ft=[],Xe=0;if(we)for(var cn=0;cn<we.length;cn++){var ct=Fe[ne[cn]];ct?(Xe===0&&(Xe=Sn()),ft[cn]=ct(we[cn])):ft[cn]=we[cn]}var Wt=Oe.apply(null,ft);return Wt=Ae(Wt),Xe!==0&&yr(Xe),Wt}function H(V,q,ne,we){ne=ne||[];var Ue=ne.every(function(Ae){return Ae==="number"}),Fe=q!=="string";return Fe&&Ue&&!we?Y(V):function(){return B(V,q,ne,arguments)}}var U=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function j(V,q,ne){for(var we=q+ne,Ue=q;V[Ue]&&!(Ue>=we);)++Ue;if(Ue-q>16&&V.subarray&&U)return U.decode(V.subarray(q,Ue));for(var Fe="";q<Ue;){var Ae=V[q++];if(!(Ae&128)){Fe+=String.fromCharCode(Ae);continue}var Oe=V[q++]&63;if((Ae&224)==192){Fe+=String.fromCharCode((Ae&31)<<6|Oe);continue}var ft=V[q++]&63;if((Ae&240)==224?Ae=(Ae&15)<<12|Oe<<6|ft:Ae=(Ae&7)<<18|Oe<<12|ft<<6|V[q++]&63,Ae<65536)Fe+=String.fromCharCode(Ae);else{var Xe=Ae-65536;Fe+=String.fromCharCode(55296|Xe>>10,56320|Xe&1023)}}return Fe}function K(V,q){return V?j(Me,V,q):""}function se(V,q,ne,we){if(!(we>0))return 0;for(var Ue=ne,Fe=ne+we-1,Ae=0;Ae<V.length;++Ae){var Oe=V.charCodeAt(Ae);if(Oe>=55296&&Oe<=57343){var ft=V.charCodeAt(++Ae);Oe=65536+((Oe&1023)<<10)|ft&1023}if(Oe<=127){if(ne>=Fe)break;q[ne++]=Oe}else if(Oe<=2047){if(ne+1>=Fe)break;q[ne++]=192|Oe>>6,q[ne++]=128|Oe&63}else if(Oe<=65535){if(ne+2>=Fe)break;q[ne++]=224|Oe>>12,q[ne++]=128|Oe>>6&63,q[ne++]=128|Oe&63}else{if(ne+3>=Fe)break;q[ne++]=240|Oe>>18,q[ne++]=128|Oe>>12&63,q[ne++]=128|Oe>>6&63,q[ne++]=128|Oe&63}}return q[ne]=0,ne-Ue}function ue(V,q,ne){return se(V,Me,q,ne)}function Q(V,q){he.set(V,q)}function ee(V,q){return V%q>0&&(V+=q-V%q),V}var ge,he,Me,je;function ae(V){ge=V,i.HEAP8=he=new Int8Array(V),i.HEAP16=new Int16Array(V),i.HEAP32=je=new Int32Array(V),i.HEAPU8=Me=new Uint8Array(V),i.HEAPU16=new Uint16Array(V),i.HEAPU32=new Uint32Array(V),i.HEAPF32=new Float32Array(V),i.HEAPF64=new Float64Array(V)}i.INITIAL_MEMORY;var Ve,He=[],Re=[],ze=[],Ye=[];Re.push({func:function(){Os()}});function te(){if(i.preRun)for(typeof i.preRun=="function"&&(i.preRun=[i.preRun]);i.preRun.length;)be(i.preRun.shift());Ee(He)}function ie(){Ee(Re)}function me(){Ee(ze)}function Ie(){if(i.postRun)for(typeof i.postRun=="function"&&(i.postRun=[i.postRun]);i.postRun.length;)Ge(i.postRun.shift());Ee(Ye)}function be(V){He.unshift(V)}function Ge(V){Ye.unshift(V)}var $e=0,We=null;function ot(V){$e++,i.monitorRunDependencies&&i.monitorRunDependencies($e)}function D(V){if($e--,i.monitorRunDependencies&&i.monitorRunDependencies($e),$e==0&&We){var q=We;We=null,q()}}i.preloadedImages={},i.preloadedAudios={};function I(V){i.onAbort&&i.onAbort(V),V+="",S(V),O=!0,V="abort("+V+"). Build with -s ASSERTIONS=1 for more info.";var q=new WebAssembly.RuntimeError(V);throw o(q),q}function oe(V,q){return String.prototype.startsWith?V.startsWith(q):V.indexOf(q)===0}var ce="data:application/octet-stream;base64,";function ke(V){return oe(V,ce)}var Pe="file://";function $(V){return oe(V,Pe)}var de="tfjs-backend-wasm.wasm";ke(de)||(de=_(de));function le(V){try{if(V==de&&R)return new Uint8Array(R);if(x)return x(V);throw"both async and sync fetching of the wasm failed"}catch(q){I(q)}}function Se(){if(!R&&(h||d)){if(typeof fetch=="function"&&!$(de))return fetch(de,{credentials:"same-origin"}).then(function(V){if(!V.ok)throw"failed to load wasm binary file at '"+de+"'";return V.arrayBuffer()}).catch(function(){return le(de)});if(y)return new Promise(function(V,q){y(de,function(ne){V(new Uint8Array(ne))},q)})}return Promise.resolve().then(function(){return le(de)})}function ve(){var V={a:Zn};function q(Ae,Oe){var ft=Ae.exports;i.asm=ft,k=i.asm.j,ae(k.buffer),Ve=i.asm.r,D()}ot();function ne(Ae){q(Ae.instance)}function we(Ae){return Se().then(function(Oe){return WebAssembly.instantiate(Oe,V)}).then(Ae,function(Oe){S("failed to asynchronously prepare wasm: "+Oe),I(Oe)})}function Ue(){return!R&&typeof WebAssembly.instantiateStreaming=="function"&&!ke(de)&&!$(de)&&typeof fetch=="function"?fetch(de,{credentials:"same-origin"}).then(function(Ae){var Oe=WebAssembly.instantiateStreaming(Ae,V);return Oe.then(ne,function(ft){return S("wasm streaming compile failed: "+ft),S("falling back to ArrayBuffer instantiation"),we(ne)})}):we(ne)}if(i.instantiateWasm)try{var Fe=i.instantiateWasm(V,q);return Fe}catch(Ae){return S("Module.instantiateWasm callback failed with error: "+Ae),!1}return Ue().catch(o),{}}function Ee(V){for(;V.length>0;){var q=V.shift();if(typeof q=="function"){q(i);continue}var ne=q.func;typeof ne=="number"?q.arg===void 0?Ve.get(ne)():Ve.get(ne)(q.arg):ne(q.arg===void 0?null:q.arg)}}function Ce(){I()}function qe(V,q,ne){Me.copyWithin(V,q,q+ne)}function _t(){return Me.length}function Je(V){try{return k.grow(V-ge.byteLength+65535>>>16),ae(k.buffer),1}catch{}}function en(V){var q=_t(),ne=2147483648;if(V>ne)return!1;for(var we=1;we<=4;we*=2){var Ue=q*(1+.2/we);Ue=Math.min(Ue,V+100663296);var Fe=Math.min(ne,ee(Math.max(V,Ue),65536)),Ae=Je(Fe);if(Ae)return!0}return!1}var Gt={mappings:{},buffers:[null,[],[]],printChar:function(V,q){var ne=Gt.buffers[V];q===0||q===10?((V===1?M:S)(j(ne,0)),ne.length=0):ne.push(q)},varargs:void 0,get:function(){Gt.varargs+=4;var V=je[Gt.varargs-4>>2];return V},getStr:function(V){var q=K(V);return q},get64:function(V,q){return V}};function Ds(V){return 0}function Ps(V,q,ne,we,Ue){}function Qr(V,q,ne,we){for(var Ue=0,Fe=0;Fe<ne;Fe++){for(var Ae=je[q+Fe*8>>2],Oe=je[q+(Fe*8+4)>>2],ft=0;ft<Oe;ft++)Gt.printChar(V,Me[Ae+ft]);Ue+=Oe}return je[we>>2]=Ue,0}function St(){return 6}function es(){return 28}function Fs(V){return je[Dn()>>2]=V,V}function Ji(V){switch(V){case 30:return 16384;case 85:var q=2147483648;return q/16384;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:case 80:case 81:case 79:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return typeof navigator=="object"&&navigator.hardwareConcurrency||1}return Fs(28),-1}var Zn={a:Ce,d:qe,e:en,f:Ds,c:Ps,b:Qr,h:St,g:es,i:Ji};ve();var Os=i.___wasm_call_ctors=function(){return(Os=i.___wasm_call_ctors=i.asm.k).apply(null,arguments)};i._init=function(){return(i._init=i.asm.l).apply(null,arguments)},i._init_with_threads_count=function(){return(i._init_with_threads_count=i.asm.m).apply(null,arguments)},i._get_threads_count=function(){return(i._get_threads_count=i.asm.n).apply(null,arguments)},i._register_tensor=function(){return(i._register_tensor=i.asm.o).apply(null,arguments)},i._dispose_data=function(){return(i._dispose_data=i.asm.p).apply(null,arguments)},i._dispose=function(){return(i._dispose=i.asm.q).apply(null,arguments)},i._Abs=function(){return(i._Abs=i.asm.s).apply(null,arguments)},i._Add=function(){return(i._Add=i.asm.t).apply(null,arguments)},i._AddN=function(){return(i._AddN=i.asm.u).apply(null,arguments)},i._All=function(){return(i._All=i.asm.v).apply(null,arguments)},i._Any=function(){return(i._Any=i.asm.w).apply(null,arguments)},i._ArgMax=function(){return(i._ArgMax=i.asm.x).apply(null,arguments)},i._AvgPool=function(){return(i._AvgPool=i.asm.y).apply(null,arguments)},i._BatchMatMul=function(){return(i._BatchMatMul=i.asm.z).apply(null,arguments)},i._Ceil=function(){return(i._Ceil=i.asm.A).apply(null,arguments)},i._ClipByValue=function(){return(i._ClipByValue=i.asm.B).apply(null,arguments)},i._Conv2D=function(){return(i._Conv2D=i.asm.C).apply(null,arguments)},i._Conv2DBackpropInput=function(){return(i._Conv2DBackpropInput=i.asm.D).apply(null,arguments)},i._Cos=function(){return(i._Cos=i.asm.E).apply(null,arguments)},i._Cosh=function(){return(i._Cosh=i.asm.F).apply(null,arguments)},i._CropAndResize=function(){return(i._CropAndResize=i.asm.G).apply(null,arguments)},i._Cumsum=function(){return(i._Cumsum=i.asm.H).apply(null,arguments)},i._DepthToSpace=function(){return(i._DepthToSpace=i.asm.I).apply(null,arguments)},i._DepthwiseConv2dNative=function(){return(i._DepthwiseConv2dNative=i.asm.J).apply(null,arguments)},i._Elu=function(){return(i._Elu=i.asm.K).apply(null,arguments)},i._Equal=function(){return(i._Equal=i.asm.L).apply(null,arguments)},i._Exp=function(){return(i._Exp=i.asm.M).apply(null,arguments)},i._FlipLeftRight=function(){return(i._FlipLeftRight=i.asm.N).apply(null,arguments)},i._Floor=function(){return(i._Floor=i.asm.O).apply(null,arguments)},i._FloorDiv=function(){return(i._FloorDiv=i.asm.P).apply(null,arguments)},i._FusedBatchNorm=function(){return(i._FusedBatchNorm=i.asm.Q).apply(null,arguments)},i._FusedConv2D=function(){return(i._FusedConv2D=i.asm.R).apply(null,arguments)},i._FusedDepthwiseConv2D=function(){return(i._FusedDepthwiseConv2D=i.asm.S).apply(null,arguments)},i._Gather=function(){return(i._Gather=i.asm.T).apply(null,arguments)},i._GatherNd=function(){return(i._GatherNd=i.asm.U).apply(null,arguments)},i._Greater=function(){return(i._Greater=i.asm.V).apply(null,arguments)},i._GreaterEqual=function(){return(i._GreaterEqual=i.asm.W).apply(null,arguments)},i._LeakyRelu=function(){return(i._LeakyRelu=i.asm.X).apply(null,arguments)},i._Less=function(){return(i._Less=i.asm.Y).apply(null,arguments)},i._LessEqual=function(){return(i._LessEqual=i.asm.Z).apply(null,arguments)},i._Log=function(){return(i._Log=i.asm._).apply(null,arguments)},i._LogicalAnd=function(){return(i._LogicalAnd=i.asm.$).apply(null,arguments)},i._Max=function(){return(i._Max=i.asm.aa).apply(null,arguments)},i._MaxPool=function(){return(i._MaxPool=i.asm.ba).apply(null,arguments)},i._Maximum=function(){return(i._Maximum=i.asm.ca).apply(null,arguments)},i._Mean=function(){return(i._Mean=i.asm.da).apply(null,arguments)},i._Min=function(){return(i._Min=i.asm.ea).apply(null,arguments)},i._Minimum=function(){return(i._Minimum=i.asm.fa).apply(null,arguments)},i._MirrorPad=function(){return(i._MirrorPad=i.asm.ga).apply(null,arguments)},i._Multiply=function(){return(i._Multiply=i.asm.ha).apply(null,arguments)},i._Neg=function(){return(i._Neg=i.asm.ia).apply(null,arguments)},i._NonMaxSuppressionV3=function(){return(i._NonMaxSuppressionV3=i.asm.ja).apply(null,arguments)},i._NonMaxSuppressionV4=function(){return(i._NonMaxSuppressionV4=i.asm.ka).apply(null,arguments)},i._NonMaxSuppressionV5=function(){return(i._NonMaxSuppressionV5=i.asm.la).apply(null,arguments)},i._NotEqual=function(){return(i._NotEqual=i.asm.ma).apply(null,arguments)},i._OneHot=function(){return(i._OneHot=i.asm.na).apply(null,arguments)},i._PadV2=function(){return(i._PadV2=i.asm.oa).apply(null,arguments)},i._Pow=function(){return(i._Pow=i.asm.pa).apply(null,arguments)},i._Prelu=function(){return(i._Prelu=i.asm.qa).apply(null,arguments)},i._Prod=function(){return(i._Prod=i.asm.ra).apply(null,arguments)},i._RealDiv=function(){return(i._RealDiv=i.asm.sa).apply(null,arguments)},i._Relu=function(){return(i._Relu=i.asm.ta).apply(null,arguments)},i._Relu6=function(){return(i._Relu6=i.asm.ua).apply(null,arguments)},i._ResizeBilinear=function(){return(i._ResizeBilinear=i.asm.va).apply(null,arguments)},i._Reverse=function(){return(i._Reverse=i.asm.wa).apply(null,arguments)},i._RotateWithOffset=function(){return(i._RotateWithOffset=i.asm.xa).apply(null,arguments)},i._Round=function(){return(i._Round=i.asm.ya).apply(null,arguments)},i._Rsqrt=function(){return(i._Rsqrt=i.asm.za).apply(null,arguments)},i._ScatterNd=function(){return(i._ScatterNd=i.asm.Aa).apply(null,arguments)},i._SelectV2=function(){return(i._SelectV2=i.asm.Ba).apply(null,arguments)},i._Sigmoid=function(){return(i._Sigmoid=i.asm.Ca).apply(null,arguments)},i._Sin=function(){return(i._Sin=i.asm.Da).apply(null,arguments)},i._Softmax=function(){return(i._Softmax=i.asm.Ea).apply(null,arguments)},i._SparseFillEmptyRows=function(){return(i._SparseFillEmptyRows=i.asm.Fa).apply(null,arguments)},i._SparseReshape=function(){return(i._SparseReshape=i.asm.Ga).apply(null,arguments)},i._SparseSegmentReduction=function(){return(i._SparseSegmentReduction=i.asm.Ha).apply(null,arguments)},i._Sqrt=function(){return(i._Sqrt=i.asm.Ia).apply(null,arguments)},i._Square=function(){return(i._Square=i.asm.Ja).apply(null,arguments)},i._SquaredDifference=function(){return(i._SquaredDifference=i.asm.Ka).apply(null,arguments)},i._Step=function(){return(i._Step=i.asm.La).apply(null,arguments)},i._StridedSlice=function(){return(i._StridedSlice=i.asm.Ma).apply(null,arguments)},i._Sub=function(){return(i._Sub=i.asm.Na).apply(null,arguments)},i._Sum=function(){return(i._Sum=i.asm.Oa).apply(null,arguments)},i._Tan=function(){return(i._Tan=i.asm.Pa).apply(null,arguments)},i._Tanh=function(){return(i._Tanh=i.asm.Qa).apply(null,arguments)},i._Tile=function(){return(i._Tile=i.asm.Ra).apply(null,arguments)},i._TopK=function(){return(i._TopK=i.asm.Sa).apply(null,arguments)},i._Transform=function(){return(i._Transform=i.asm.Ta).apply(null,arguments)},i._Transpose=function(){return(i._Transpose=i.asm.Ua).apply(null,arguments)},i.__FusedMatMul=function(){return(i.__FusedMatMul=i.asm.Va).apply(null,arguments)},i._malloc=function(){return(i._malloc=i.asm.Wa).apply(null,arguments)},i._free=function(){return(i._free=i.asm.Xa).apply(null,arguments)};var Dn=i.___errno_location=function(){return(Dn=i.___errno_location=i.asm.Ya).apply(null,arguments)},Sn=i.stackSave=function(){return(Sn=i.stackSave=i.asm.Za).apply(null,arguments)},yr=i.stackRestore=function(){return(yr=i.stackRestore=i.asm._a).apply(null,arguments)},ts=i.stackAlloc=function(){return(ts=i.stackAlloc=i.asm.$a).apply(null,arguments)};i.cwrap=H;var _r;function N(V){this.name="ExitStatus",this.message="Program terminated with exit("+V+")",this.status=V}We=function V(){_r||F(),_r||(We=V)};function F(V){if($e>0||(te(),$e>0))return;function q(){_r||(_r=!0,i.calledRun=!0,!O&&(ie(),me(),a(i),i.onRuntimeInitialized&&i.onRuntimeInitialized(),Ie()))}i.setStatus?(i.setStatus("Running..."),setTimeout(function(){setTimeout(function(){i.setStatus("")},1),q()},1)):q()}if(i.run=F,i.preInit)for(typeof i.preInit=="function"&&(i.preInit=[i.preInit]);i.preInit.length>0;)i.preInit.pop()();F();var Z;c&&(Z={uncaughtException:process.listeners("uncaughtException").filter(function(V){return!c.uncaughtException.indexOf(V)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(V){return!c.unhandledRejection.indexOf(V)>-1})});var J;if(typeof s!="undefined")J=s;else if(typeof WasmBackendModuleThreadedSimd!="undefined")J=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(Z){var re=J._dispose;J._dispose=function(){re(),Z.uncaughtException.forEach(function(V){process.removeListener("uncaughtException",V)}),Z.unhandledRejection.forEach(function(V){process.removeListener("unhandledRejection",V)})}}return s.ready}}();r.exports=t})(e1);var ZT=e1.exports;/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QT extends $d{constructor(e){super();this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(r1),zl=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new C3(this,r9())}write(e,t,n){const s={id:this.dataIdNextNumber++};return this.move(s,e,t,n,1),s}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){const t=Ks();return e(),{kernelMs:Ks()-t}}move(e,t,n,s,i){const a=this.dataIdNextNumber++;if(s==="string"){const u=t;this.dataIdMap.set(e,{id:a,stringBytes:u,shape:n,dtype:s,memoryOffset:null,refCount:i});return}const o=Ne(n),c=o*co(s),l=this.wasm._malloc(c);this.dataIdMap.set(e,{id:a,memoryOffset:l,shape:n,dtype:s,refCount:i}),this.wasm.tfjs.registerTensor(a,o,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,c),l)}async read(e){return this.readSync(e)}readSync(e,t,n){const{memoryOffset:s,dtype:i,shape:a,stringBytes:o}=this.dataIdMap.get(e);if(i==="string")return(t==null||t===0)&&(n==null||n>=o.length)?o:o.slice(t,n);t=t||0,n=n||Ne(a);const c=co(i),l=this.wasm.HEAPU8.slice(s+t*c,s+n*c);return nE(l.buffer,i)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){const n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){const t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n){let s;if(n==null)s=this.write(null,e,t);else{const i=this.dataIdNextNumber++;s={id:i},this.dataIdMap.set(s,{id:i,memoryOffset:n,shape:e,dtype:t,refCount:1});const a=Ne(e);this.wasm.tfjs.registerTensor(i,a,n)}return{dataId:s,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){const s=this.wasm.HEAPU8.buffer,{memoryOffset:i}=this.dataIdMap.get(n),a=Ne(e);switch(t){case"float32":return new Float32Array(s,i,a);case"int32":return new Int32Array(s,i,a);case"bool":return new Uint8Array(s,i,a);default:throw new Error(`Unknown dtype ${t}`)}}}function eE(r){return(e,t)=>(Hy(r,{credentials:"same-origin"}).then(n=>{n.ok||e.env.a(`failed to load wasm binary file at '${r}'`),n.arrayBuffer().then(s=>{WebAssembly.instantiate(s,e).then(i=>{t(i.instance,i.module)})})}),{})}function t1(r,e,t){let n="tfjs-backend-wasm.wasm";return r&&e?n="tfjs-backend-wasm-threaded-simd.wasm":r&&(n="tfjs-backend-wasm-simd.wasm"),xa!=null&&xa[n]!=null?xa[n]:t+n}async function tE(){const[r,e]=await Promise.all([nt().getAsync("WASM_HAS_SIMD_SUPPORT"),nt().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((t,n)=>{const s={};s.locateFile=(o,c)=>{if(o.endsWith(".worker.js")){const l=JT,u=new Blob([l],{type:"application/javascript"});return URL.createObjectURL(u)}return o.endsWith(".wasm")?t1(r,e,_a!=null?_a:c):c+o},n1&&(s.instantiateWasm=eE(t1(r,e,_a!=null?_a:"")));let i=!1;s.onAbort=()=>{if(i||Lo)return;Lo=!0,n({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let a;e&&r&&sE==null?(s.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+Q0.toString()],{type:"text/javascript"}),a=Q0(s)):a=ZT(s),a.then(o=>{i=!0,Lo=!1;const c=null;o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",c,["number"]),dispose:o.cwrap("dispose",c,[])},t({wasm:o})})})}function nE(r,e){switch(e){case"float32":return new Float32Array(r);case"int32":return new Int32Array(r);case"bool":return new Uint8Array(r);default:throw new Error(`Unknown dtype ${e}`)}}const rE=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"];let sE=null,_a=null,xa={},Lo=!1,n1=!1;function iE(r,e=!1){if(Lo)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof r=="string")_a=r;else{xa=r;const t=rE.filter(n=>xa[n]==null);if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}n1=e}let r1=-1,zl=-1;function aE(r){r1=r}function oE(){if(zl===-1)throw new Error("WASM backend not initialized.");return zl}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cE=2;o9("wasm",async()=>{const{wasm:r}=await tE();return new QT(r)},cE);/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Ul="135",uE=0,s1=1,lE=2,i1=1,hE=2,ba=3,oi=0,zt=1,ys=2,a1=1,Dr=0,va=1,o1=2,c1=3,u1=4,dE=5,ci=100,pE=101,fE=102,l1=103,h1=104,mE=200,gE=201,yE=202,_E=203,d1=204,p1=205,xE=206,bE=207,vE=208,wE=209,SE=210,TE=0,EE=1,ME=2,Vl=3,AE=4,IE=5,NE=6,RE=7,ko=0,CE=1,LE=2,_s=0,kE=1,DE=2,PE=3,FE=4,OE=5,f1=300,wa=301,Sa=302,Hl=303,$l=304,Do=306,Gl=307,ui=1e3,mn=1001,Po=1002,Ut=1003,Wl=1004,jl=1005,gn=1006,m1=1007,li=1008,Pr=1009,BE=1010,zE=1011,Ta=1012,UE=1013,Fo=1014,ar=1015,hi=1016,VE=1017,HE=1018,$E=1019,di=1020,GE=1021,Fr=1022,sn=1023,WE=1024,jE=1025,qE=sn,xs=1026,pi=1027,KE=1028,XE=1029,YE=1030,JE=1031,ZE=1032,QE=1033,g1=33776,y1=33777,_1=33778,x1=33779,b1=35840,v1=35841,w1=35842,S1=35843,eM=36196,T1=37492,E1=37496,tM=37808,nM=37809,rM=37810,sM=37811,iM=37812,aM=37813,oM=37814,cM=37815,uM=37816,lM=37817,hM=37818,dM=37819,pM=37820,fM=37821,mM=36492,gM=37840,yM=37841,_M=37842,xM=37843,bM=37844,vM=37845,wM=37846,SM=37847,TM=37848,EM=37849,MM=37850,AM=37851,IM=37852,NM=37853,RM=2200,CM=2201,LM=2202,Ea=2300,fi=2301,ql=2302,mi=2400,gi=2401,Oo=2402,Kl=2500,M1=2501,kM=0,DM=1,A1=2,yn=3e3,Or=3001,Xl=3007,Yl=3002,I1=3004,N1=3005,R1=3006,PM=3200,FM=3201,bs=0,OM=1,Jl=7680,BM=519,Ma=35044,Bo=35048,C1="300 es";class vs{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const s=this._listeners[e];if(s!==void 0){const i=s.indexOf(t);i!==-1&&s.splice(i,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const n=this._listeners[e.type];if(n!==void 0){e.target=this;const s=n.slice(0);for(let i=0,a=s.length;i<a;i++)s[i].call(this,e);e.target=null}}}const Zt=[];for(let r=0;r<256;r++)Zt[r]=(r<16?"0":"")+r.toString(16);let zo=1234567;const Aa=Math.PI/180,Ia=180/Math.PI;function Nn(){const r=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(Zt[r&255]+Zt[r>>8&255]+Zt[r>>16&255]+Zt[r>>24&255]+"-"+Zt[e&255]+Zt[e>>8&255]+"-"+Zt[e>>16&15|64]+Zt[e>>24&255]+"-"+Zt[t&63|128]+Zt[t>>8&255]+"-"+Zt[t>>16&255]+Zt[t>>24&255]+Zt[n&255]+Zt[n>>8&255]+Zt[n>>16&255]+Zt[n>>24&255]).toUpperCase()}function _n(r,e,t){return Math.max(e,Math.min(t,r))}function Zl(r,e){return(r%e+e)%e}function zM(r,e,t,n,s){return n+(r-e)*(s-n)/(t-e)}function UM(r,e,t){return r!==e?(t-r)/(e-r):0}function Na(r,e,t){return(1-t)*r+t*e}function VM(r,e,t,n){return Na(r,e,1-Math.exp(-t*n))}function HM(r,e=1){return e-Math.abs(Zl(r,e*2)-e)}function $M(r,e,t){return r<=e?0:r>=t?1:(r=(r-e)/(t-e),r*r*(3-2*r))}function GM(r,e,t){return r<=e?0:r>=t?1:(r=(r-e)/(t-e),r*r*r*(r*(r*6-15)+10))}function WM(r,e){return r+Math.floor(Math.random()*(e-r+1))}function jM(r,e){return r+Math.random()*(e-r)}function qM(r){return r*(.5-Math.random())}function KM(r){return r!==void 0&&(zo=r%2147483647),zo=zo*16807%2147483647,(zo-1)/2147483646}function XM(r){return r*Aa}function YM(r){return r*Ia}function Ql(r){return(r&r-1)==0&&r!==0}function L1(r){return Math.pow(2,Math.ceil(Math.log(r)/Math.LN2))}function k1(r){return Math.pow(2,Math.floor(Math.log(r)/Math.LN2))}function JM(r,e,t,n,s){const i=Math.cos,a=Math.sin,o=i(t/2),c=a(t/2),l=i((e+n)/2),u=a((e+n)/2),h=i((e-n)/2),d=a((e-n)/2),p=i((n-e)/2),f=a((n-e)/2);switch(s){case"XYX":r.set(o*u,c*h,c*d,o*l);break;case"YZY":r.set(c*d,o*u,c*h,o*l);break;case"ZXZ":r.set(c*h,c*d,o*u,o*l);break;case"XZX":r.set(o*u,c*f,c*p,o*l);break;case"YXY":r.set(c*p,o*u,c*f,o*l);break;case"ZYZ":r.set(c*f,c*p,o*u,o*l);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+s)}}var ZM=Object.freeze({__proto__:null,DEG2RAD:Aa,RAD2DEG:Ia,generateUUID:Nn,clamp:_n,euclideanModulo:Zl,mapLinear:zM,inverseLerp:UM,lerp:Na,damp:VM,pingpong:HM,smoothstep:$M,smootherstep:GM,randInt:WM,randFloat:jM,randFloatSpread:qM,seededRandom:KM,degToRad:XM,radToDeg:YM,isPowerOfTwo:Ql,ceilPowerOfTwo:L1,floorPowerOfTwo:k1,setQuaternionFromProperEuler:JM});class fe{constructor(e=0,t=0){this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,s=e.elements;return this.x=s[0]*t+s[3]*n+s[6],this.y=s[1]*t+s[4]*n+s[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),s=Math.sin(t),i=this.x-e.x,a=this.y-e.y;return this.x=i*n-a*s+e.x,this.y=i*s+a*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}fe.prototype.isVector2=!0;class Qt{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,s,i,a,o,c,l){const u=this.elements;return u[0]=e,u[1]=s,u[2]=o,u[3]=t,u[4]=i,u[5]=c,u[6]=n,u[7]=a,u[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,s=t.elements,i=this.elements,a=n[0],o=n[3],c=n[6],l=n[1],u=n[4],h=n[7],d=n[2],p=n[5],f=n[8],m=s[0],_=s[3],g=s[6],y=s[1],x=s[4],w=s[7],T=s[2],M=s[5],S=s[8];return i[0]=a*m+o*y+c*T,i[3]=a*_+o*x+c*M,i[6]=a*g+o*w+c*S,i[1]=l*m+u*y+h*T,i[4]=l*_+u*x+h*M,i[7]=l*g+u*w+h*S,i[2]=d*m+p*y+f*T,i[5]=d*_+p*x+f*M,i[8]=d*g+p*w+f*S,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],s=e[2],i=e[3],a=e[4],o=e[5],c=e[6],l=e[7],u=e[8];return t*a*u-t*o*l-n*i*u+n*o*c+s*i*l-s*a*c}invert(){const e=this.elements,t=e[0],n=e[1],s=e[2],i=e[3],a=e[4],o=e[5],c=e[6],l=e[7],u=e[8],h=u*a-o*l,d=o*c-u*i,p=l*i-a*c,f=t*h+n*d+s*p;if(f===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/f;return e[0]=h*m,e[1]=(s*l-u*n)*m,e[2]=(o*n-s*a)*m,e[3]=d*m,e[4]=(u*t-s*c)*m,e[5]=(s*i-o*t)*m,e[6]=p*m,e[7]=(n*c-l*t)*m,e[8]=(a*t-n*i)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,s,i,a,o){const c=Math.cos(i),l=Math.sin(i);return this.set(n*c,n*l,-n*(c*a+l*o)+a+e,-s*l,s*c,-s*(-l*a+c*o)+o+t,0,0,1),this}scale(e,t){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=t,n[4]*=t,n[7]*=t,this}rotate(e){const t=Math.cos(e),n=Math.sin(e),s=this.elements,i=s[0],a=s[3],o=s[6],c=s[1],l=s[4],u=s[7];return s[0]=t*i+n*c,s[3]=t*a+n*l,s[6]=t*o+n*u,s[1]=-n*i+t*c,s[4]=-n*a+t*l,s[7]=-n*o+t*u,this}translate(e,t){const n=this.elements;return n[0]+=e*n[2],n[3]+=e*n[5],n[6]+=e*n[8],n[1]+=t*n[2],n[4]+=t*n[5],n[7]+=t*n[8],this}equals(e){const t=this.elements,n=e.elements;for(let s=0;s<9;s++)if(t[s]!==n[s])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}}Qt.prototype.isMatrix3=!0;function D1(r){if(r.length===0)return-1/0;let e=r[0];for(let t=1,n=r.length;t<n;++t)r[t]>e&&(e=r[t]);return e}function Uo(r){return document.createElementNS("http://www.w3.org/1999/xhtml",r)}function P1(r,e=0){let t=3735928559^e,n=1103547991^e;for(let s=0,i;s<r.length;s++)i=r.charCodeAt(s),t=Math.imul(t^i,2654435761),n=Math.imul(n^i,1597334677);return t=Math.imul(t^t>>>16,2246822507)^Math.imul(n^n>>>13,3266489909),n=Math.imul(n^n>>>16,2246822507)^Math.imul(t^t>>>13,3266489909),4294967296*(2097151&n)+(t>>>0)}let yi;class _i{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement=="undefined")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{yi===void 0&&(yi=Uo("canvas")),yi.width=e.width,yi.height=e.height;const n=yi.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=yi}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}}let QM=0;class Vt extends vs{constructor(e=Vt.DEFAULT_IMAGE,t=Vt.DEFAULT_MAPPING,n=mn,s=mn,i=gn,a=li,o=sn,c=Pr,l=1,u=yn){super();Object.defineProperty(this,"id",{value:QM++}),this.uuid=Nn(),this.name="",this.image=e,this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=s,this.magFilter=i,this.minFilter=a,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=c,this.offset=new fe(0,0),this.repeat=new fe(1,1),this.center=new fe(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Qt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const s=this.image;if(s.uuid===void 0&&(s.uuid=Nn()),!t&&e.images[s.uuid]===void 0){let i;if(Array.isArray(s)){i=[];for(let a=0,o=s.length;a<o;a++)s[a].isDataTexture?i.push(eh(s[a].image)):i.push(eh(s[a]))}else i=eh(s);e.images[s.uuid]={uuid:s.uuid,url:i}}n.image=s.uuid}return JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==f1)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case ui:e.x=e.x-Math.floor(e.x);break;case mn:e.x=e.x<0?0:1;break;case Po:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case ui:e.y=e.y-Math.floor(e.y);break;case mn:e.y=e.y<0?0:1;break;case Po:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&this.version++}}Vt.DEFAULT_IMAGE=void 0;Vt.DEFAULT_MAPPING=f1;Vt.prototype.isTexture=!0;function eh(r){return typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&r instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&r instanceof ImageBitmap?_i.getDataURL(r):r.data?{data:Array.prototype.slice.call(r.data),width:r.width,height:r.height,type:r.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class pt{constructor(e=0,t=0,n=0,s=1){this.x=e,this.y=t,this.z=n,this.w=s}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,s){return this.x=e,this.y=t,this.z=n,this.w=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,s=this.z,i=this.w,a=e.elements;return this.x=a[0]*t+a[4]*n+a[8]*s+a[12]*i,this.y=a[1]*t+a[5]*n+a[9]*s+a[13]*i,this.z=a[2]*t+a[6]*n+a[10]*s+a[14]*i,this.w=a[3]*t+a[7]*n+a[11]*s+a[15]*i,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,s,i;const a=.01,o=.1,c=e.elements,l=c[0],u=c[4],h=c[8],d=c[1],p=c[5],f=c[9],m=c[2],_=c[6],g=c[10];if(Math.abs(u-d)<a&&Math.abs(h-m)<a&&Math.abs(f-_)<a){if(Math.abs(u+d)<o&&Math.abs(h+m)<o&&Math.abs(f+_)<o&&Math.abs(l+p+g-3)<o)return this.set(1,0,0,0),this;t=Math.PI;const x=(l+1)/2,w=(p+1)/2,T=(g+1)/2,M=(u+d)/4,S=(h+m)/4,R=(f+_)/4;return x>w&&x>T?x<a?(n=0,s=.707106781,i=.707106781):(n=Math.sqrt(x),s=M/n,i=S/n):w>T?w<a?(n=.707106781,s=0,i=.707106781):(s=Math.sqrt(w),n=M/s,i=R/s):T<a?(n=.707106781,s=.707106781,i=0):(i=Math.sqrt(T),n=S/i,s=R/i),this.set(n,s,i,t),this}let y=Math.sqrt((_-f)*(_-f)+(h-m)*(h-m)+(d-u)*(d-u));return Math.abs(y)<.001&&(y=1),this.x=(_-f)/y,this.y=(h-m)/y,this.z=(d-u)/y,this.w=Math.acos((l+p+g-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}pt.prototype.isVector4=!0;class Rn extends vs{constructor(e,t,n={}){super();this.width=e,this.height=t,this.depth=1,this.scissor=new pt(0,0,e,t),this.scissorTest=!1,this.viewport=new pt(0,0,e,t),this.texture=new Vt(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:e,height:t,depth:1},this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.internalFormat=n.internalFormat!==void 0?n.internalFormat:null,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:gn,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null}setTexture(e){e.image={width:this.width,height:this.height,depth:this.depth},this.texture=e}setSize(e,t,n=1){(this.width!==e||this.height!==t||this.depth!==n)&&(this.width=e,this.height=t,this.depth=n,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=n,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.image=Bd({},this.texture.image),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}Rn.prototype.isWebGLRenderTarget=!0;class eA extends Rn{constructor(e,t,n){super(e,t);const s=this.texture;this.texture=[];for(let i=0;i<n;i++)this.texture[i]=s.clone()}setSize(e,t,n=1){if(this.width!==e||this.height!==t||this.depth!==n){this.width=e,this.height=t,this.depth=n;for(let s=0,i=this.texture.length;s<i;s++)this.texture[s].image.width=e,this.texture[s].image.height=t,this.texture[s].image.depth=n;this.dispose()}return this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t),this}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this.texture.length=0;for(let t=0,n=e.texture.length;t<n;t++)this.texture[t]=e.texture[t].clone();return this}}eA.prototype.isWebGLMultipleRenderTargets=!0;class th extends Rn{constructor(e,t,n={}){super(e,t,n);this.samples=4,this.ignoreDepthForMultisampleCopy=n.ignoreDepth!==void 0?n.ignoreDepth:!0,this.useRenderToTexture=n.useRenderToTexture!==void 0?n.useRenderToTexture:!1,this.useRenderbuffer=this.useRenderToTexture===!1}copy(e){return super.copy.call(this,e),this.samples=e.samples,this.useRenderToTexture=e.useRenderToTexture,this.useRenderbuffer=e.useRenderbuffer,this}}th.prototype.isWebGLMultisampleRenderTarget=!0;class hn{constructor(e=0,t=0,n=0,s=1){this._x=e,this._y=t,this._z=n,this._w=s}static slerp(e,t,n,s){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),n.slerpQuaternions(e,t,s)}static slerpFlat(e,t,n,s,i,a,o){let c=n[s+0],l=n[s+1],u=n[s+2],h=n[s+3];const d=i[a+0],p=i[a+1],f=i[a+2],m=i[a+3];if(o===0){e[t+0]=c,e[t+1]=l,e[t+2]=u,e[t+3]=h;return}if(o===1){e[t+0]=d,e[t+1]=p,e[t+2]=f,e[t+3]=m;return}if(h!==m||c!==d||l!==p||u!==f){let _=1-o;const g=c*d+l*p+u*f+h*m,y=g>=0?1:-1,x=1-g*g;if(x>Number.EPSILON){const T=Math.sqrt(x),M=Math.atan2(T,g*y);_=Math.sin(_*M)/T,o=Math.sin(o*M)/T}const w=o*y;if(c=c*_+d*w,l=l*_+p*w,u=u*_+f*w,h=h*_+m*w,_===1-o){const T=1/Math.sqrt(c*c+l*l+u*u+h*h);c*=T,l*=T,u*=T,h*=T}}e[t]=c,e[t+1]=l,e[t+2]=u,e[t+3]=h}static multiplyQuaternionsFlat(e,t,n,s,i,a){const o=n[s],c=n[s+1],l=n[s+2],u=n[s+3],h=i[a],d=i[a+1],p=i[a+2],f=i[a+3];return e[t]=o*f+u*h+c*p-l*d,e[t+1]=c*f+u*d+l*h-o*p,e[t+2]=l*f+u*p+o*d-c*h,e[t+3]=u*f-o*h-c*d-l*p,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,s){return this._x=e,this._y=t,this._z=n,this._w=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const n=e._x,s=e._y,i=e._z,a=e._order,o=Math.cos,c=Math.sin,l=o(n/2),u=o(s/2),h=o(i/2),d=c(n/2),p=c(s/2),f=c(i/2);switch(a){case"XYZ":this._x=d*u*h+l*p*f,this._y=l*p*h-d*u*f,this._z=l*u*f+d*p*h,this._w=l*u*h-d*p*f;break;case"YXZ":this._x=d*u*h+l*p*f,this._y=l*p*h-d*u*f,this._z=l*u*f-d*p*h,this._w=l*u*h+d*p*f;break;case"ZXY":this._x=d*u*h-l*p*f,this._y=l*p*h+d*u*f,this._z=l*u*f+d*p*h,this._w=l*u*h-d*p*f;break;case"ZYX":this._x=d*u*h-l*p*f,this._y=l*p*h+d*u*f,this._z=l*u*f-d*p*h,this._w=l*u*h+d*p*f;break;case"YZX":this._x=d*u*h+l*p*f,this._y=l*p*h+d*u*f,this._z=l*u*f-d*p*h,this._w=l*u*h-d*p*f;break;case"XZY":this._x=d*u*h-l*p*f,this._y=l*p*h-d*u*f,this._z=l*u*f+d*p*h,this._w=l*u*h+d*p*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,s=Math.sin(n);return this._x=e.x*s,this._y=e.y*s,this._z=e.z*s,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],s=t[4],i=t[8],a=t[1],o=t[5],c=t[9],l=t[2],u=t[6],h=t[10],d=n+o+h;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(u-c)*p,this._y=(i-l)*p,this._z=(a-s)*p}else if(n>o&&n>h){const p=2*Math.sqrt(1+n-o-h);this._w=(u-c)/p,this._x=.25*p,this._y=(s+a)/p,this._z=(i+l)/p}else if(o>h){const p=2*Math.sqrt(1+o-n-h);this._w=(i-l)/p,this._x=(s+a)/p,this._y=.25*p,this._z=(c+u)/p}else{const p=2*Math.sqrt(1+h-n-o);this._w=(a-s)/p,this._x=(i+l)/p,this._y=(c+u)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(_n(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(n===0)return this;const s=Math.min(1,t/n);return this.slerp(e,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,s=e._y,i=e._z,a=e._w,o=t._x,c=t._y,l=t._z,u=t._w;return this._x=n*u+a*o+s*l-i*c,this._y=s*u+a*c+i*o-n*l,this._z=i*u+a*l+n*c-s*o,this._w=a*u-n*o-s*c-i*l,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const n=this._x,s=this._y,i=this._z,a=this._w;let o=a*e._w+n*e._x+s*e._y+i*e._z;if(o<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,o=-o):this.copy(e),o>=1)return this._w=a,this._x=n,this._y=s,this._z=i,this;const c=1-o*o;if(c<=Number.EPSILON){const p=1-t;return this._w=p*a+t*this._w,this._x=p*n+t*this._x,this._y=p*s+t*this._y,this._z=p*i+t*this._z,this.normalize(),this._onChangeCallback(),this}const l=Math.sqrt(c),u=Math.atan2(l,o),h=Math.sin((1-t)*u)/l,d=Math.sin(t*u)/l;return this._w=a*h+this._w*d,this._x=n*h+this._x*d,this._y=s*h+this._y*d,this._z=i*h+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,n){this.copy(e).slerp(t,n)}random(){const e=Math.random(),t=Math.sqrt(1-e),n=Math.sqrt(e),s=2*Math.PI*Math.random(),i=2*Math.PI*Math.random();return this.set(t*Math.cos(s),n*Math.sin(i),n*Math.cos(i),t*Math.sin(s))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}hn.prototype.isQuaternion=!0;class L{constructor(e=0,t=0,n=0){this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(F1.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(F1.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,s=this.z,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6]*s,this.y=i[1]*t+i[4]*n+i[7]*s,this.z=i[2]*t+i[5]*n+i[8]*s,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,s=this.z,i=e.elements,a=1/(i[3]*t+i[7]*n+i[11]*s+i[15]);return this.x=(i[0]*t+i[4]*n+i[8]*s+i[12])*a,this.y=(i[1]*t+i[5]*n+i[9]*s+i[13])*a,this.z=(i[2]*t+i[6]*n+i[10]*s+i[14])*a,this}applyQuaternion(e){const t=this.x,n=this.y,s=this.z,i=e.x,a=e.y,o=e.z,c=e.w,l=c*t+a*s-o*n,u=c*n+o*t-i*s,h=c*s+i*n-a*t,d=-i*t-a*n-o*s;return this.x=l*c+d*-i+u*-o-h*-a,this.y=u*c+d*-a+h*-i-l*-o,this.z=h*c+d*-o+l*-a-u*-i,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,s=this.z,i=e.elements;return this.x=i[0]*t+i[4]*n+i[8]*s,this.y=i[1]*t+i[5]*n+i[9]*s,this.z=i[2]*t+i[6]*n+i[10]*s,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,s=e.y,i=e.z,a=t.x,o=t.y,c=t.z;return this.x=s*c-i*o,this.y=i*a-n*c,this.z=n*o-s*a,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return nh.copy(this).projectOnVector(e),this.sub(nh)}reflect(e){return this.sub(nh.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(_n(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,s=this.z-e.z;return t*t+n*n+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const s=Math.sin(t)*e;return this.x=s*Math.sin(n),this.y=Math.cos(t)*e,this.z=s*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),s=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=s,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,n){return n!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,n=Math.sqrt(1-e**2);return this.x=n*Math.cos(t),this.y=n*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}L.prototype.isVector3=!0;const nh=new L,F1=new hn;class Cn{constructor(e=new L(1/0,1/0,1/0),t=new L(-1/0,-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,n=1/0,s=1/0,i=-1/0,a=-1/0,o=-1/0;for(let c=0,l=e.length;c<l;c+=3){const u=e[c],h=e[c+1],d=e[c+2];u<t&&(t=u),h<n&&(n=h),d<s&&(s=d),u>i&&(i=u),h>a&&(a=h),d>o&&(o=d)}return this.min.set(t,n,s),this.max.set(i,a,o),this}setFromBufferAttribute(e){let t=1/0,n=1/0,s=1/0,i=-1/0,a=-1/0,o=-1/0;for(let c=0,l=e.count;c<l;c++){const u=e.getX(c),h=e.getY(c),d=e.getZ(c);u<t&&(t=u),h<n&&(n=h),d<s&&(s=d),u>i&&(i=u),h>a&&(a=h),d>o&&(o=d)}return this.min.set(t,n,s),this.max.set(i,a,o),this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Ra.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;t!==void 0&&(t.boundingBox===null&&t.computeBoundingBox(),rh.copy(t.boundingBox),rh.applyMatrix4(e.matrixWorld),this.union(rh));const n=e.children;for(let s=0,i=n.length;s<i;s++)this.expandByObject(n[s]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,Ra),Ra.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Ca),Vo.subVectors(this.max,Ca),xi.subVectors(e.a,Ca),bi.subVectors(e.b,Ca),vi.subVectors(e.c,Ca),Br.subVectors(bi,xi),zr.subVectors(vi,bi),ws.subVectors(xi,vi);let t=[0,-Br.z,Br.y,0,-zr.z,zr.y,0,-ws.z,ws.y,Br.z,0,-Br.x,zr.z,0,-zr.x,ws.z,0,-ws.x,-Br.y,Br.x,0,-zr.y,zr.x,0,-ws.y,ws.x,0];return!sh(t,xi,bi,vi,Vo)||(t=[1,0,0,0,1,0,0,0,1],!sh(t,xi,bi,vi,Vo))?!1:(Ho.crossVectors(Br,zr),t=[Ho.x,Ho.y,Ho.z],sh(t,xi,bi,vi,Vo))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return Ra.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=this.getSize(Ra).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(or[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),or[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),or[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),or[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),or[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),or[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),or[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),or[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(or),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}Cn.prototype.isBox3=!0;const or=[new L,new L,new L,new L,new L,new L,new L,new L],Ra=new L,rh=new Cn,xi=new L,bi=new L,vi=new L,Br=new L,zr=new L,ws=new L,Ca=new L,Vo=new L,Ho=new L,Ss=new L;function sh(r,e,t,n,s){for(let i=0,a=r.length-3;i<=a;i+=3){Ss.fromArray(r,i);const o=s.x*Math.abs(Ss.x)+s.y*Math.abs(Ss.y)+s.z*Math.abs(Ss.z),c=e.dot(Ss),l=t.dot(Ss),u=n.dot(Ss);if(Math.max(-Math.max(c,l,u),Math.min(c,l,u))>o)return!1}return!0}const tA=new Cn,O1=new L,ih=new L,ah=new L;class Ts{constructor(e=new L,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;t!==void 0?n.copy(t):tA.setFromPoints(e).getCenter(n);let s=0;for(let i=0,a=e.length;i<a;i++)s=Math.max(s,n.distanceToSquared(e[i]));return this.radius=Math.sqrt(s),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){ah.subVectors(e,this.center);const t=ah.lengthSq();if(t>this.radius*this.radius){const n=Math.sqrt(t),s=(n-this.radius)*.5;this.center.add(ah.multiplyScalar(s/n)),this.radius+=s}return this}union(e){return ih.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(O1.copy(e.center).add(ih)),this.expandByPoint(O1.copy(e.center).sub(ih)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const cr=new L,oh=new L,$o=new L,Ur=new L,ch=new L,Go=new L,uh=new L;class wi{constructor(e=new L,t=new L(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,cr)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(n).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=cr.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(cr.copy(this.direction).multiplyScalar(t).add(this.origin),cr.distanceToSquared(e))}distanceSqToSegment(e,t,n,s){oh.copy(e).add(t).multiplyScalar(.5),$o.copy(t).sub(e).normalize(),Ur.copy(this.origin).sub(oh);const i=e.distanceTo(t)*.5,a=-this.direction.dot($o),o=Ur.dot(this.direction),c=-Ur.dot($o),l=Ur.lengthSq(),u=Math.abs(1-a*a);let h,d,p,f;if(u>0)if(h=a*c-o,d=a*o-c,f=i*u,h>=0)if(d>=-f)if(d<=f){const m=1/u;h*=m,d*=m,p=h*(h+a*d+2*o)+d*(a*h+d+2*c)+l}else d=i,h=Math.max(0,-(a*d+o)),p=-h*h+d*(d+2*c)+l;else d=-i,h=Math.max(0,-(a*d+o)),p=-h*h+d*(d+2*c)+l;else d<=-f?(h=Math.max(0,-(-a*i+o)),d=h>0?-i:Math.min(Math.max(-i,-c),i),p=-h*h+d*(d+2*c)+l):d<=f?(h=0,d=Math.min(Math.max(-i,-c),i),p=d*(d+2*c)+l):(h=Math.max(0,-(a*i+o)),d=h>0?i:Math.min(Math.max(-i,-c),i),p=-h*h+d*(d+2*c)+l);else d=a>0?-i:i,h=Math.max(0,-(a*d+o)),p=-h*h+d*(d+2*c)+l;return n&&n.copy(this.direction).multiplyScalar(h).add(this.origin),s&&s.copy($o).multiplyScalar(d).add(oh),p}intersectSphere(e,t){cr.subVectors(e.center,this.origin);const n=cr.dot(this.direction),s=cr.dot(cr)-n*n,i=e.radius*e.radius;if(s>i)return null;const a=Math.sqrt(i-s),o=n-a,c=n+a;return o<0&&c<0?null:o<0?this.at(c,t):this.at(o,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,s,i,a,o,c;const l=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,d=this.origin;return l>=0?(n=(e.min.x-d.x)*l,s=(e.max.x-d.x)*l):(n=(e.max.x-d.x)*l,s=(e.min.x-d.x)*l),u>=0?(i=(e.min.y-d.y)*u,a=(e.max.y-d.y)*u):(i=(e.max.y-d.y)*u,a=(e.min.y-d.y)*u),n>a||i>s||((i>n||n!==n)&&(n=i),(a<s||s!==s)&&(s=a),h>=0?(o=(e.min.z-d.z)*h,c=(e.max.z-d.z)*h):(o=(e.max.z-d.z)*h,c=(e.min.z-d.z)*h),n>c||o>s)||((o>n||n!==n)&&(n=o),(c<s||s!==s)&&(s=c),s<0)?null:this.at(n>=0?n:s,t)}intersectsBox(e){return this.intersectBox(e,cr)!==null}intersectTriangle(e,t,n,s,i){ch.subVectors(t,e),Go.subVectors(n,e),uh.crossVectors(ch,Go);let a=this.direction.dot(uh),o;if(a>0){if(s)return null;o=1}else if(a<0)o=-1,a=-a;else return null;Ur.subVectors(this.origin,e);const c=o*this.direction.dot(Go.crossVectors(Ur,Go));if(c<0)return null;const l=o*this.direction.dot(ch.cross(Ur));if(l<0||c+l>a)return null;const u=-o*Ur.dot(uh);return u<0?null:this.at(u/a,i)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Be{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,n,s,i,a,o,c,l,u,h,d,p,f,m,_){const g=this.elements;return g[0]=e,g[4]=t,g[8]=n,g[12]=s,g[1]=i,g[5]=a,g[9]=o,g[13]=c,g[2]=l,g[6]=u,g[10]=h,g[14]=d,g[3]=p,g[7]=f,g[11]=m,g[15]=_,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Be().fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,s=1/Si.setFromMatrixColumn(e,0).length(),i=1/Si.setFromMatrixColumn(e,1).length(),a=1/Si.setFromMatrixColumn(e,2).length();return t[0]=n[0]*s,t[1]=n[1]*s,t[2]=n[2]*s,t[3]=0,t[4]=n[4]*i,t[5]=n[5]*i,t[6]=n[6]*i,t[7]=0,t[8]=n[8]*a,t[9]=n[9]*a,t[10]=n[10]*a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,n=e.x,s=e.y,i=e.z,a=Math.cos(n),o=Math.sin(n),c=Math.cos(s),l=Math.sin(s),u=Math.cos(i),h=Math.sin(i);if(e.order==="XYZ"){const d=a*u,p=a*h,f=o*u,m=o*h;t[0]=c*u,t[4]=-c*h,t[8]=l,t[1]=p+f*l,t[5]=d-m*l,t[9]=-o*c,t[2]=m-d*l,t[6]=f+p*l,t[10]=a*c}else if(e.order==="YXZ"){const d=c*u,p=c*h,f=l*u,m=l*h;t[0]=d+m*o,t[4]=f*o-p,t[8]=a*l,t[1]=a*h,t[5]=a*u,t[9]=-o,t[2]=p*o-f,t[6]=m+d*o,t[10]=a*c}else if(e.order==="ZXY"){const d=c*u,p=c*h,f=l*u,m=l*h;t[0]=d-m*o,t[4]=-a*h,t[8]=f+p*o,t[1]=p+f*o,t[5]=a*u,t[9]=m-d*o,t[2]=-a*l,t[6]=o,t[10]=a*c}else if(e.order==="ZYX"){const d=a*u,p=a*h,f=o*u,m=o*h;t[0]=c*u,t[4]=f*l-p,t[8]=d*l+m,t[1]=c*h,t[5]=m*l+d,t[9]=p*l-f,t[2]=-l,t[6]=o*c,t[10]=a*c}else if(e.order==="YZX"){const d=a*c,p=a*l,f=o*c,m=o*l;t[0]=c*u,t[4]=m-d*h,t[8]=f*h+p,t[1]=h,t[5]=a*u,t[9]=-o*u,t[2]=-l*u,t[6]=p*h+f,t[10]=d-m*h}else if(e.order==="XZY"){const d=a*c,p=a*l,f=o*c,m=o*l;t[0]=c*u,t[4]=-h,t[8]=l*u,t[1]=d*h+m,t[5]=a*u,t[9]=p*h-f,t[2]=f*h-p,t[6]=o*u,t[10]=m*h+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(nA,e,rA)}lookAt(e,t,n){const s=this.elements;return vn.subVectors(e,t),vn.lengthSq()===0&&(vn.z=1),vn.normalize(),Vr.crossVectors(n,vn),Vr.lengthSq()===0&&(Math.abs(n.z)===1?vn.x+=1e-4:vn.z+=1e-4,vn.normalize(),Vr.crossVectors(n,vn)),Vr.normalize(),Wo.crossVectors(vn,Vr),s[0]=Vr.x,s[4]=Wo.x,s[8]=vn.x,s[1]=Vr.y,s[5]=Wo.y,s[9]=vn.y,s[2]=Vr.z,s[6]=Wo.z,s[10]=vn.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,s=t.elements,i=this.elements,a=n[0],o=n[4],c=n[8],l=n[12],u=n[1],h=n[5],d=n[9],p=n[13],f=n[2],m=n[6],_=n[10],g=n[14],y=n[3],x=n[7],w=n[11],T=n[15],M=s[0],S=s[4],R=s[8],k=s[12],O=s[1],A=s[5],Y=s[9],B=s[13],H=s[2],U=s[6],j=s[10],K=s[14],se=s[3],ue=s[7],Q=s[11],ee=s[15];return i[0]=a*M+o*O+c*H+l*se,i[4]=a*S+o*A+c*U+l*ue,i[8]=a*R+o*Y+c*j+l*Q,i[12]=a*k+o*B+c*K+l*ee,i[1]=u*M+h*O+d*H+p*se,i[5]=u*S+h*A+d*U+p*ue,i[9]=u*R+h*Y+d*j+p*Q,i[13]=u*k+h*B+d*K+p*ee,i[2]=f*M+m*O+_*H+g*se,i[6]=f*S+m*A+_*U+g*ue,i[10]=f*R+m*Y+_*j+g*Q,i[14]=f*k+m*B+_*K+g*ee,i[3]=y*M+x*O+w*H+T*se,i[7]=y*S+x*A+w*U+T*ue,i[11]=y*R+x*Y+w*j+T*Q,i[15]=y*k+x*B+w*K+T*ee,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],s=e[8],i=e[12],a=e[1],o=e[5],c=e[9],l=e[13],u=e[2],h=e[6],d=e[10],p=e[14],f=e[3],m=e[7],_=e[11],g=e[15];return f*(+i*c*h-s*l*h-i*o*d+n*l*d+s*o*p-n*c*p)+m*(+t*c*p-t*l*d+i*a*d-s*a*p+s*l*u-i*c*u)+_*(+t*l*h-t*o*p-i*a*h+n*a*p+i*o*u-n*l*u)+g*(-s*o*u-t*c*h+t*o*d+s*a*h-n*a*d+n*c*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const s=this.elements;return e.isVector3?(s[12]=e.x,s[13]=e.y,s[14]=e.z):(s[12]=e,s[13]=t,s[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],s=e[2],i=e[3],a=e[4],o=e[5],c=e[6],l=e[7],u=e[8],h=e[9],d=e[10],p=e[11],f=e[12],m=e[13],_=e[14],g=e[15],y=h*_*l-m*d*l+m*c*p-o*_*p-h*c*g+o*d*g,x=f*d*l-u*_*l-f*c*p+a*_*p+u*c*g-a*d*g,w=u*m*l-f*h*l+f*o*p-a*m*p-u*o*g+a*h*g,T=f*h*c-u*m*c-f*o*d+a*m*d+u*o*_-a*h*_,M=t*y+n*x+s*w+i*T;if(M===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const S=1/M;return e[0]=y*S,e[1]=(m*d*i-h*_*i-m*s*p+n*_*p+h*s*g-n*d*g)*S,e[2]=(o*_*i-m*c*i+m*s*l-n*_*l-o*s*g+n*c*g)*S,e[3]=(h*c*i-o*d*i-h*s*l+n*d*l+o*s*p-n*c*p)*S,e[4]=x*S,e[5]=(u*_*i-f*d*i+f*s*p-t*_*p-u*s*g+t*d*g)*S,e[6]=(f*c*i-a*_*i-f*s*l+t*_*l+a*s*g-t*c*g)*S,e[7]=(a*d*i-u*c*i+u*s*l-t*d*l-a*s*p+t*c*p)*S,e[8]=w*S,e[9]=(f*h*i-u*m*i-f*n*p+t*m*p+u*n*g-t*h*g)*S,e[10]=(a*m*i-f*o*i+f*n*l-t*m*l-a*n*g+t*o*g)*S,e[11]=(u*o*i-a*h*i-u*n*l+t*h*l+a*n*p-t*o*p)*S,e[12]=T*S,e[13]=(u*m*s-f*h*s+f*n*d-t*m*d-u*n*_+t*h*_)*S,e[14]=(f*o*s-a*m*s-f*n*c+t*m*c+a*n*_-t*o*_)*S,e[15]=(a*h*s-u*o*s+u*n*c-t*h*c-a*n*d+t*o*d)*S,this}scale(e){const t=this.elements,n=e.x,s=e.y,i=e.z;return t[0]*=n,t[4]*=s,t[8]*=i,t[1]*=n,t[5]*=s,t[9]*=i,t[2]*=n,t[6]*=s,t[10]*=i,t[3]*=n,t[7]*=s,t[11]*=i,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],s=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,s))}makeTranslation(e,t,n){return this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),s=Math.sin(t),i=1-n,a=e.x,o=e.y,c=e.z,l=i*a,u=i*o;return this.set(l*a+n,l*o-s*c,l*c+s*o,0,l*o+s*c,u*o+n,u*c-s*a,0,l*c-s*o,u*c+s*a,i*c*c+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,s,i,a){return this.set(1,n,i,0,e,1,a,0,t,s,1,0,0,0,0,1),this}compose(e,t,n){const s=this.elements,i=t._x,a=t._y,o=t._z,c=t._w,l=i+i,u=a+a,h=o+o,d=i*l,p=i*u,f=i*h,m=a*u,_=a*h,g=o*h,y=c*l,x=c*u,w=c*h,T=n.x,M=n.y,S=n.z;return s[0]=(1-(m+g))*T,s[1]=(p+w)*T,s[2]=(f-x)*T,s[3]=0,s[4]=(p-w)*M,s[5]=(1-(d+g))*M,s[6]=(_+y)*M,s[7]=0,s[8]=(f+x)*S,s[9]=(_-y)*S,s[10]=(1-(d+m))*S,s[11]=0,s[12]=e.x,s[13]=e.y,s[14]=e.z,s[15]=1,this}decompose(e,t,n){const s=this.elements;let i=Si.set(s[0],s[1],s[2]).length();const a=Si.set(s[4],s[5],s[6]).length(),o=Si.set(s[8],s[9],s[10]).length();this.determinant()<0&&(i=-i),e.x=s[12],e.y=s[13],e.z=s[14],zn.copy(this);const l=1/i,u=1/a,h=1/o;return zn.elements[0]*=l,zn.elements[1]*=l,zn.elements[2]*=l,zn.elements[4]*=u,zn.elements[5]*=u,zn.elements[6]*=u,zn.elements[8]*=h,zn.elements[9]*=h,zn.elements[10]*=h,t.setFromRotationMatrix(zn),n.x=i,n.y=a,n.z=o,this}makePerspective(e,t,n,s,i,a){a===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,c=2*i/(t-e),l=2*i/(n-s),u=(t+e)/(t-e),h=(n+s)/(n-s),d=-(a+i)/(a-i),p=-2*a*i/(a-i);return o[0]=c,o[4]=0,o[8]=u,o[12]=0,o[1]=0,o[5]=l,o[9]=h,o[13]=0,o[2]=0,o[6]=0,o[10]=d,o[14]=p,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(e,t,n,s,i,a){const o=this.elements,c=1/(t-e),l=1/(n-s),u=1/(a-i),h=(t+e)*c,d=(n+s)*l,p=(a+i)*u;return o[0]=2*c,o[4]=0,o[8]=0,o[12]=-h,o[1]=0,o[5]=2*l,o[9]=0,o[13]=-d,o[2]=0,o[6]=0,o[10]=-2*u,o[14]=-p,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let s=0;s<16;s++)if(t[s]!==n[s])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}Be.prototype.isMatrix4=!0;const Si=new L,zn=new Be,nA=new L(0,0,0),rA=new L(1,1,1),Vr=new L,Wo=new L,vn=new L,B1=new Be,z1=new hn;class Ti{constructor(e=0,t=0,n=0,s=Ti.DefaultOrder){this._x=e,this._y=t,this._z=n,this._order=s}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,s=this._order){return this._x=e,this._y=t,this._z=n,this._order=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const s=e.elements,i=s[0],a=s[4],o=s[8],c=s[1],l=s[5],u=s[9],h=s[2],d=s[6],p=s[10];switch(t){case"XYZ":this._y=Math.asin(_n(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-a,i)):(this._x=Math.atan2(d,l),this._z=0);break;case"YXZ":this._x=Math.asin(-_n(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(o,p),this._z=Math.atan2(c,l)):(this._y=Math.atan2(-h,i),this._z=0);break;case"ZXY":this._x=Math.asin(_n(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,p),this._z=Math.atan2(-a,l)):(this._y=0,this._z=Math.atan2(c,i));break;case"ZYX":this._y=Math.asin(-_n(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(c,i)):(this._x=0,this._z=Math.atan2(-a,l));break;case"YZX":this._z=Math.asin(_n(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-u,l),this._y=Math.atan2(-h,i)):(this._x=0,this._y=Math.atan2(o,p));break;case"XZY":this._z=Math.asin(-_n(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(d,l),this._y=Math.atan2(o,i)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return B1.makeRotationFromQuaternion(e),this.setFromRotationMatrix(B1,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return z1.setFromEuler(this),this.setFromQuaternion(z1,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new L(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}Ti.prototype.isEuler=!0;Ti.DefaultOrder="XYZ";Ti.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class sA{constructor(){this.mask=1|0}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=4294967295|0}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!=0}isEnabled(e){return(this.mask&(1<<e|0))!=0}}let iA=0;const U1=new L,Ei=new hn,ur=new Be,jo=new L,La=new L,aA=new L,oA=new hn,V1=new L(1,0,0),H1=new L(0,1,0),$1=new L(0,0,1),cA={type:"added"},G1={type:"removed"};class it extends vs{constructor(){super();Object.defineProperty(this,"id",{value:iA++}),this.uuid=Nn(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=it.DefaultUp.clone();const e=new L,t=new Ti,n=new hn,s=new L(1,1,1);function i(){n.setFromEuler(t,!1)}function a(){t.setFromQuaternion(n,void 0,!1)}t._onChange(i),n._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:s},modelViewMatrix:{value:new Be},normalMatrix:{value:new Qt}}),this.matrix=new Be,this.matrixWorld=new Be,this.matrixAutoUpdate=it.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new sA,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return Ei.setFromAxisAngle(e,t),this.quaternion.multiply(Ei),this}rotateOnWorldAxis(e,t){return Ei.setFromAxisAngle(e,t),this.quaternion.premultiply(Ei),this}rotateX(e){return this.rotateOnAxis(V1,e)}rotateY(e){return this.rotateOnAxis(H1,e)}rotateZ(e){return this.rotateOnAxis($1,e)}translateOnAxis(e,t){return U1.copy(e).applyQuaternion(this.quaternion),this.position.add(U1.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(V1,e)}translateY(e){return this.translateOnAxis(H1,e)}translateZ(e){return this.translateOnAxis($1,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(ur.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?jo.copy(e):jo.set(e,t,n);const s=this.parent;this.updateWorldMatrix(!0,!1),La.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ur.lookAt(La,jo,this.up):ur.lookAt(jo,La,this.up),this.quaternion.setFromRotationMatrix(ur),s&&(ur.extractRotation(s.matrixWorld),Ei.setFromRotationMatrix(ur),this.quaternion.premultiply(Ei.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(cA)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(G1)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(G1)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),ur.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),ur.multiply(e.parent.matrixWorld)),e.applyMatrix4(ur),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,s=this.children.length;n<s;n++){const a=this.children[n].getObjectByProperty(e,t);if(a!==void 0)return a}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(La,e,aA),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(La,oA,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,s=t.length;n<s;n++)t[n].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let n=0,s=t.length;n<s;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,s=t.length;n<s;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){const n=this.parent;if(e===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const s=this.children;for(let i=0,a=s.length;i<a;i++)s[i].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const s={};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.castShadow===!0&&(s.castShadow=!0),this.receiveShadow===!0&&(s.receiveShadow=!0),this.visible===!1&&(s.visible=!1),this.frustumCulled===!1&&(s.frustumCulled=!1),this.renderOrder!==0&&(s.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(s.userData=this.userData),s.layers=this.layers.mask,s.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(s.matrixAutoUpdate=!1),this.isInstancedMesh&&(s.type="InstancedMesh",s.count=this.count,s.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(s.instanceColor=this.instanceColor.toJSON()));function i(o,c){return o[c.uuid]===void 0&&(o[c.uuid]=c.toJSON(e)),c.uuid}if(this.isScene)this.background&&(this.background.isColor?s.background=this.background.toJSON():this.background.isTexture&&(s.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&(s.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){s.geometry=i(e.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const c=o.shapes;if(Array.isArray(c))for(let l=0,u=c.length;l<u;l++){const h=c[l];i(e.shapes,h)}else i(e.shapes,c)}}if(this.isSkinnedMesh&&(s.bindMode=this.bindMode,s.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(i(e.skeletons,this.skeleton),s.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let c=0,l=this.material.length;c<l;c++)o.push(i(e.materials,this.material[c]));s.material=o}else s.material=i(e.materials,this.material);if(this.children.length>0){s.children=[];for(let o=0;o<this.children.length;o++)s.children.push(this.children[o].toJSON(e).object)}if(this.animations.length>0){s.animations=[];for(let o=0;o<this.animations.length;o++){const c=this.animations[o];s.animations.push(i(e.animations,c))}}if(t){const o=a(e.geometries),c=a(e.materials),l=a(e.textures),u=a(e.images),h=a(e.shapes),d=a(e.skeletons),p=a(e.animations);o.length>0&&(n.geometries=o),c.length>0&&(n.materials=c),l.length>0&&(n.textures=l),u.length>0&&(n.images=u),h.length>0&&(n.shapes=h),d.length>0&&(n.skeletons=d),p.length>0&&(n.animations=p)}return n.object=s,n;function a(o){const c=[];for(const l in o){const u=o[l];delete u.metadata,c.push(u)}return c}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){const s=e.children[n];this.add(s.clone())}return this}}it.DefaultUp=new L(0,1,0);it.DefaultMatrixAutoUpdate=!0;it.prototype.isObject3D=!0;const Un=new L,lr=new L,lh=new L,hr=new L,Mi=new L,Ai=new L,W1=new L,hh=new L,dh=new L,ph=new L;class Dt{constructor(e=new L,t=new L,n=new L){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,s){s.subVectors(n,t),Un.subVectors(e,t),s.cross(Un);const i=s.lengthSq();return i>0?s.multiplyScalar(1/Math.sqrt(i)):s.set(0,0,0)}static getBarycoord(e,t,n,s,i){Un.subVectors(s,t),lr.subVectors(n,t),lh.subVectors(e,t);const a=Un.dot(Un),o=Un.dot(lr),c=Un.dot(lh),l=lr.dot(lr),u=lr.dot(lh),h=a*l-o*o;if(h===0)return i.set(-2,-1,-1);const d=1/h,p=(l*c-o*u)*d,f=(a*u-o*c)*d;return i.set(1-p-f,f,p)}static containsPoint(e,t,n,s){return this.getBarycoord(e,t,n,s,hr),hr.x>=0&&hr.y>=0&&hr.x+hr.y<=1}static getUV(e,t,n,s,i,a,o,c){return this.getBarycoord(e,t,n,s,hr),c.set(0,0),c.addScaledVector(i,hr.x),c.addScaledVector(a,hr.y),c.addScaledVector(o,hr.z),c}static isFrontFacing(e,t,n,s){return Un.subVectors(n,t),lr.subVectors(e,t),Un.cross(lr).dot(s)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,s){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[s]),this}setFromAttributeAndIndices(e,t,n,s){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,s),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Un.subVectors(this.c,this.b),lr.subVectors(this.a,this.b),Un.cross(lr).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Dt.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Dt.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,n,s,i){return Dt.getUV(e,this.a,this.b,this.c,t,n,s,i)}containsPoint(e){return Dt.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Dt.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,s=this.b,i=this.c;let a,o;Mi.subVectors(s,n),Ai.subVectors(i,n),hh.subVectors(e,n);const c=Mi.dot(hh),l=Ai.dot(hh);if(c<=0&&l<=0)return t.copy(n);dh.subVectors(e,s);const u=Mi.dot(dh),h=Ai.dot(dh);if(u>=0&&h<=u)return t.copy(s);const d=c*h-u*l;if(d<=0&&c>=0&&u<=0)return a=c/(c-u),t.copy(n).addScaledVector(Mi,a);ph.subVectors(e,i);const p=Mi.dot(ph),f=Ai.dot(ph);if(f>=0&&p<=f)return t.copy(i);const m=p*l-c*f;if(m<=0&&l>=0&&f<=0)return o=l/(l-f),t.copy(n).addScaledVector(Ai,o);const _=u*f-p*h;if(_<=0&&h-u>=0&&p-f>=0)return W1.subVectors(i,s),o=(h-u)/(h-u+(p-f)),t.copy(s).addScaledVector(W1,o);const g=1/(_+m+d);return a=m*g,o=d*g,t.copy(n).addScaledVector(Mi,a).addScaledVector(Ai,o)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let uA=0;class Ht extends vs{constructor(){super();Object.defineProperty(this,"id",{value:uA++}),this.uuid=Nn(),this.name="",this.type="Material",this.fog=!0,this.blending=va,this.side=oi,this.vertexColors=!1,this.opacity=1,this.format=sn,this.transparent=!1,this.blendSrc=d1,this.blendDst=p1,this.blendEquation=ci,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Vl,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=BM,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Jl,this.stencilZFail=Jl,this.stencilZPass=Jl,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const n=e[t];if(n===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===a1;continue}const s=this[t];if(s===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}s&&s.isColor?s.set(n):s&&s.isVector3&&n&&n.isVector3?s.copy(n):this[t]=n}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==va&&(n.blending=this.blending),this.side!==oi&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.format!==sn&&(n.format=this.format),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.colorWrite=this.colorWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(n.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=this.flatShading),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData);function s(i){const a=[];for(const o in i){const c=i[o];delete c.metadata,a.push(c)}return a}if(t){const i=s(e.textures),a=s(e.images);i.length>0&&(n.textures=i),a.length>0&&(n.images=a)}return n}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.format=e.format,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(t!==null){const s=t.length;n=new Array(s);for(let i=0;i!==s;++i)n[i]=t[i].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}Ht.prototype.isMaterial=!0;const j1={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Vn={h:0,s:0,l:0},qo={h:0,s:0,l:0};function fh(r,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?r+(e-r)*6*t:t<1/2?e:t<2/3?r+(e-r)*6*(2/3-t):r}function mh(r){return r<.04045?r*.0773993808:Math.pow(r*.9478672986+.0521327014,2.4)}function gh(r){return r<.0031308?r*12.92:1.055*Math.pow(r,.41666)-.055}class Le{constructor(e,t,n){return t===void 0&&n===void 0?this.set(e):this.setRGB(e,t,n)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,this}setRGB(e,t,n){return this.r=e,this.g=t,this.b=n,this}setHSL(e,t,n){if(e=Zl(e,1),t=_n(t,0,1),n=_n(n,0,1),t===0)this.r=this.g=this.b=n;else{const s=n<=.5?n*(1+t):n+t-n*t,i=2*n-s;this.r=fh(i,s,e+1/3),this.g=fh(i,s,e),this.b=fh(i,s,e-1/3)}return this}setStyle(e){function t(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let n;if(n=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let s;const i=n[1],a=n[2];switch(i){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(255,parseInt(s[1],10))/255,this.g=Math.min(255,parseInt(s[2],10))/255,this.b=Math.min(255,parseInt(s[3],10))/255,t(s[4]),this;if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return this.r=Math.min(100,parseInt(s[1],10))/100,this.g=Math.min(100,parseInt(s[2],10))/100,this.b=Math.min(100,parseInt(s[3],10))/100,t(s[4]),this;break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)){const o=parseFloat(s[1])/360,c=parseInt(s[2],10)/100,l=parseInt(s[3],10)/100;return t(s[4]),this.setHSL(o,c,l)}break}}else if(n=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=n[1],i=s.length;if(i===3)return this.r=parseInt(s.charAt(0)+s.charAt(0),16)/255,this.g=parseInt(s.charAt(1)+s.charAt(1),16)/255,this.b=parseInt(s.charAt(2)+s.charAt(2),16)/255,this;if(i===6)return this.r=parseInt(s.charAt(0)+s.charAt(1),16)/255,this.g=parseInt(s.charAt(2)+s.charAt(3),16)/255,this.b=parseInt(s.charAt(4)+s.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=j1[e.toLowerCase()];return t!==void 0?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const n=t>0?1/t:1;return this.r=Math.pow(e.r,n),this.g=Math.pow(e.g,n),this.b=Math.pow(e.b,n),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=mh(e.r),this.g=mh(e.g),this.b=mh(e.b),this}copyLinearToSRGB(e){return this.r=gh(e.r),this.g=gh(e.g),this.b=gh(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){const t=this.r,n=this.g,s=this.b,i=Math.max(t,n,s),a=Math.min(t,n,s);let o,c;const l=(a+i)/2;if(a===i)o=0,c=0;else{const u=i-a;switch(c=l<=.5?u/(i+a):u/(2-i-a),i){case t:o=(n-s)/u+(n<s?6:0);break;case n:o=(s-t)/u+2;break;case s:o=(t-n)/u+4;break}o/=6}return e.h=o,e.s=c,e.l=l,e}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(e,t,n){return this.getHSL(Vn),Vn.h+=e,Vn.s+=t,Vn.l+=n,this.setHSL(Vn.h,Vn.s,Vn.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(Vn),e.getHSL(qo);const n=Na(Vn.h,qo.h,t),s=Na(Vn.s,qo.s,t),i=Na(Vn.l,qo.l,t);return this.setHSL(n,s,i),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Le.NAMES=j1;Le.prototype.isColor=!0;Le.prototype.r=1;Le.prototype.g=1;Le.prototype.b=1;class qn extends Ht{constructor(e){super();this.type="MeshBasicMaterial",this.color=new Le(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ko,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}qn.prototype.isMeshBasicMaterial=!0;const gt=new L,Ko=new fe;class It{constructor(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n===!0,this.usage=Ma,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let s=0,i=this.itemSize;s<i;s++)this.array[e+s]=t.array[n+s];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let n=0;for(let s=0,i=e.length;s<i;s++){let a=e[s];a===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",s),a=new Le),t[n++]=a.r,t[n++]=a.g,t[n++]=a.b}return this}copyVector2sArray(e){const t=this.array;let n=0;for(let s=0,i=e.length;s<i;s++){let a=e[s];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",s),a=new fe),t[n++]=a.x,t[n++]=a.y}return this}copyVector3sArray(e){const t=this.array;let n=0;for(let s=0,i=e.length;s<i;s++){let a=e[s];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",s),a=new L),t[n++]=a.x,t[n++]=a.y,t[n++]=a.z}return this}copyVector4sArray(e){const t=this.array;let n=0;for(let s=0,i=e.length;s<i;s++){let a=e[s];a===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",s),a=new pt),t[n++]=a.x,t[n++]=a.y,t[n++]=a.z,t[n++]=a.w}return this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)Ko.fromBufferAttribute(this,t),Ko.applyMatrix3(e),this.setXY(t,Ko.x,Ko.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)gt.fromBufferAttribute(this,t),gt.applyMatrix3(e),this.setXYZ(t,gt.x,gt.y,gt.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)gt.x=this.getX(t),gt.y=this.getY(t),gt.z=this.getZ(t),gt.applyMatrix4(e),this.setXYZ(t,gt.x,gt.y,gt.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)gt.x=this.getX(t),gt.y=this.getY(t),gt.z=this.getZ(t),gt.applyNormalMatrix(e),this.setXYZ(t,gt.x,gt.y,gt.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)gt.x=this.getX(t),gt.y=this.getY(t),gt.z=this.getZ(t),gt.transformDirection(e),this.setXYZ(t,gt.x,gt.y,gt.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,s){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=s,this}setXYZW(e,t,n,s,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=s,this.array[e+3]=i,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==Ma&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}}It.prototype.isBufferAttribute=!0;class q1 extends It{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class K1 extends It{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class lA extends It{constructor(e,t,n){super(new Uint16Array(e),t,n)}}lA.prototype.isFloat16BufferAttribute=!0;class Nt extends It{constructor(e,t,n){super(new Float32Array(e),t,n)}}let hA=0;const Ln=new Be,yh=new it,Ii=new L,wn=new Cn,ka=new Cn,Kt=new L;class yt extends vs{constructor(){super();Object.defineProperty(this,"id",{value:hA++}),this.uuid=Nn(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(D1(e)>65535?K1:q1)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const i=new Qt().getNormalMatrix(e);n.applyNormalMatrix(i),n.needsUpdate=!0}const s=this.attributes.tangent;return s!==void 0&&(s.transformDirection(e),s.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Ln.makeRotationFromQuaternion(e),this.applyMatrix4(Ln),this}rotateX(e){return Ln.makeRotationX(e),this.applyMatrix4(Ln),this}rotateY(e){return Ln.makeRotationY(e),this.applyMatrix4(Ln),this}rotateZ(e){return Ln.makeRotationZ(e),this.applyMatrix4(Ln),this}translate(e,t,n){return Ln.makeTranslation(e,t,n),this.applyMatrix4(Ln),this}scale(e,t,n){return Ln.makeScale(e,t,n),this.applyMatrix4(Ln),this}lookAt(e){return yh.lookAt(e),yh.updateMatrix(),this.applyMatrix4(yh.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Ii).negate(),this.translate(Ii.x,Ii.y,Ii.z),this}setFromPoints(e){const t=[];for(let n=0,s=e.length;n<s;n++){const i=e[n];t.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new Nt(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Cn);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new L(-1/0,-1/0,-1/0),new L(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,s=t.length;n<s;n++){const i=t[n];wn.setFromBufferAttribute(i),this.morphTargetsRelative?(Kt.addVectors(this.boundingBox.min,wn.min),this.boundingBox.expandByPoint(Kt),Kt.addVectors(this.boundingBox.max,wn.max),this.boundingBox.expandByPoint(Kt)):(this.boundingBox.expandByPoint(wn.min),this.boundingBox.expandByPoint(wn.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Ts);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new L,1/0);return}if(e){const n=this.boundingSphere.center;if(wn.setFromBufferAttribute(e),t)for(let i=0,a=t.length;i<a;i++){const o=t[i];ka.setFromBufferAttribute(o),this.morphTargetsRelative?(Kt.addVectors(wn.min,ka.min),wn.expandByPoint(Kt),Kt.addVectors(wn.max,ka.max),wn.expandByPoint(Kt)):(wn.expandByPoint(ka.min),wn.expandByPoint(ka.max))}wn.getCenter(n);let s=0;for(let i=0,a=e.count;i<a;i++)Kt.fromBufferAttribute(e,i),s=Math.max(s,n.distanceToSquared(Kt));if(t)for(let i=0,a=t.length;i<a;i++){const o=t[i],c=this.morphTargetsRelative;for(let l=0,u=o.count;l<u;l++)Kt.fromBufferAttribute(o,l),c&&(Ii.fromBufferAttribute(e,l),Kt.add(Ii)),s=Math.max(s,n.distanceToSquared(Kt))}this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=e.array,s=t.position.array,i=t.normal.array,a=t.uv.array,o=s.length/3;t.tangent===void 0&&this.setAttribute("tangent",new It(new Float32Array(4*o),4));const c=t.tangent.array,l=[],u=[];for(let O=0;O<o;O++)l[O]=new L,u[O]=new L;const h=new L,d=new L,p=new L,f=new fe,m=new fe,_=new fe,g=new L,y=new L;function x(O,A,Y){h.fromArray(s,O*3),d.fromArray(s,A*3),p.fromArray(s,Y*3),f.fromArray(a,O*2),m.fromArray(a,A*2),_.fromArray(a,Y*2),d.sub(h),p.sub(h),m.sub(f),_.sub(f);const B=1/(m.x*_.y-_.x*m.y);!isFinite(B)||(g.copy(d).multiplyScalar(_.y).addScaledVector(p,-m.y).multiplyScalar(B),y.copy(p).multiplyScalar(m.x).addScaledVector(d,-_.x).multiplyScalar(B),l[O].add(g),l[A].add(g),l[Y].add(g),u[O].add(y),u[A].add(y),u[Y].add(y))}let w=this.groups;w.length===0&&(w=[{start:0,count:n.length}]);for(let O=0,A=w.length;O<A;++O){const Y=w[O],B=Y.start,H=Y.count;for(let U=B,j=B+H;U<j;U+=3)x(n[U+0],n[U+1],n[U+2])}const T=new L,M=new L,S=new L,R=new L;function k(O){S.fromArray(i,O*3),R.copy(S);const A=l[O];T.copy(A),T.sub(S.multiplyScalar(S.dot(A))).normalize(),M.crossVectors(R,A);const B=M.dot(u[O])<0?-1:1;c[O*4]=T.x,c[O*4+1]=T.y,c[O*4+2]=T.z,c[O*4+3]=B}for(let O=0,A=w.length;O<A;++O){const Y=w[O],B=Y.start,H=Y.count;for(let U=B,j=B+H;U<j;U+=3)k(n[U+0]),k(n[U+1]),k(n[U+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new It(new Float32Array(t.count*3),3),this.setAttribute("normal",n);else for(let d=0,p=n.count;d<p;d++)n.setXYZ(d,0,0,0);const s=new L,i=new L,a=new L,o=new L,c=new L,l=new L,u=new L,h=new L;if(e)for(let d=0,p=e.count;d<p;d+=3){const f=e.getX(d+0),m=e.getX(d+1),_=e.getX(d+2);s.fromBufferAttribute(t,f),i.fromBufferAttribute(t,m),a.fromBufferAttribute(t,_),u.subVectors(a,i),h.subVectors(s,i),u.cross(h),o.fromBufferAttribute(n,f),c.fromBufferAttribute(n,m),l.fromBufferAttribute(n,_),o.add(u),c.add(u),l.add(u),n.setXYZ(f,o.x,o.y,o.z),n.setXYZ(m,c.x,c.y,c.z),n.setXYZ(_,l.x,l.y,l.z)}else for(let d=0,p=t.count;d<p;d+=3)s.fromBufferAttribute(t,d+0),i.fromBufferAttribute(t,d+1),a.fromBufferAttribute(t,d+2),u.subVectors(a,i),h.subVectors(s,i),u.cross(h),n.setXYZ(d+0,u.x,u.y,u.z),n.setXYZ(d+1,u.x,u.y,u.z),n.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),n.needsUpdate=!0}}merge(e,t){if(!(e&&e.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);return}t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const s in n){if(e.attributes[s]===void 0)continue;const a=n[s].array,o=e.attributes[s],c=o.array,l=o.itemSize*t,u=Math.min(c.length,a.length-l);for(let h=0,d=l;h<u;h++,d++)a[d]=c[h]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)Kt.fromBufferAttribute(e,t),Kt.normalize(),e.setXYZ(t,Kt.x,Kt.y,Kt.z)}toNonIndexed(){function e(o,c){const l=o.array,u=o.itemSize,h=o.normalized,d=new l.constructor(c.length*u);let p=0,f=0;for(let m=0,_=c.length;m<_;m++){o.isInterleavedBufferAttribute?p=c[m]*o.data.stride+o.offset:p=c[m]*u;for(let g=0;g<u;g++)d[f++]=l[p++]}return new It(d,u,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new yt,n=this.index.array,s=this.attributes;for(const o in s){const c=s[o],l=e(c,n);t.setAttribute(o,l)}const i=this.morphAttributes;for(const o in i){const c=[],l=i[o];for(let u=0,h=l.length;u<h;u++){const d=l[u],p=e(d,n);c.push(p)}t.morphAttributes[o]=c}t.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let o=0,c=a.length;o<c;o++){const l=a[o];t.addGroup(l.start,l.count,l.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const c=this.parameters;for(const l in c)c[l]!==void 0&&(e[l]=c[l]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const c in n){const l=n[c];e.data.attributes[c]=l.toJSON(e.data)}const s={};let i=!1;for(const c in this.morphAttributes){const l=this.morphAttributes[c],u=[];for(let h=0,d=l.length;h<d;h++){const p=l[h];u.push(p.toJSON(e.data))}u.length>0&&(s[c]=u,i=!0)}i&&(e.data.morphAttributes=s,e.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(e.data.groups=JSON.parse(JSON.stringify(a)));const o=this.boundingSphere;return o!==null&&(e.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;n!==null&&this.setIndex(n.clone(t));const s=e.attributes;for(const l in s){const u=s[l];this.setAttribute(l,u.clone(t))}const i=e.morphAttributes;for(const l in i){const u=[],h=i[l];for(let d=0,p=h.length;d<p;d++)u.push(h[d].clone(t));this.morphAttributes[l]=u}this.morphTargetsRelative=e.morphTargetsRelative;const a=e.groups;for(let l=0,u=a.length;l<u;l++){const h=a[l];this.addGroup(h.start,h.count,h.materialIndex)}const o=e.boundingBox;o!==null&&(this.boundingBox=o.clone());const c=e.boundingSphere;return c!==null&&(this.boundingSphere=c.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,e.parameters!==void 0&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}yt.prototype.isBufferGeometry=!0;const X1=new Be,Ni=new wi,_h=new Ts,Hr=new L,$r=new L,Gr=new L,xh=new L,bh=new L,vh=new L,Xo=new L,Yo=new L,Jo=new L,Zo=new fe,Qo=new fe,ec=new fe,wh=new L,tc=new L;class $t extends it{constructor(e=new yt,t=new qn){super();this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const s=t[n[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,a=s.length;i<a;i++){const o=s[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=i}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){const n=this.geometry,s=this.material,i=this.matrixWorld;if(s===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),_h.copy(n.boundingSphere),_h.applyMatrix4(i),e.ray.intersectsSphere(_h)===!1)||(X1.copy(i).invert(),Ni.copy(e.ray).applyMatrix4(X1),n.boundingBox!==null&&Ni.intersectsBox(n.boundingBox)===!1))return;let a;if(n.isBufferGeometry){const o=n.index,c=n.attributes.position,l=n.morphAttributes.position,u=n.morphTargetsRelative,h=n.attributes.uv,d=n.attributes.uv2,p=n.groups,f=n.drawRange;if(o!==null)if(Array.isArray(s))for(let m=0,_=p.length;m<_;m++){const g=p[m],y=s[g.materialIndex],x=Math.max(g.start,f.start),w=Math.min(o.count,Math.min(g.start+g.count,f.start+f.count));for(let T=x,M=w;T<M;T+=3){const S=o.getX(T),R=o.getX(T+1),k=o.getX(T+2);a=nc(this,y,e,Ni,c,l,u,h,d,S,R,k),a&&(a.faceIndex=Math.floor(T/3),a.face.materialIndex=g.materialIndex,t.push(a))}}else{const m=Math.max(0,f.start),_=Math.min(o.count,f.start+f.count);for(let g=m,y=_;g<y;g+=3){const x=o.getX(g),w=o.getX(g+1),T=o.getX(g+2);a=nc(this,s,e,Ni,c,l,u,h,d,x,w,T),a&&(a.faceIndex=Math.floor(g/3),t.push(a))}}else if(c!==void 0)if(Array.isArray(s))for(let m=0,_=p.length;m<_;m++){const g=p[m],y=s[g.materialIndex],x=Math.max(g.start,f.start),w=Math.min(c.count,Math.min(g.start+g.count,f.start+f.count));for(let T=x,M=w;T<M;T+=3){const S=T,R=T+1,k=T+2;a=nc(this,y,e,Ni,c,l,u,h,d,S,R,k),a&&(a.faceIndex=Math.floor(T/3),a.face.materialIndex=g.materialIndex,t.push(a))}}else{const m=Math.max(0,f.start),_=Math.min(c.count,f.start+f.count);for(let g=m,y=_;g<y;g+=3){const x=g,w=g+1,T=g+2;a=nc(this,s,e,Ni,c,l,u,h,d,x,w,T),a&&(a.faceIndex=Math.floor(g/3),t.push(a))}}}else n.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}$t.prototype.isMesh=!0;function dA(r,e,t,n,s,i,a,o){let c;if(e.side===zt?c=n.intersectTriangle(a,i,s,!0,o):c=n.intersectTriangle(s,i,a,e.side!==ys,o),c===null)return null;tc.copy(o),tc.applyMatrix4(r.matrixWorld);const l=t.ray.origin.distanceTo(tc);return l<t.near||l>t.far?null:{distance:l,point:tc.clone(),object:r}}function nc(r,e,t,n,s,i,a,o,c,l,u,h){Hr.fromBufferAttribute(s,l),$r.fromBufferAttribute(s,u),Gr.fromBufferAttribute(s,h);const d=r.morphTargetInfluences;if(i&&d){Xo.set(0,0,0),Yo.set(0,0,0),Jo.set(0,0,0);for(let f=0,m=i.length;f<m;f++){const _=d[f],g=i[f];_!==0&&(xh.fromBufferAttribute(g,l),bh.fromBufferAttribute(g,u),vh.fromBufferAttribute(g,h),a?(Xo.addScaledVector(xh,_),Yo.addScaledVector(bh,_),Jo.addScaledVector(vh,_)):(Xo.addScaledVector(xh.sub(Hr),_),Yo.addScaledVector(bh.sub($r),_),Jo.addScaledVector(vh.sub(Gr),_)))}Hr.add(Xo),$r.add(Yo),Gr.add(Jo)}r.isSkinnedMesh&&(r.boneTransform(l,Hr),r.boneTransform(u,$r),r.boneTransform(h,Gr));const p=dA(r,e,t,n,Hr,$r,Gr,wh);if(p){o&&(Zo.fromBufferAttribute(o,l),Qo.fromBufferAttribute(o,u),ec.fromBufferAttribute(o,h),p.uv=Dt.getUV(wh,Hr,$r,Gr,Zo,Qo,ec,new fe)),c&&(Zo.fromBufferAttribute(c,l),Qo.fromBufferAttribute(c,u),ec.fromBufferAttribute(c,h),p.uv2=Dt.getUV(wh,Hr,$r,Gr,Zo,Qo,ec,new fe));const f={a:l,b:u,c:h,normal:new L,materialIndex:0};Dt.getNormal(Hr,$r,Gr,f.normal),p.face=f}return p}class Da extends yt{constructor(e=1,t=1,n=1,s=1,i=1,a=1){super();this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:s,heightSegments:i,depthSegments:a};const o=this;s=Math.floor(s),i=Math.floor(i),a=Math.floor(a);const c=[],l=[],u=[],h=[];let d=0,p=0;f("z","y","x",-1,-1,n,t,e,a,i,0),f("z","y","x",1,-1,n,t,-e,a,i,1),f("x","z","y",1,1,e,n,t,s,a,2),f("x","z","y",1,-1,e,n,-t,s,a,3),f("x","y","z",1,-1,e,t,n,s,i,4),f("x","y","z",-1,-1,e,t,-n,s,i,5),this.setIndex(c),this.setAttribute("position",new Nt(l,3)),this.setAttribute("normal",new Nt(u,3)),this.setAttribute("uv",new Nt(h,2));function f(m,_,g,y,x,w,T,M,S,R,k){const O=w/S,A=T/R,Y=w/2,B=T/2,H=M/2,U=S+1,j=R+1;let K=0,se=0;const ue=new L;for(let Q=0;Q<j;Q++){const ee=Q*A-B;for(let ge=0;ge<U;ge++){const he=ge*O-Y;ue[m]=he*y,ue[_]=ee*x,ue[g]=H,l.push(ue.x,ue.y,ue.z),ue[m]=0,ue[_]=0,ue[g]=M>0?1:-1,u.push(ue.x,ue.y,ue.z),h.push(ge/S),h.push(1-Q/R),K+=1}}for(let Q=0;Q<R;Q++)for(let ee=0;ee<S;ee++){const ge=d+ee+U*Q,he=d+ee+U*(Q+1),Me=d+(ee+1)+U*(Q+1),je=d+(ee+1)+U*Q;c.push(ge,he,je),c.push(he,Me,je),se+=6}o.addGroup(p,se,k),p+=se,d+=K}}static fromJSON(e){return new Da(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function Ri(r){const e={};for(const t in r){e[t]={};for(const n in r[t]){const s=r[t][n];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture||s.isQuaternion)?e[t][n]=s.clone():Array.isArray(s)?e[t][n]=s.slice():e[t][n]=s}}return e}function an(r){const e={};for(let t=0;t<r.length;t++){const n=Ri(r[t]);for(const s in n)e[s]=n[s]}return e}const pA={clone:Ri,merge:an};var fA=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,mA=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Es extends Ht{constructor(e){super();this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=fA,this.fragmentShader=mA,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Ri(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const s in this.uniforms){const a=this.uniforms[s].value;a&&a.isTexture?t.uniforms[s]={type:"t",value:a.toJSON(e).uuid}:a&&a.isColor?t.uniforms[s]={type:"c",value:a.getHex()}:a&&a.isVector2?t.uniforms[s]={type:"v2",value:a.toArray()}:a&&a.isVector3?t.uniforms[s]={type:"v3",value:a.toArray()}:a&&a.isVector4?t.uniforms[s]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?t.uniforms[s]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?t.uniforms[s]={type:"m4",value:a.toArray()}:t.uniforms[s]={value:a}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const s in this.extensions)this.extensions[s]===!0&&(n[s]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}Es.prototype.isShaderMaterial=!0;class Sh extends it{constructor(){super();this.type="Camera",this.matrixWorldInverse=new Be,this.projectionMatrix=new Be,this.projectionMatrixInverse=new Be}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}Sh.prototype.isCamera=!0;class dn extends Sh{constructor(e=50,t=1,n=.1,s=2e3){super();this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=s,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=Ia*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Aa*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return Ia*2*Math.atan(Math.tan(Aa*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,n,s,i,a){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=s,this.view.width=i,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(Aa*.5*this.fov)/this.zoom,n=2*t,s=this.aspect*n,i=-.5*s;const a=this.view;if(this.view!==null&&this.view.enabled){const c=a.fullWidth,l=a.fullHeight;i+=a.offsetX*s/c,t-=a.offsetY*n/l,s*=a.width/c,n*=a.height/l}const o=this.filmOffset;o!==0&&(i+=e*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+s,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}dn.prototype.isPerspectiveCamera=!0;const Ci=90,Li=1;class Th extends it{constructor(e,t,n){super();if(this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;const s=new dn(Ci,Li,e,t);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new L(1,0,0)),this.add(s);const i=new dn(Ci,Li,e,t);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new L(-1,0,0)),this.add(i);const a=new dn(Ci,Li,e,t);a.layers=this.layers,a.up.set(0,0,1),a.lookAt(new L(0,1,0)),this.add(a);const o=new dn(Ci,Li,e,t);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new L(0,-1,0)),this.add(o);const c=new dn(Ci,Li,e,t);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new L(0,0,1)),this.add(c);const l=new dn(Ci,Li,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new L(0,0,-1)),this.add(l)}update(e,t){this.parent===null&&this.updateMatrixWorld();const n=this.renderTarget,[s,i,a,o,c,l]=this.children,u=e.xr.enabled,h=e.getRenderTarget();e.xr.enabled=!1;const d=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0),e.render(t,s),e.setRenderTarget(n,1),e.render(t,i),e.setRenderTarget(n,2),e.render(t,a),e.setRenderTarget(n,3),e.render(t,o),e.setRenderTarget(n,4),e.render(t,c),n.texture.generateMipmaps=d,e.setRenderTarget(n,5),e.render(t,l),e.setRenderTarget(h),e.xr.enabled=u}}class rc extends Vt{constructor(e,t,n,s,i,a,o,c,l,u){e=e!==void 0?e:[],t=t!==void 0?t:wa;super(e,t,n,s,i,a,o,c,l,u);this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}rc.prototype.isCubeTexture=!0;class Y1 extends Rn{constructor(e,t,n){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=n);super(e,e,t);t=t||{},this.texture=new rc(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:gn,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=sn,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},s=new Da(5,5,5),i=new Es({name:"CubemapFromEquirect",uniforms:Ri(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:zt,blending:Dr});i.uniforms.tEquirect.value=t;const a=new $t(s,i),o=t.minFilter;return t.minFilter===li&&(t.minFilter=gn),new Th(1,10,this).update(e,a),t.minFilter=o,a.geometry.dispose(),a.material.dispose(),this}clear(e,t,n,s){const i=e.getRenderTarget();for(let a=0;a<6;a++)e.setRenderTarget(this,a),e.clear(t,n,s);e.setRenderTarget(i)}}Y1.prototype.isWebGLCubeRenderTarget=!0;const Eh=new L,gA=new L,yA=new Qt;class dr{constructor(e=new L(1,0,0),t=0){this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,s){return this.normal.set(e,t,n),this.constant=s,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const s=Eh.subVectors(n,t).cross(gA.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(s,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const n=e.delta(Eh),s=this.normal.dot(n);if(s===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const i=-(e.start.dot(this.normal)+this.constant)/s;return i<0||i>1?null:t.copy(n).multiplyScalar(i).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||yA.getNormalMatrix(e),s=this.coplanarPoint(Eh).applyMatrix4(e),i=this.normal.applyMatrix3(n).normalize();return this.constant=-s.dot(i),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}dr.prototype.isPlane=!0;const ki=new Ts,sc=new L;class ic{constructor(e=new dr,t=new dr,n=new dr,s=new dr,i=new dr,a=new dr){this.planes=[e,t,n,s,i,a]}set(e,t,n,s,i,a){const o=this.planes;return o[0].copy(e),o[1].copy(t),o[2].copy(n),o[3].copy(s),o[4].copy(i),o[5].copy(a),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e){const t=this.planes,n=e.elements,s=n[0],i=n[1],a=n[2],o=n[3],c=n[4],l=n[5],u=n[6],h=n[7],d=n[8],p=n[9],f=n[10],m=n[11],_=n[12],g=n[13],y=n[14],x=n[15];return t[0].setComponents(o-s,h-c,m-d,x-_).normalize(),t[1].setComponents(o+s,h+c,m+d,x+_).normalize(),t[2].setComponents(o+i,h+l,m+p,x+g).normalize(),t[3].setComponents(o-i,h-l,m-p,x-g).normalize(),t[4].setComponents(o-a,h-u,m-f,x-y).normalize(),t[5].setComponents(o+a,h+u,m+f,x+y).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),ki.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(ki)}intersectsSprite(e){return ki.center.set(0,0,0),ki.radius=.7071067811865476,ki.applyMatrix4(e.matrixWorld),this.intersectsSphere(ki)}intersectsSphere(e){const t=this.planes,n=e.center,s=-e.radius;for(let i=0;i<6;i++)if(t[i].distanceToPoint(n)<s)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const s=t[n];if(sc.x=s.normal.x>0?e.max.x:e.min.x,sc.y=s.normal.y>0?e.max.y:e.min.y,sc.z=s.normal.z>0?e.max.z:e.min.z,s.distanceToPoint(sc)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function J1(){let r=null,e=!1,t=null,n=null;function s(i,a){t(i,a),n=r.requestAnimationFrame(s)}return{start:function(){e!==!0&&t!==null&&(n=r.requestAnimationFrame(s),e=!0)},stop:function(){r.cancelAnimationFrame(n),e=!1},setAnimationLoop:function(i){t=i},setContext:function(i){r=i}}}function _A(r,e){const t=e.isWebGL2,n=new WeakMap;function s(l,u){const h=l.array,d=l.usage,p=r.createBuffer();r.bindBuffer(u,p),r.bufferData(u,h,d),l.onUploadCallback();let f=5126;return h instanceof Float32Array?f=5126:h instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):h instanceof Uint16Array?l.isFloat16BufferAttribute?t?f=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):f=5123:h instanceof Int16Array?f=5122:h instanceof Uint32Array?f=5125:h instanceof Int32Array?f=5124:h instanceof Int8Array?f=5120:(h instanceof Uint8Array||h instanceof Uint8ClampedArray)&&(f=5121),{buffer:p,type:f,bytesPerElement:h.BYTES_PER_ELEMENT,version:l.version}}function i(l,u,h){const d=u.array,p=u.updateRange;r.bindBuffer(h,l),p.count===-1?r.bufferSubData(h,0,d):(t?r.bufferSubData(h,p.offset*d.BYTES_PER_ELEMENT,d,p.offset,p.count):r.bufferSubData(h,p.offset*d.BYTES_PER_ELEMENT,d.subarray(p.offset,p.offset+p.count)),p.count=-1)}function a(l){return l.isInterleavedBufferAttribute&&(l=l.data),n.get(l)}function o(l){l.isInterleavedBufferAttribute&&(l=l.data);const u=n.get(l);u&&(r.deleteBuffer(u.buffer),n.delete(l))}function c(l,u){if(l.isGLBufferAttribute){const d=n.get(l);(!d||d.version<l.version)&&n.set(l,{buffer:l.buffer,type:l.type,bytesPerElement:l.elementSize,version:l.version});return}l.isInterleavedBufferAttribute&&(l=l.data);const h=n.get(l);h===void 0?n.set(l,s(l,u)):h.version<l.version&&(i(h.buffer,l,u),h.version=l.version)}return{get:a,remove:o,update:c}}class Di extends yt{constructor(e=1,t=1,n=1,s=1){super();this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:s};const i=e/2,a=t/2,o=Math.floor(n),c=Math.floor(s),l=o+1,u=c+1,h=e/o,d=t/c,p=[],f=[],m=[],_=[];for(let g=0;g<u;g++){const y=g*d-a;for(let x=0;x<l;x++){const w=x*h-i;f.push(w,-y,0),m.push(0,0,1),_.push(x/o),_.push(1-g/c)}}for(let g=0;g<c;g++)for(let y=0;y<o;y++){const x=y+l*g,w=y+l*(g+1),T=y+1+l*(g+1),M=y+1+l*g;p.push(x,w,M),p.push(w,T,M)}this.setIndex(p),this.setAttribute("position",new Nt(f,3)),this.setAttribute("normal",new Nt(m,3)),this.setAttribute("uv",new Nt(_,2))}static fromJSON(e){return new Di(e.width,e.height,e.widthSegments,e.heightSegments)}}var xA=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,bA=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,vA=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,wA=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,SA=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,TA=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,EA="vec3 transformed = vec3( position );",MA=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,AA=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,IA=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,NA=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,RA=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,CA=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,LA=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,kA=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,DA=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,PA=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,FA=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,OA=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,BA=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,zA=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,UA=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,VA=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,HA=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,$A=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,GA="gl_FragColor = linearToOutputTexel( gl_FragColor );",WA=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}`,jA=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		envColor = envMapTexelToLinear( envColor );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,qA=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,KA=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,XA=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,YA=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,JA=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,ZA=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,QA=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,eI=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,tI=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,nI=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,rI=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,sI=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,iI=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,aI=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,oI=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,cI=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,uI=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,lI=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,hI=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,dI=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,pI=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,fI=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,mI=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,gI=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,yI=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,_I=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,xI=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,bI=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,vI=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,wI=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,SI=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,TI=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,EI=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,MI=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,AI=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform vec2 morphTargetsTextureSize;
		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {
			float texelIndex = float( vertexIndex * stride + offset );
			float y = floor( texelIndex / morphTargetsTextureSize.x );
			float x = texelIndex - y * morphTargetsTextureSize.x;
			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );
			return texture( morphTargetsTexture, morphUV ).xyz;
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,II=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			#ifndef USE_MORPHNORMALS
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];
			#else
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];
			#endif
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,NI=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,RI=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,CI=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,LI=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,kI=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,DI=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,PI=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,FI=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,OI=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,BI=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,zI=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,UI=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,VI=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,HI=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,$I=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,GI=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,WI=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,jI=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,qI=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,KI=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,XI=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,YI=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,JI=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,ZI=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,QI=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,eN=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,tN=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,nN=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,rN=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,sN=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,iN=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( float roughness, float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,aN=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,oN=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,cN=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,uN=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,lN=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,hN=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,dN=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const pN=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,fN=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,mN=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,gN=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,yN=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,_N=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,xN=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,bN=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,vN=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,wN=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,SN=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,TN=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,EN=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,MN=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,AN=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,IN=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,NN=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,RN=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,CN=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,LN=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,kN=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,DN=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,PN=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,FN=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,ON=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,BN=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,zN=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,UN=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,VN=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,HN=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,$N=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,GN=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,tt={alphamap_fragment:xA,alphamap_pars_fragment:bA,alphatest_fragment:vA,alphatest_pars_fragment:wA,aomap_fragment:SA,aomap_pars_fragment:TA,begin_vertex:EA,beginnormal_vertex:MA,bsdfs:AA,bumpmap_pars_fragment:IA,clipping_planes_fragment:NA,clipping_planes_pars_fragment:RA,clipping_planes_pars_vertex:CA,clipping_planes_vertex:LA,color_fragment:kA,color_pars_fragment:DA,color_pars_vertex:PA,color_vertex:FA,common:OA,cube_uv_reflection_fragment:BA,defaultnormal_vertex:zA,displacementmap_pars_vertex:UA,displacementmap_vertex:VA,emissivemap_fragment:HA,emissivemap_pars_fragment:$A,encodings_fragment:GA,encodings_pars_fragment:WA,envmap_fragment:jA,envmap_common_pars_fragment:qA,envmap_pars_fragment:KA,envmap_pars_vertex:XA,envmap_physical_pars_fragment:aI,envmap_vertex:YA,fog_vertex:JA,fog_pars_vertex:ZA,fog_fragment:QA,fog_pars_fragment:eI,gradientmap_pars_fragment:tI,lightmap_fragment:nI,lightmap_pars_fragment:rI,lights_lambert_vertex:sI,lights_pars_begin:iI,lights_toon_fragment:oI,lights_toon_pars_fragment:cI,lights_phong_fragment:uI,lights_phong_pars_fragment:lI,lights_physical_fragment:hI,lights_physical_pars_fragment:dI,lights_fragment_begin:pI,lights_fragment_maps:fI,lights_fragment_end:mI,logdepthbuf_fragment:gI,logdepthbuf_pars_fragment:yI,logdepthbuf_pars_vertex:_I,logdepthbuf_vertex:xI,map_fragment:bI,map_pars_fragment:vI,map_particle_fragment:wI,map_particle_pars_fragment:SI,metalnessmap_fragment:TI,metalnessmap_pars_fragment:EI,morphnormal_vertex:MI,morphtarget_pars_vertex:AI,morphtarget_vertex:II,normal_fragment_begin:NI,normal_fragment_maps:RI,normal_pars_fragment:CI,normal_pars_vertex:LI,normal_vertex:kI,normalmap_pars_fragment:DI,clearcoat_normal_fragment_begin:PI,clearcoat_normal_fragment_maps:FI,clearcoat_pars_fragment:OI,output_fragment:BI,packing:zI,premultiplied_alpha_fragment:UI,project_vertex:VI,dithering_fragment:HI,dithering_pars_fragment:$I,roughnessmap_fragment:GI,roughnessmap_pars_fragment:WI,shadowmap_pars_fragment:jI,shadowmap_pars_vertex:qI,shadowmap_vertex:KI,shadowmask_pars_fragment:XI,skinbase_vertex:YI,skinning_pars_vertex:JI,skinning_vertex:ZI,skinnormal_vertex:QI,specularmap_fragment:eN,specularmap_pars_fragment:tN,tonemapping_fragment:nN,tonemapping_pars_fragment:rN,transmission_fragment:sN,transmission_pars_fragment:iN,uv_pars_fragment:aN,uv_pars_vertex:oN,uv_vertex:cN,uv2_pars_fragment:uN,uv2_pars_vertex:lN,uv2_vertex:hN,worldpos_vertex:dN,background_vert:pN,background_frag:fN,cube_vert:mN,cube_frag:gN,depth_vert:yN,depth_frag:_N,distanceRGBA_vert:xN,distanceRGBA_frag:bN,equirect_vert:vN,equirect_frag:wN,linedashed_vert:SN,linedashed_frag:TN,meshbasic_vert:EN,meshbasic_frag:MN,meshlambert_vert:AN,meshlambert_frag:IN,meshmatcap_vert:NN,meshmatcap_frag:RN,meshnormal_vert:CN,meshnormal_frag:LN,meshphong_vert:kN,meshphong_frag:DN,meshphysical_vert:PN,meshphysical_frag:FN,meshtoon_vert:ON,meshtoon_frag:BN,points_vert:zN,points_frag:UN,shadow_vert:VN,shadow_frag:HN,sprite_vert:$N,sprite_frag:GN},Te={common:{diffuse:{value:new Le(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Qt},uv2Transform:{value:new Qt},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new fe(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Le(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Le(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Qt}},sprite:{diffuse:{value:new Le(16777215)},opacity:{value:1},center:{value:new fe(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Qt}}},Kn={basic:{uniforms:an([Te.common,Te.specularmap,Te.envmap,Te.aomap,Te.lightmap,Te.fog]),vertexShader:tt.meshbasic_vert,fragmentShader:tt.meshbasic_frag},lambert:{uniforms:an([Te.common,Te.specularmap,Te.envmap,Te.aomap,Te.lightmap,Te.emissivemap,Te.fog,Te.lights,{emissive:{value:new Le(0)}}]),vertexShader:tt.meshlambert_vert,fragmentShader:tt.meshlambert_frag},phong:{uniforms:an([Te.common,Te.specularmap,Te.envmap,Te.aomap,Te.lightmap,Te.emissivemap,Te.bumpmap,Te.normalmap,Te.displacementmap,Te.fog,Te.lights,{emissive:{value:new Le(0)},specular:{value:new Le(1118481)},shininess:{value:30}}]),vertexShader:tt.meshphong_vert,fragmentShader:tt.meshphong_frag},standard:{uniforms:an([Te.common,Te.envmap,Te.aomap,Te.lightmap,Te.emissivemap,Te.bumpmap,Te.normalmap,Te.displacementmap,Te.roughnessmap,Te.metalnessmap,Te.fog,Te.lights,{emissive:{value:new Le(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:tt.meshphysical_vert,fragmentShader:tt.meshphysical_frag},toon:{uniforms:an([Te.common,Te.aomap,Te.lightmap,Te.emissivemap,Te.bumpmap,Te.normalmap,Te.displacementmap,Te.gradientmap,Te.fog,Te.lights,{emissive:{value:new Le(0)}}]),vertexShader:tt.meshtoon_vert,fragmentShader:tt.meshtoon_frag},matcap:{uniforms:an([Te.common,Te.bumpmap,Te.normalmap,Te.displacementmap,Te.fog,{matcap:{value:null}}]),vertexShader:tt.meshmatcap_vert,fragmentShader:tt.meshmatcap_frag},points:{uniforms:an([Te.points,Te.fog]),vertexShader:tt.points_vert,fragmentShader:tt.points_frag},dashed:{uniforms:an([Te.common,Te.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:tt.linedashed_vert,fragmentShader:tt.linedashed_frag},depth:{uniforms:an([Te.common,Te.displacementmap]),vertexShader:tt.depth_vert,fragmentShader:tt.depth_frag},normal:{uniforms:an([Te.common,Te.bumpmap,Te.normalmap,Te.displacementmap,{opacity:{value:1}}]),vertexShader:tt.meshnormal_vert,fragmentShader:tt.meshnormal_frag},sprite:{uniforms:an([Te.sprite,Te.fog]),vertexShader:tt.sprite_vert,fragmentShader:tt.sprite_frag},background:{uniforms:{uvTransform:{value:new Qt},t2D:{value:null}},vertexShader:tt.background_vert,fragmentShader:tt.background_frag},cube:{uniforms:an([Te.envmap,{opacity:{value:1}}]),vertexShader:tt.cube_vert,fragmentShader:tt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:tt.equirect_vert,fragmentShader:tt.equirect_frag},distanceRGBA:{uniforms:an([Te.common,Te.displacementmap,{referencePosition:{value:new L},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:tt.distanceRGBA_vert,fragmentShader:tt.distanceRGBA_frag},shadow:{uniforms:an([Te.lights,Te.fog,{color:{value:new Le(0)},opacity:{value:1}}]),vertexShader:tt.shadow_vert,fragmentShader:tt.shadow_frag}};Kn.physical={uniforms:an([Kn.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new fe(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new Le(0)},sheenColorMap:{value:null},sheenRoughness:{value:0},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new fe},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Le(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularColor:{value:new Le(1,1,1)},specularColorMap:{value:null}}]),vertexShader:tt.meshphysical_vert,fragmentShader:tt.meshphysical_frag};function WN(r,e,t,n,s){const i=new Le(0);let a=0,o,c,l=null,u=0,h=null;function d(f,m){let _=!1,g=m.isScene===!0?m.background:null;g&&g.isTexture&&(g=e.get(g));const y=r.xr,x=y.getSession&&y.getSession();x&&x.environmentBlendMode==="additive"&&(g=null),g===null?p(i,a):g&&g.isColor&&(p(g,1),_=!0),(r.autoClear||_)&&r.clear(r.autoClearColor,r.autoClearDepth,r.autoClearStencil),g&&(g.isCubeTexture||g.mapping===Do)?(c===void 0&&(c=new $t(new Da(1,1,1),new Es({name:"BackgroundCubeMaterial",uniforms:Ri(Kn.cube.uniforms),vertexShader:Kn.cube.vertexShader,fragmentShader:Kn.cube.fragmentShader,side:zt,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),c.geometry.deleteAttribute("uv"),c.onBeforeRender=function(w,T,M){this.matrixWorld.copyPosition(M.matrixWorld)},Object.defineProperty(c.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),n.update(c)),c.material.uniforms.envMap.value=g,c.material.uniforms.flipEnvMap.value=g.isCubeTexture&&g.isRenderTargetTexture===!1?-1:1,(l!==g||u!==g.version||h!==r.toneMapping)&&(c.material.needsUpdate=!0,l=g,u=g.version,h=r.toneMapping),f.unshift(c,c.geometry,c.material,0,0,null)):g&&g.isTexture&&(o===void 0&&(o=new $t(new Di(2,2),new Es({name:"BackgroundMaterial",uniforms:Ri(Kn.background.uniforms),vertexShader:Kn.background.vertexShader,fragmentShader:Kn.background.fragmentShader,side:oi,depthTest:!1,depthWrite:!1,fog:!1})),o.geometry.deleteAttribute("normal"),Object.defineProperty(o.material,"map",{get:function(){return this.uniforms.t2D.value}}),n.update(o)),o.material.uniforms.t2D.value=g,g.matrixAutoUpdate===!0&&g.updateMatrix(),o.material.uniforms.uvTransform.value.copy(g.matrix),(l!==g||u!==g.version||h!==r.toneMapping)&&(o.material.needsUpdate=!0,l=g,u=g.version,h=r.toneMapping),f.unshift(o,o.geometry,o.material,0,0,null))}function p(f,m){t.buffers.color.setClear(f.r,f.g,f.b,m,s)}return{getClearColor:function(){return i},setClearColor:function(f,m=1){i.set(f),a=m,p(i,a)},getClearAlpha:function(){return a},setClearAlpha:function(f){a=f,p(i,a)},render:d}}function jN(r,e,t,n){const s=r.getParameter(34921),i=n.isWebGL2?null:e.get("OES_vertex_array_object"),a=n.isWebGL2||i!==null,o={},c=m(null);let l=c;function u(B,H,U,j,K){let se=!1;if(a){const ue=f(j,U,H);l!==ue&&(l=ue,d(l.object)),se=_(j,K),se&&g(j,K)}else{const ue=H.wireframe===!0;(l.geometry!==j.id||l.program!==U.id||l.wireframe!==ue)&&(l.geometry=j.id,l.program=U.id,l.wireframe=ue,se=!0)}B.isInstancedMesh===!0&&(se=!0),K!==null&&t.update(K,34963),se&&(S(B,H,U,j),K!==null&&r.bindBuffer(34963,t.get(K).buffer))}function h(){return n.isWebGL2?r.createVertexArray():i.createVertexArrayOES()}function d(B){return n.isWebGL2?r.bindVertexArray(B):i.bindVertexArrayOES(B)}function p(B){return n.isWebGL2?r.deleteVertexArray(B):i.deleteVertexArrayOES(B)}function f(B,H,U){const j=U.wireframe===!0;let K=o[B.id];K===void 0&&(K={},o[B.id]=K);let se=K[H.id];se===void 0&&(se={},K[H.id]=se);let ue=se[j];return ue===void 0&&(ue=m(h()),se[j]=ue),ue}function m(B){const H=[],U=[],j=[];for(let K=0;K<s;K++)H[K]=0,U[K]=0,j[K]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:H,enabledAttributes:U,attributeDivisors:j,object:B,attributes:{},index:null}}function _(B,H){const U=l.attributes,j=B.attributes;let K=0;for(const se in j){const ue=U[se],Q=j[se];if(ue===void 0||ue.attribute!==Q||ue.data!==Q.data)return!0;K++}return l.attributesNum!==K||l.index!==H}function g(B,H){const U={},j=B.attributes;let K=0;for(const se in j){const ue=j[se],Q={};Q.attribute=ue,ue.data&&(Q.data=ue.data),U[se]=Q,K++}l.attributes=U,l.attributesNum=K,l.index=H}function y(){const B=l.newAttributes;for(let H=0,U=B.length;H<U;H++)B[H]=0}function x(B){w(B,0)}function w(B,H){const U=l.newAttributes,j=l.enabledAttributes,K=l.attributeDivisors;U[B]=1,j[B]===0&&(r.enableVertexAttribArray(B),j[B]=1),K[B]!==H&&((n.isWebGL2?r:e.get("ANGLE_instanced_arrays"))[n.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](B,H),K[B]=H)}function T(){const B=l.newAttributes,H=l.enabledAttributes;for(let U=0,j=H.length;U<j;U++)H[U]!==B[U]&&(r.disableVertexAttribArray(U),H[U]=0)}function M(B,H,U,j,K,se){n.isWebGL2===!0&&(U===5124||U===5125)?r.vertexAttribIPointer(B,H,U,K,se):r.vertexAttribPointer(B,H,U,j,K,se)}function S(B,H,U,j){if(n.isWebGL2===!1&&(B.isInstancedMesh||j.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;y();const K=j.attributes,se=U.getAttributes(),ue=H.defaultAttributeValues;for(const Q in se){const ee=se[Q];if(ee.location>=0){let ge=K[Q];if(ge===void 0&&(Q==="instanceMatrix"&&B.instanceMatrix&&(ge=B.instanceMatrix),Q==="instanceColor"&&B.instanceColor&&(ge=B.instanceColor)),ge!==void 0){const he=ge.normalized,Me=ge.itemSize,je=t.get(ge);if(je===void 0)continue;const ae=je.buffer,Ve=je.type,He=je.bytesPerElement;if(ge.isInterleavedBufferAttribute){const Re=ge.data,ze=Re.stride,Ye=ge.offset;if(Re&&Re.isInstancedInterleavedBuffer){for(let te=0;te<ee.locationSize;te++)w(ee.location+te,Re.meshPerAttribute);B.isInstancedMesh!==!0&&j._maxInstanceCount===void 0&&(j._maxInstanceCount=Re.meshPerAttribute*Re.count)}else for(let te=0;te<ee.locationSize;te++)x(ee.location+te);r.bindBuffer(34962,ae);for(let te=0;te<ee.locationSize;te++)M(ee.location+te,Me/ee.locationSize,Ve,he,ze*He,(Ye+Me/ee.locationSize*te)*He)}else{if(ge.isInstancedBufferAttribute){for(let Re=0;Re<ee.locationSize;Re++)w(ee.location+Re,ge.meshPerAttribute);B.isInstancedMesh!==!0&&j._maxInstanceCount===void 0&&(j._maxInstanceCount=ge.meshPerAttribute*ge.count)}else for(let Re=0;Re<ee.locationSize;Re++)x(ee.location+Re);r.bindBuffer(34962,ae);for(let Re=0;Re<ee.locationSize;Re++)M(ee.location+Re,Me/ee.locationSize,Ve,he,Me*He,Me/ee.locationSize*Re*He)}}else if(ue!==void 0){const he=ue[Q];if(he!==void 0)switch(he.length){case 2:r.vertexAttrib2fv(ee.location,he);break;case 3:r.vertexAttrib3fv(ee.location,he);break;case 4:r.vertexAttrib4fv(ee.location,he);break;default:r.vertexAttrib1fv(ee.location,he)}}}}T()}function R(){A();for(const B in o){const H=o[B];for(const U in H){const j=H[U];for(const K in j)p(j[K].object),delete j[K];delete H[U]}delete o[B]}}function k(B){if(o[B.id]===void 0)return;const H=o[B.id];for(const U in H){const j=H[U];for(const K in j)p(j[K].object),delete j[K];delete H[U]}delete o[B.id]}function O(B){for(const H in o){const U=o[H];if(U[B.id]===void 0)continue;const j=U[B.id];for(const K in j)p(j[K].object),delete j[K];delete U[B.id]}}function A(){Y(),l!==c&&(l=c,d(l.object))}function Y(){c.geometry=null,c.program=null,c.wireframe=!1}return{setup:u,reset:A,resetDefaultState:Y,dispose:R,releaseStatesOfGeometry:k,releaseStatesOfProgram:O,initAttributes:y,enableAttribute:x,disableUnusedAttributes:T}}function qN(r,e,t,n){const s=n.isWebGL2;let i;function a(l){i=l}function o(l,u){r.drawArrays(i,l,u),t.update(u,i,1)}function c(l,u,h){if(h===0)return;let d,p;if(s)d=r,p="drawArraysInstanced";else if(d=e.get("ANGLE_instanced_arrays"),p="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[p](i,l,u,h),t.update(u,i,h)}this.setMode=a,this.render=o,this.renderInstances=c}function KN(r,e,t){let n;function s(){if(n!==void 0)return n;if(e.has("EXT_texture_filter_anisotropic")===!0){const S=e.get("EXT_texture_filter_anisotropic");n=r.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else n=0;return n}function i(S){if(S==="highp"){if(r.getShaderPrecisionFormat(35633,36338).precision>0&&r.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";S="mediump"}return S==="mediump"&&r.getShaderPrecisionFormat(35633,36337).precision>0&&r.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const a=typeof WebGL2RenderingContext!="undefined"&&r instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&r instanceof WebGL2ComputeRenderingContext;let o=t.precision!==void 0?t.precision:"highp";const c=i(o);c!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",c,"instead."),o=c);const l=a||e.has("WEBGL_draw_buffers"),u=t.logarithmicDepthBuffer===!0,h=r.getParameter(34930),d=r.getParameter(35660),p=r.getParameter(3379),f=r.getParameter(34076),m=r.getParameter(34921),_=r.getParameter(36347),g=r.getParameter(36348),y=r.getParameter(36349),x=d>0,w=a||e.has("OES_texture_float"),T=x&&w,M=a?r.getParameter(36183):0;return{isWebGL2:a,drawBuffers:l,getMaxAnisotropy:s,getMaxPrecision:i,precision:o,logarithmicDepthBuffer:u,maxTextures:h,maxVertexTextures:d,maxTextureSize:p,maxCubemapSize:f,maxAttributes:m,maxVertexUniforms:_,maxVaryings:g,maxFragmentUniforms:y,vertexTextures:x,floatFragmentTextures:w,floatVertexTextures:T,maxSamples:M}}function XN(r){const e=this;let t=null,n=0,s=!1,i=!1;const a=new dr,o=new Qt,c={value:null,needsUpdate:!1};this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(h,d,p){const f=h.length!==0||d||n!==0||s;return s=d,t=u(h,p,0),n=h.length,f},this.beginShadows=function(){i=!0,u(null)},this.endShadows=function(){i=!1,l()},this.setState=function(h,d,p){const f=h.clippingPlanes,m=h.clipIntersection,_=h.clipShadows,g=r.get(h);if(!s||f===null||f.length===0||i&&!_)i?u(null):l();else{const y=i?0:n,x=y*4;let w=g.clippingState||null;c.value=w,w=u(f,d,x,p);for(let T=0;T!==x;++T)w[T]=t[T];g.clippingState=w,this.numIntersection=m?this.numPlanes:0,this.numPlanes+=y}};function l(){c.value!==t&&(c.value=t,c.needsUpdate=n>0),e.numPlanes=n,e.numIntersection=0}function u(h,d,p,f){const m=h!==null?h.length:0;let _=null;if(m!==0){if(_=c.value,f!==!0||_===null){const g=p+m*4,y=d.matrixWorldInverse;o.getNormalMatrix(y),(_===null||_.length<g)&&(_=new Float32Array(g));for(let x=0,w=p;x!==m;++x,w+=4)a.copy(h[x]).applyMatrix4(y,o),a.normal.toArray(_,w),_[w+3]=a.constant}c.value=_,c.needsUpdate=!0}return e.numPlanes=m,e.numIntersection=0,_}}function YN(r){let e=new WeakMap;function t(a,o){return o===Hl?a.mapping=wa:o===$l&&(a.mapping=Sa),a}function n(a){if(a&&a.isTexture&&a.isRenderTargetTexture===!1){const o=a.mapping;if(o===Hl||o===$l)if(e.has(a)){const c=e.get(a).texture;return t(c,a.mapping)}else{const c=a.image;if(c&&c.height>0){const l=r.getRenderTarget(),u=new Y1(c.height/2);return u.fromEquirectangularTexture(r,a),e.set(a,u),r.setRenderTarget(l),a.addEventListener("dispose",s),t(u.texture,a.mapping)}else return null}}return a}function s(a){const o=a.target;o.removeEventListener("dispose",s);const c=e.get(o);c!==void 0&&(e.delete(o),c.dispose())}function i(){e=new WeakMap}return{get:n,dispose:i}}class Pa extends Sh{constructor(e=-1,t=1,n=1,s=-1,i=.1,a=2e3){super();this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=s,this.near=i,this.far=a,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,n,s,i,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=s,this.view.width=i,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,s=(this.top+this.bottom)/2;let i=n-e,a=n+e,o=s+t,c=s-t;if(this.view!==null&&this.view.enabled){const l=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=l*this.view.offsetX,a=i+l*this.view.width,o-=u*this.view.offsetY,c=o-u*this.view.height}this.projectionMatrix.makeOrthographic(i,a,o,c,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}Pa.prototype.isOrthographicCamera=!0;class ac extends Es{constructor(e){super(e);this.type="RawShaderMaterial"}}ac.prototype.isRawShaderMaterial=!0;const Pi=4,Wr=8,Xn=Math.pow(2,Wr),Z1=[.125,.215,.35,.446,.526,.582],Q1=Wr-Pi+1+Z1.length,Fi=20,Ms={[yn]:0,[Or]:1,[Yl]:2,[I1]:3,[N1]:4,[R1]:5,[Xl]:6},Mh=new Pa,{_lodPlanes:Fa,_sizeLods:eg,_sigmas:oc}=QN(),tg=new Le;let Ah=null;const As=(1+Math.sqrt(5))/2,Oi=1/As,ng=[new L(1,1,1),new L(-1,1,1),new L(1,1,-1),new L(-1,1,-1),new L(0,As,Oi),new L(0,As,-Oi),new L(Oi,0,As),new L(-Oi,0,As),new L(As,Oi,0),new L(-As,Oi,0)];class JN{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=eR(Fi),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,s=100){Ah=this._renderer.getRenderTarget();const i=this._allocateTargets();return this._sceneToCubeUV(e,n,s,i),t>0&&this._blur(i,0,0,t),this._applyPMREM(i),this._cleanup(i),i}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=ig(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=sg(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let e=0;e<Fa.length;e++)Fa[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(Ah),e.scissorTest=!1,cc(e,0,0,e.width,e.height)}_fromTexture(e){Ah=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){const t={magFilter:Ut,minFilter:Ut,generateMipmaps:!1,type:Pr,format:qE,encoding:ZN(e)?e.encoding:Yl,depthBuffer:!1},n=rg(t);return n.depthBuffer=!e,this._pingPongRenderTarget=rg(t),n}_compileMaterial(e){const t=new $t(Fa[0],e);this._renderer.compile(t,Mh)}_sceneToCubeUV(e,t,n,s){const i=90,a=1,o=new dn(i,a,t,n),c=[1,-1,1,1,1,1],l=[1,1,1,-1,-1,-1],u=this._renderer,h=u.autoClear,d=u.outputEncoding,p=u.toneMapping;u.getClearColor(tg),u.toneMapping=_s,u.outputEncoding=yn,u.autoClear=!1;const f=new qn({name:"PMREM.Background",side:zt,depthWrite:!1,depthTest:!1}),m=new $t(new Da,f);let _=!1;const g=e.background;g?g.isColor&&(f.color.copy(g),e.background=null,_=!0):(f.color.copy(tg),_=!0);for(let y=0;y<6;y++){const x=y%3;x==0?(o.up.set(0,c[y],0),o.lookAt(l[y],0,0)):x==1?(o.up.set(0,0,c[y]),o.lookAt(0,l[y],0)):(o.up.set(0,c[y],0),o.lookAt(0,0,l[y])),cc(s,x*Xn,y>2?Xn:0,Xn,Xn),u.setRenderTarget(s),_&&u.render(m,o),u.render(e,o)}m.geometry.dispose(),m.material.dispose(),u.toneMapping=p,u.outputEncoding=d,u.autoClear=h,e.background=g}_setEncoding(e,t){e.value=Ms[t.encoding]}_textureToCubeUV(e,t){const n=this._renderer,s=e.mapping===wa||e.mapping===Sa;s?this._cubemapShader==null&&(this._cubemapShader=ig()):this._equirectShader==null&&(this._equirectShader=sg());const i=s?this._cubemapShader:this._equirectShader,a=new $t(Fa[0],i),o=i.uniforms;o.envMap.value=e,s||o.texelSize.value.set(1/e.image.width,1/e.image.height),this._setEncoding(o.inputEncoding,e),this._setEncoding(o.outputEncoding,t.texture),cc(t,0,0,3*Xn,2*Xn),n.setRenderTarget(t),n.render(a,Mh)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;for(let s=1;s<Q1;s++){const i=Math.sqrt(oc[s]*oc[s]-oc[s-1]*oc[s-1]),a=ng[(s-1)%ng.length];this._blur(e,s-1,s,i,a)}t.autoClear=n}_blur(e,t,n,s,i){const a=this._pingPongRenderTarget;this._halfBlur(e,a,t,n,s,"latitudinal",i),this._halfBlur(a,e,n,n,s,"longitudinal",i)}_halfBlur(e,t,n,s,i,a,o){const c=this._renderer,l=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,h=new $t(Fa[s],l),d=l.uniforms,p=eg[n]-1,f=isFinite(i)?Math.PI/(2*p):2*Math.PI/(2*Fi-1),m=i/f,_=isFinite(i)?1+Math.floor(u*m):Fi;_>Fi&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${_} samples when the maximum is set to ${Fi}`);const g=[];let y=0;for(let M=0;M<Fi;++M){const S=M/m,R=Math.exp(-S*S/2);g.push(R),M==0?y+=R:M<_&&(y+=2*R)}for(let M=0;M<g.length;M++)g[M]=g[M]/y;d.envMap.value=e.texture,d.samples.value=_,d.weights.value=g,d.latitudinal.value=a==="latitudinal",o&&(d.poleAxis.value=o),d.dTheta.value=f,d.mipInt.value=Wr-n,this._setEncoding(d.inputEncoding,e.texture),this._setEncoding(d.outputEncoding,e.texture);const x=eg[s],w=3*Math.max(0,Xn-2*x),T=(s===0?0:2*Xn)+2*x*(s>Wr-Pi?s-Wr+Pi:0);cc(t,w,T,3*x,2*x),c.setRenderTarget(t),c.render(h,Mh)}}function ZN(r){return r===void 0||r.type!==Pr?!1:r.encoding===yn||r.encoding===Or||r.encoding===Xl}function QN(){const r=[],e=[],t=[];let n=Wr;for(let s=0;s<Q1;s++){const i=Math.pow(2,n);e.push(i);let a=1/i;s>Wr-Pi?a=Z1[s-Wr+Pi-1]:s==0&&(a=0),t.push(a);const o=1/(i-1),c=-o/2,l=1+o/2,u=[c,c,l,c,l,l,c,c,l,l,c,l],h=6,d=6,p=3,f=2,m=1,_=new Float32Array(p*d*h),g=new Float32Array(f*d*h),y=new Float32Array(m*d*h);for(let w=0;w<h;w++){const T=w%3*2/3-1,M=w>2?0:-1,S=[T,M,0,T+2/3,M,0,T+2/3,M+1,0,T,M,0,T+2/3,M+1,0,T,M+1,0];_.set(S,p*d*w),g.set(u,f*d*w);const R=[w,w,w,w,w,w];y.set(R,m*d*w)}const x=new yt;x.setAttribute("position",new It(_,p)),x.setAttribute("uv",new It(g,f)),x.setAttribute("faceIndex",new It(y,m)),r.push(x),n>Pi&&n--}return{_lodPlanes:r,_sizeLods:e,_sigmas:t}}function rg(r){const e=new Rn(3*Xn,3*Xn,r);return e.texture.mapping=Do,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function cc(r,e,t,n,s){r.viewport.set(e,t,n,s),r.scissor.set(e,t,n,s)}function eR(r){const e=new Float32Array(r),t=new L(0,1,0);return new ac({name:"SphericalGaussianBlur",defines:{n:r},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:t},inputEncoding:{value:Ms[yn]},outputEncoding:{value:Ms[yn]}},vertexShader:Ih(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Nh()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Dr,depthTest:!1,depthWrite:!1})}function sg(){const r=new fe(1,1);return new ac({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:r},inputEncoding:{value:Ms[yn]},outputEncoding:{value:Ms[yn]}},vertexShader:Ih(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Nh()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Dr,depthTest:!1,depthWrite:!1})}function ig(){return new ac({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:Ms[yn]},outputEncoding:{value:Ms[yn]}},vertexShader:Ih(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Nh()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Dr,depthTest:!1,depthWrite:!1})}function Ih(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function Nh(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function tR(r){let e=new WeakMap,t=null;function n(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const c=o.mapping,l=c===Hl||c===$l,u=c===wa||c===Sa;if(l||u){if(e.has(o))return e.get(o).texture;{const h=o.image;if(l&&h&&h.height>0||u&&h&&s(h)){const d=r.getRenderTarget();t===null&&(t=new JN(r));const p=l?t.fromEquirectangular(o):t.fromCubemap(o);return e.set(o,p),r.setRenderTarget(d),o.addEventListener("dispose",i),p.texture}else return null}}}return o}function s(o){let c=0;const l=6;for(let u=0;u<l;u++)o[u]!==void 0&&c++;return c===l}function i(o){const c=o.target;c.removeEventListener("dispose",i);const l=e.get(c);l!==void 0&&(e.delete(c),l.dispose())}function a(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:n,dispose:a}}function nR(r){const e={};function t(n){if(e[n]!==void 0)return e[n];let s;switch(n){case"WEBGL_depth_texture":s=r.getExtension("WEBGL_depth_texture")||r.getExtension("MOZ_WEBGL_depth_texture")||r.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":s=r.getExtension("EXT_texture_filter_anisotropic")||r.getExtension("MOZ_EXT_texture_filter_anisotropic")||r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":s=r.getExtension("WEBGL_compressed_texture_s3tc")||r.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":s=r.getExtension("WEBGL_compressed_texture_pvrtc")||r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:s=r.getExtension(n)}return e[n]=s,s}return{has:function(n){return t(n)!==null},init:function(n){n.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(n){const s=t(n);return s===null&&console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),s}}}function rR(r,e,t,n){const s={},i=new WeakMap;function a(h){const d=h.target;d.index!==null&&e.remove(d.index);for(const f in d.attributes)e.remove(d.attributes[f]);d.removeEventListener("dispose",a),delete s[d.id];const p=i.get(d);p&&(e.remove(p),i.delete(d)),n.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function o(h,d){return s[d.id]===!0||(d.addEventListener("dispose",a),s[d.id]=!0,t.memory.geometries++),d}function c(h){const d=h.attributes;for(const f in d)e.update(d[f],34962);const p=h.morphAttributes;for(const f in p){const m=p[f];for(let _=0,g=m.length;_<g;_++)e.update(m[_],34962)}}function l(h){const d=[],p=h.index,f=h.attributes.position;let m=0;if(p!==null){const y=p.array;m=p.version;for(let x=0,w=y.length;x<w;x+=3){const T=y[x+0],M=y[x+1],S=y[x+2];d.push(T,M,M,S,S,T)}}else{const y=f.array;m=f.version;for(let x=0,w=y.length/3-1;x<w;x+=3){const T=x+0,M=x+1,S=x+2;d.push(T,M,M,S,S,T)}}const _=new(D1(d)>65535?K1:q1)(d,1);_.version=m;const g=i.get(h);g&&e.remove(g),i.set(h,_)}function u(h){const d=i.get(h);if(d){const p=h.index;p!==null&&d.version<p.version&&l(h)}else l(h);return i.get(h)}return{get:o,update:c,getWireframeAttribute:u}}function sR(r,e,t,n){const s=n.isWebGL2;let i;function a(d){i=d}let o,c;function l(d){o=d.type,c=d.bytesPerElement}function u(d,p){r.drawElements(i,p,o,d*c),t.update(p,i,1)}function h(d,p,f){if(f===0)return;let m,_;if(s)m=r,_="drawElementsInstanced";else if(m=e.get("ANGLE_instanced_arrays"),_="drawElementsInstancedANGLE",m===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[_](i,p,o,d*c,f),t.update(p,i,f)}this.setMode=a,this.setIndex=l,this.render=u,this.renderInstances=h}function iR(r){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function n(i,a,o){switch(t.calls++,a){case 4:t.triangles+=o*(i/3);break;case 1:t.lines+=o*(i/2);break;case 3:t.lines+=o*(i-1);break;case 2:t.lines+=o*i;break;case 0:t.points+=o*i;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function s(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:s,update:n}}class Rh extends Vt{constructor(e=null,t=1,n=1,s=1){super(null);this.image={data:e,width:t,height:n,depth:s},this.magFilter=Ut,this.minFilter=Ut,this.wrapR=mn,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Rh.prototype.isDataTexture2DArray=!0;function aR(r,e){return r[0]-e[0]}function oR(r,e){return Math.abs(e[1])-Math.abs(r[1])}function ag(r,e){let t=1;const n=e.isInterleavedBufferAttribute?e.data.array:e.array;n instanceof Int8Array?t=127:n instanceof Int16Array?t=32767:n instanceof Int32Array?t=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",n),r.divideScalar(t)}function cR(r,e,t){const n={},s=new Float32Array(8),i=new WeakMap,a=new L,o=[];for(let l=0;l<8;l++)o[l]=[l,0];function c(l,u,h,d){const p=l.morphTargetInfluences;if(e.isWebGL2===!0){const f=u.morphAttributes.position.length;let m=i.get(u);if(m===void 0||m.count!==f){m!==void 0&&m.texture.dispose();const y=u.morphAttributes.normal!==void 0,x=u.morphAttributes.position,w=u.morphAttributes.normal||[],T=u.attributes.position.count,M=y===!0?2:1;let S=T*M,R=1;S>e.maxTextureSize&&(R=Math.ceil(S/e.maxTextureSize),S=e.maxTextureSize);const k=new Float32Array(S*R*4*f),O=new Rh(k,S,R,f);O.format=sn,O.type=ar;const A=M*4;for(let Y=0;Y<f;Y++){const B=x[Y],H=w[Y],U=S*R*4*Y;for(let j=0;j<B.count;j++){a.fromBufferAttribute(B,j),B.normalized===!0&&ag(a,B);const K=j*A;k[U+K+0]=a.x,k[U+K+1]=a.y,k[U+K+2]=a.z,k[U+K+3]=0,y===!0&&(a.fromBufferAttribute(H,j),H.normalized===!0&&ag(a,H),k[U+K+4]=a.x,k[U+K+5]=a.y,k[U+K+6]=a.z,k[U+K+7]=0)}}m={count:f,texture:O,size:new fe(S,R)},i.set(u,m)}let _=0;for(let y=0;y<p.length;y++)_+=p[y];const g=u.morphTargetsRelative?1:1-_;d.getUniforms().setValue(r,"morphTargetBaseInfluence",g),d.getUniforms().setValue(r,"morphTargetInfluences",p),d.getUniforms().setValue(r,"morphTargetsTexture",m.texture,t),d.getUniforms().setValue(r,"morphTargetsTextureSize",m.size)}else{const f=p===void 0?0:p.length;let m=n[u.id];if(m===void 0||m.length!==f){m=[];for(let w=0;w<f;w++)m[w]=[w,0];n[u.id]=m}for(let w=0;w<f;w++){const T=m[w];T[0]=w,T[1]=p[w]}m.sort(oR);for(let w=0;w<8;w++)w<f&&m[w][1]?(o[w][0]=m[w][0],o[w][1]=m[w][1]):(o[w][0]=Number.MAX_SAFE_INTEGER,o[w][1]=0);o.sort(aR);const _=u.morphAttributes.position,g=u.morphAttributes.normal;let y=0;for(let w=0;w<8;w++){const T=o[w],M=T[0],S=T[1];M!==Number.MAX_SAFE_INTEGER&&S?(_&&u.getAttribute("morphTarget"+w)!==_[M]&&u.setAttribute("morphTarget"+w,_[M]),g&&u.getAttribute("morphNormal"+w)!==g[M]&&u.setAttribute("morphNormal"+w,g[M]),s[w]=S,y+=S):(_&&u.hasAttribute("morphTarget"+w)===!0&&u.deleteAttribute("morphTarget"+w),g&&u.hasAttribute("morphNormal"+w)===!0&&u.deleteAttribute("morphNormal"+w),s[w]=0)}const x=u.morphTargetsRelative?1:1-y;d.getUniforms().setValue(r,"morphTargetBaseInfluence",x),d.getUniforms().setValue(r,"morphTargetInfluences",s)}}return{update:c}}function uR(r,e,t,n){let s=new WeakMap;function i(c){const l=n.render.frame,u=c.geometry,h=e.get(c,u);return s.get(h)!==l&&(e.update(h),s.set(h,l)),c.isInstancedMesh&&(c.hasEventListener("dispose",o)===!1&&c.addEventListener("dispose",o),t.update(c.instanceMatrix,34962),c.instanceColor!==null&&t.update(c.instanceColor,34962)),h}function a(){s=new WeakMap}function o(c){const l=c.target;l.removeEventListener("dispose",o),t.remove(l.instanceMatrix),l.instanceColor!==null&&t.remove(l.instanceColor)}return{update:i,dispose:a}}class og extends Vt{constructor(e=null,t=1,n=1,s=1){super(null);this.image={data:e,width:t,height:n,depth:s},this.magFilter=Ut,this.minFilter=Ut,this.wrapR=mn,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}og.prototype.isDataTexture3D=!0;const cg=new Vt,ug=new Rh,lg=new og,hg=new rc,dg=[],pg=[],fg=new Float32Array(16),mg=new Float32Array(9),gg=new Float32Array(4);function Bi(r,e,t){const n=r[0];if(n<=0||n>0)return r;const s=e*t;let i=dg[s];if(i===void 0&&(i=new Float32Array(s),dg[s]=i),e!==0){n.toArray(i,0);for(let a=1,o=0;a!==e;++a)o+=t,r[a].toArray(i,o)}return i}function pn(r,e){if(r.length!==e.length)return!1;for(let t=0,n=r.length;t<n;t++)if(r[t]!==e[t])return!1;return!0}function on(r,e){for(let t=0,n=e.length;t<n;t++)r[t]=e[t]}function uc(r,e){let t=pg[e];t===void 0&&(t=new Int32Array(e),pg[e]=t);for(let n=0;n!==e;++n)t[n]=r.allocateTextureUnit();return t}function lR(r,e){const t=this.cache;t[0]!==e&&(r.uniform1f(this.addr,e),t[0]=e)}function hR(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(r.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(pn(t,e))return;r.uniform2fv(this.addr,e),on(t,e)}}function dR(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(r.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(r.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(pn(t,e))return;r.uniform3fv(this.addr,e),on(t,e)}}function pR(r,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(r.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(pn(t,e))return;r.uniform4fv(this.addr,e),on(t,e)}}function fR(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(pn(t,e))return;r.uniformMatrix2fv(this.addr,!1,e),on(t,e)}else{if(pn(t,n))return;gg.set(n),r.uniformMatrix2fv(this.addr,!1,gg),on(t,n)}}function mR(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(pn(t,e))return;r.uniformMatrix3fv(this.addr,!1,e),on(t,e)}else{if(pn(t,n))return;mg.set(n),r.uniformMatrix3fv(this.addr,!1,mg),on(t,n)}}function gR(r,e){const t=this.cache,n=e.elements;if(n===void 0){if(pn(t,e))return;r.uniformMatrix4fv(this.addr,!1,e),on(t,e)}else{if(pn(t,n))return;fg.set(n),r.uniformMatrix4fv(this.addr,!1,fg),on(t,n)}}function yR(r,e){const t=this.cache;t[0]!==e&&(r.uniform1i(this.addr,e),t[0]=e)}function _R(r,e){const t=this.cache;pn(t,e)||(r.uniform2iv(this.addr,e),on(t,e))}function xR(r,e){const t=this.cache;pn(t,e)||(r.uniform3iv(this.addr,e),on(t,e))}function bR(r,e){const t=this.cache;pn(t,e)||(r.uniform4iv(this.addr,e),on(t,e))}function vR(r,e){const t=this.cache;t[0]!==e&&(r.uniform1ui(this.addr,e),t[0]=e)}function wR(r,e){const t=this.cache;pn(t,e)||(r.uniform2uiv(this.addr,e),on(t,e))}function SR(r,e){const t=this.cache;pn(t,e)||(r.uniform3uiv(this.addr,e),on(t,e))}function TR(r,e){const t=this.cache;pn(t,e)||(r.uniform4uiv(this.addr,e),on(t,e))}function ER(r,e,t){const n=this.cache,s=t.allocateTextureUnit();n[0]!==s&&(r.uniform1i(this.addr,s),n[0]=s),t.safeSetTexture2D(e||cg,s)}function MR(r,e,t){const n=this.cache,s=t.allocateTextureUnit();n[0]!==s&&(r.uniform1i(this.addr,s),n[0]=s),t.setTexture3D(e||lg,s)}function AR(r,e,t){const n=this.cache,s=t.allocateTextureUnit();n[0]!==s&&(r.uniform1i(this.addr,s),n[0]=s),t.safeSetTextureCube(e||hg,s)}function IR(r,e,t){const n=this.cache,s=t.allocateTextureUnit();n[0]!==s&&(r.uniform1i(this.addr,s),n[0]=s),t.setTexture2DArray(e||ug,s)}function NR(r){switch(r){case 5126:return lR;case 35664:return hR;case 35665:return dR;case 35666:return pR;case 35674:return fR;case 35675:return mR;case 35676:return gR;case 5124:case 35670:return yR;case 35667:case 35671:return _R;case 35668:case 35672:return xR;case 35669:case 35673:return bR;case 5125:return vR;case 36294:return wR;case 36295:return SR;case 36296:return TR;case 35678:case 36198:case 36298:case 36306:case 35682:return ER;case 35679:case 36299:case 36307:return MR;case 35680:case 36300:case 36308:case 36293:return AR;case 36289:case 36303:case 36311:case 36292:return IR}}function RR(r,e){r.uniform1fv(this.addr,e)}function CR(r,e){const t=Bi(e,this.size,2);r.uniform2fv(this.addr,t)}function LR(r,e){const t=Bi(e,this.size,3);r.uniform3fv(this.addr,t)}function kR(r,e){const t=Bi(e,this.size,4);r.uniform4fv(this.addr,t)}function DR(r,e){const t=Bi(e,this.size,4);r.uniformMatrix2fv(this.addr,!1,t)}function PR(r,e){const t=Bi(e,this.size,9);r.uniformMatrix3fv(this.addr,!1,t)}function FR(r,e){const t=Bi(e,this.size,16);r.uniformMatrix4fv(this.addr,!1,t)}function OR(r,e){r.uniform1iv(this.addr,e)}function BR(r,e){r.uniform2iv(this.addr,e)}function zR(r,e){r.uniform3iv(this.addr,e)}function UR(r,e){r.uniform4iv(this.addr,e)}function VR(r,e){r.uniform1uiv(this.addr,e)}function HR(r,e){r.uniform2uiv(this.addr,e)}function $R(r,e){r.uniform3uiv(this.addr,e)}function GR(r,e){r.uniform4uiv(this.addr,e)}function WR(r,e,t){const n=e.length,s=uc(t,n);r.uniform1iv(this.addr,s);for(let i=0;i!==n;++i)t.safeSetTexture2D(e[i]||cg,s[i])}function jR(r,e,t){const n=e.length,s=uc(t,n);r.uniform1iv(this.addr,s);for(let i=0;i!==n;++i)t.setTexture3D(e[i]||lg,s[i])}function qR(r,e,t){const n=e.length,s=uc(t,n);r.uniform1iv(this.addr,s);for(let i=0;i!==n;++i)t.safeSetTextureCube(e[i]||hg,s[i])}function KR(r,e,t){const n=e.length,s=uc(t,n);r.uniform1iv(this.addr,s);for(let i=0;i!==n;++i)t.setTexture2DArray(e[i]||ug,s[i])}function XR(r){switch(r){case 5126:return RR;case 35664:return CR;case 35665:return LR;case 35666:return kR;case 35674:return DR;case 35675:return PR;case 35676:return FR;case 5124:case 35670:return OR;case 35667:case 35671:return BR;case 35668:case 35672:return zR;case 35669:case 35673:return UR;case 5125:return VR;case 36294:return HR;case 36295:return $R;case 36296:return GR;case 35678:case 36198:case 36298:case 36306:case 35682:return WR;case 35679:case 36299:case 36307:return jR;case 35680:case 36300:case 36308:case 36293:return qR;case 36289:case 36303:case 36311:case 36292:return KR}}function YR(r,e,t){this.id=r,this.addr=t,this.cache=[],this.setValue=NR(e.type)}function yg(r,e,t){this.id=r,this.addr=t,this.cache=[],this.size=e.size,this.setValue=XR(e.type)}yg.prototype.updateCache=function(r){const e=this.cache;r instanceof Float32Array&&e.length!==r.length&&(this.cache=new Float32Array(r.length)),on(e,r)};function _g(r){this.id=r,this.seq=[],this.map={}}_g.prototype.setValue=function(r,e,t){const n=this.seq;for(let s=0,i=n.length;s!==i;++s){const a=n[s];a.setValue(r,e[a.id],t)}};const Ch=/(\w+)(\])?(\[|\.)?/g;function xg(r,e){r.seq.push(e),r.map[e.id]=e}function JR(r,e,t){const n=r.name,s=n.length;for(Ch.lastIndex=0;;){const i=Ch.exec(n),a=Ch.lastIndex;let o=i[1];const c=i[2]==="]",l=i[3];if(c&&(o=o|0),l===void 0||l==="["&&a+2===s){xg(t,l===void 0?new YR(o,r,e):new yg(o,r,e));break}else{let h=t.map[o];h===void 0&&(h=new _g(o),xg(t,h)),t=h}}}function jr(r,e){this.seq=[],this.map={};const t=r.getProgramParameter(e,35718);for(let n=0;n<t;++n){const s=r.getActiveUniform(e,n),i=r.getUniformLocation(e,s.name);JR(s,i,this)}}jr.prototype.setValue=function(r,e,t,n){const s=this.map[e];s!==void 0&&s.setValue(r,t,n)};jr.prototype.setOptional=function(r,e,t){const n=e[t];n!==void 0&&this.setValue(r,t,n)};jr.upload=function(r,e,t,n){for(let s=0,i=e.length;s!==i;++s){const a=e[s],o=t[a.id];o.needsUpdate!==!1&&a.setValue(r,o.value,n)}};jr.seqWithValue=function(r,e){const t=[];for(let n=0,s=r.length;n!==s;++n){const i=r[n];i.id in e&&t.push(i)}return t};function bg(r,e,t){const n=r.createShader(e);return r.shaderSource(n,t),r.compileShader(n),n}let ZR=0;function QR(r){const e=r.split(`
`);for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join(`
`)}function vg(r){switch(r){case yn:return["Linear","( value )"];case Or:return["sRGB","( value )"];case Yl:return["RGBE","( value )"];case I1:return["RGBM","( value, 7.0 )"];case N1:return["RGBM","( value, 16.0 )"];case R1:return["RGBD","( value, 256.0 )"];case Xl:return["Gamma","( value, float( GAMMA_FACTOR ) )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",r),["Linear","( value )"]}}function wg(r,e,t){const n=r.getShaderParameter(e,35713),s=r.getShaderInfoLog(e).trim();return n&&s===""?"":t.toUpperCase()+`

`+s+`

`+QR(r.getShaderSource(e))}function Is(r,e){const t=vg(e);return"vec4 "+r+"( vec4 value ) { return "+t[0]+"ToLinear"+t[1]+"; }"}function eC(r,e){const t=vg(e);return"vec4 "+r+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function tC(r,e){let t;switch(e){case kE:t="Linear";break;case DE:t="Reinhard";break;case PE:t="OptimizedCineon";break;case FE:t="ACESFilmic";break;case OE:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+r+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function nC(r){return[r.extensionDerivatives||r.envMapCubeUV||r.bumpMap||r.tangentSpaceNormalMap||r.clearcoatNormalMap||r.flatShading||r.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(r.extensionFragDepth||r.logarithmicDepthBuffer)&&r.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",r.extensionDrawBuffers&&r.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(r.extensionShaderTextureLOD||r.envMap||r.transmission)&&r.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Oa).join(`
`)}function rC(r){const e=[];for(const t in r){const n=r[t];n!==!1&&e.push("#define "+t+" "+n)}return e.join(`
`)}function sC(r,e){const t={},n=r.getProgramParameter(e,35721);for(let s=0;s<n;s++){const i=r.getActiveAttrib(e,s),a=i.name;let o=1;i.type===35674&&(o=2),i.type===35675&&(o=3),i.type===35676&&(o=4),t[a]={type:i.type,location:r.getAttribLocation(e,a),locationSize:o}}return t}function Oa(r){return r!==""}function Sg(r,e){return r.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function Tg(r,e){return r.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const iC=/^[ \t]*#include +<([\w\d./]+)>/gm;function Lh(r){return r.replace(iC,aC)}function aC(r,e){const t=tt[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return Lh(t)}const oC=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,cC=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Eg(r){return r.replace(cC,Mg).replace(oC,uC)}function uC(r,e,t,n){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Mg(r,e,t,n)}function Mg(r,e,t,n){let s="";for(let i=parseInt(e);i<parseInt(t);i++)s+=n.replace(/\[\s*i\s*\]/g,"[ "+i+" ]").replace(/UNROLLED_LOOP_INDEX/g,i);return s}function Ag(r){let e="precision "+r.precision+` float;
precision `+r.precision+" int;";return r.precision==="highp"?e+=`
#define HIGH_PRECISION`:r.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:r.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function lC(r){let e="SHADOWMAP_TYPE_BASIC";return r.shadowMapType===i1?e="SHADOWMAP_TYPE_PCF":r.shadowMapType===hE?e="SHADOWMAP_TYPE_PCF_SOFT":r.shadowMapType===ba&&(e="SHADOWMAP_TYPE_VSM"),e}function hC(r){let e="ENVMAP_TYPE_CUBE";if(r.envMap)switch(r.envMapMode){case wa:case Sa:e="ENVMAP_TYPE_CUBE";break;case Do:case Gl:e="ENVMAP_TYPE_CUBE_UV";break}return e}function dC(r){let e="ENVMAP_MODE_REFLECTION";if(r.envMap)switch(r.envMapMode){case Sa:case Gl:e="ENVMAP_MODE_REFRACTION";break}return e}function pC(r){let e="ENVMAP_BLENDING_NONE";if(r.envMap)switch(r.combine){case ko:e="ENVMAP_BLENDING_MULTIPLY";break;case CE:e="ENVMAP_BLENDING_MIX";break;case LE:e="ENVMAP_BLENDING_ADD";break}return e}function fC(r,e,t,n){const s=r.getContext(),i=t.defines;let a=t.vertexShader,o=t.fragmentShader;const c=lC(t),l=hC(t),u=dC(t),h=pC(t),d=r.gammaFactor>0?r.gammaFactor:1,p=t.isWebGL2?"":nC(t),f=rC(i),m=s.createProgram();let _,g,y=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(_=[f].filter(Oa).join(`
`),_.length>0&&(_+=`
`),g=[p,f].filter(Oa).join(`
`),g.length>0&&(g+=`
`)):(_=[Ag(t),"#define SHADER_NAME "+t.shaderName,f,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+d,"#define MAX_BONES "+t.maxBones,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.useVertexTexture?"#define BONE_TEXTURE":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphTargets&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargets&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+c:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Oa).join(`
`),g=[p,Ag(t),"#define SHADER_NAME "+t.shaderName,f,"#define GAMMA_FACTOR "+d,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+l:"",t.envMap?"#define "+u:"",t.envMap?"#define "+h:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+c:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==_s?"#define TONE_MAPPING":"",t.toneMapping!==_s?tt.tonemapping_pars_fragment:"",t.toneMapping!==_s?tC("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.format===Fr?"#define OPAQUE":"",tt.encodings_pars_fragment,t.map?Is("mapTexelToLinear",t.mapEncoding):"",t.matcap?Is("matcapTexelToLinear",t.matcapEncoding):"",t.envMap?Is("envMapTexelToLinear",t.envMapEncoding):"",t.emissiveMap?Is("emissiveMapTexelToLinear",t.emissiveMapEncoding):"",t.specularColorMap?Is("specularColorMapTexelToLinear",t.specularColorMapEncoding):"",t.sheenColorMap?Is("sheenColorMapTexelToLinear",t.sheenColorMapEncoding):"",t.lightMap?Is("lightMapTexelToLinear",t.lightMapEncoding):"",eC("linearToOutputTexel",t.outputEncoding),t.depthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Oa).join(`
`)),a=Lh(a),a=Sg(a,t),a=Tg(a,t),o=Lh(o),o=Sg(o,t),o=Tg(o,t),a=Eg(a),o=Eg(o),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(y=`#version 300 es
`,_=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+_,g=["#define varying in",t.glslVersion===C1?"":"out highp vec4 pc_fragColor;",t.glslVersion===C1?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+g);const x=y+_+a,w=y+g+o,T=bg(s,35633,x),M=bg(s,35632,w);if(s.attachShader(m,T),s.attachShader(m,M),t.index0AttributeName!==void 0?s.bindAttribLocation(m,0,t.index0AttributeName):t.morphTargets===!0&&s.bindAttribLocation(m,0,"position"),s.linkProgram(m),r.debug.checkShaderErrors){const k=s.getProgramInfoLog(m).trim(),O=s.getShaderInfoLog(T).trim(),A=s.getShaderInfoLog(M).trim();let Y=!0,B=!0;if(s.getProgramParameter(m,35714)===!1){Y=!1;const H=wg(s,T,"vertex"),U=wg(s,M,"fragment");console.error("THREE.WebGLProgram: Shader Error "+s.getError()+" - VALIDATE_STATUS "+s.getProgramParameter(m,35715)+`

Program Info Log: `+k+`
`+H+`
`+U)}else k!==""?console.warn("THREE.WebGLProgram: Program Info Log:",k):(O===""||A==="")&&(B=!1);B&&(this.diagnostics={runnable:Y,programLog:k,vertexShader:{log:O,prefix:_},fragmentShader:{log:A,prefix:g}})}s.deleteShader(T),s.deleteShader(M);let S;this.getUniforms=function(){return S===void 0&&(S=new jr(s,m)),S};let R;return this.getAttributes=function(){return R===void 0&&(R=sC(s,m)),R},this.destroy=function(){n.releaseStatesOfProgram(this),s.deleteProgram(m),this.program=void 0},this.name=t.shaderName,this.id=ZR++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=T,this.fragmentShader=M,this}function mC(r,e,t,n,s,i,a){const o=[],c=s.isWebGL2,l=s.logarithmicDepthBuffer,u=s.floatVertexTextures,h=s.maxVertexUniforms,d=s.vertexTextures;let p=s.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},m=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoat","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap",,"roughnessMap","metalnessMap","gradientMap","alphaMap","alphaTest","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","morphTargetsCount","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","format","specularIntensityMap","specularColorMap","specularColorMapEncoding","transmission","transmissionMap","thicknessMap","sheen","sheenColorMap","sheenColorMapEncoding","sheenRoughnessMap"];function _(S){const k=S.skeleton.bones;if(u)return 1024;{const A=Math.floor((h-20)/4),Y=Math.min(A,k.length);return Y<k.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+k.length+" bones. This GPU supports "+Y+"."),0):Y}}function g(S){let R;return S&&S.isTexture?R=S.encoding:S&&S.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),R=S.texture.encoding):R=yn,R}function y(S,R,k,O,A){const Y=O.fog,B=S.isMeshStandardMaterial?O.environment:null,H=(S.isMeshStandardMaterial?t:e).get(S.envMap||B),U=f[S.type],j=A.isSkinnedMesh?_(A):0;S.precision!==null&&(p=s.getMaxPrecision(S.precision),p!==S.precision&&console.warn("THREE.WebGLProgram.getParameters:",S.precision,"not supported, using",p,"instead."));let K,se;if(U){const he=Kn[U];K=he.vertexShader,se=he.fragmentShader}else K=S.vertexShader,se=S.fragmentShader;const ue=r.getRenderTarget(),Q=S.alphaTest>0,ee=S.clearcoat>0;return{isWebGL2:c,shaderID:U,shaderName:S.type,vertexShader:K,fragmentShader:se,defines:S.defines,isRawShaderMaterial:S.isRawShaderMaterial===!0,glslVersion:S.glslVersion,precision:p,instancing:A.isInstancedMesh===!0,instancingColor:A.isInstancedMesh===!0&&A.instanceColor!==null,supportsVertexTextures:d,outputEncoding:ue!==null?g(ue.texture):r.outputEncoding,map:!!S.map,mapEncoding:g(S.map),matcap:!!S.matcap,matcapEncoding:g(S.matcap),envMap:!!H,envMapMode:H&&H.mapping,envMapEncoding:g(H),envMapCubeUV:!!H&&(H.mapping===Do||H.mapping===Gl),lightMap:!!S.lightMap,lightMapEncoding:g(S.lightMap),aoMap:!!S.aoMap,emissiveMap:!!S.emissiveMap,emissiveMapEncoding:g(S.emissiveMap),bumpMap:!!S.bumpMap,normalMap:!!S.normalMap,objectSpaceNormalMap:S.normalMapType===OM,tangentSpaceNormalMap:S.normalMapType===bs,clearcoat:ee,clearcoatMap:ee&&!!S.clearcoatMap,clearcoatRoughnessMap:ee&&!!S.clearcoatRoughnessMap,clearcoatNormalMap:ee&&!!S.clearcoatNormalMap,displacementMap:!!S.displacementMap,roughnessMap:!!S.roughnessMap,metalnessMap:!!S.metalnessMap,specularMap:!!S.specularMap,specularIntensityMap:!!S.specularIntensityMap,specularColorMap:!!S.specularColorMap,specularColorMapEncoding:g(S.specularColorMap),alphaMap:!!S.alphaMap,alphaTest:Q,gradientMap:!!S.gradientMap,sheen:S.sheen>0,sheenColorMap:!!S.sheenColorMap,sheenColorMapEncoding:g(S.sheenColorMap),sheenRoughnessMap:!!S.sheenRoughnessMap,transmission:S.transmission>0,transmissionMap:!!S.transmissionMap,thicknessMap:!!S.thicknessMap,combine:S.combine,vertexTangents:!!S.normalMap&&!!A.geometry&&!!A.geometry.attributes.tangent,vertexColors:S.vertexColors,vertexAlphas:S.vertexColors===!0&&!!A.geometry&&!!A.geometry.attributes.color&&A.geometry.attributes.color.itemSize===4,vertexUvs:!!S.map||!!S.bumpMap||!!S.normalMap||!!S.specularMap||!!S.alphaMap||!!S.emissiveMap||!!S.roughnessMap||!!S.metalnessMap||!!S.clearcoatMap||!!S.clearcoatRoughnessMap||!!S.clearcoatNormalMap||!!S.displacementMap||!!S.transmissionMap||!!S.thicknessMap||!!S.specularIntensityMap||!!S.specularColorMap||!!S.sheenColorMap||S.sheenRoughnessMap,uvsVertexOnly:!(!!S.map||!!S.bumpMap||!!S.normalMap||!!S.specularMap||!!S.alphaMap||!!S.emissiveMap||!!S.roughnessMap||!!S.metalnessMap||!!S.clearcoatNormalMap||S.transmission>0||!!S.transmissionMap||!!S.thicknessMap||!!S.specularIntensityMap||!!S.specularColorMap||S.sheen>0||!!S.sheenColorMap||!!S.sheenRoughnessMap)&&!!S.displacementMap,fog:!!Y,useFog:S.fog,fogExp2:Y&&Y.isFogExp2,flatShading:!!S.flatShading,sizeAttenuation:S.sizeAttenuation,logarithmicDepthBuffer:l,skinning:A.isSkinnedMesh===!0&&j>0,maxBones:j,useVertexTexture:u,morphTargets:!!A.geometry&&!!A.geometry.morphAttributes.position,morphNormals:!!A.geometry&&!!A.geometry.morphAttributes.normal,morphTargetsCount:!!A.geometry&&!!A.geometry.morphAttributes.position?A.geometry.morphAttributes.position.length:0,numDirLights:R.directional.length,numPointLights:R.point.length,numSpotLights:R.spot.length,numRectAreaLights:R.rectArea.length,numHemiLights:R.hemi.length,numDirLightShadows:R.directionalShadowMap.length,numPointLightShadows:R.pointShadowMap.length,numSpotLightShadows:R.spotShadowMap.length,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,format:S.format,dithering:S.dithering,shadowMapEnabled:r.shadowMap.enabled&&k.length>0,shadowMapType:r.shadowMap.type,toneMapping:S.toneMapped?r.toneMapping:_s,physicallyCorrectLights:r.physicallyCorrectLights,premultipliedAlpha:S.premultipliedAlpha,doubleSided:S.side===ys,flipSided:S.side===zt,depthPacking:S.depthPacking!==void 0?S.depthPacking:!1,index0AttributeName:S.index0AttributeName,extensionDerivatives:S.extensions&&S.extensions.derivatives,extensionFragDepth:S.extensions&&S.extensions.fragDepth,extensionDrawBuffers:S.extensions&&S.extensions.drawBuffers,extensionShaderTextureLOD:S.extensions&&S.extensions.shaderTextureLOD,rendererExtensionFragDepth:c||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:c||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:c||n.has("EXT_shader_texture_lod"),customProgramCacheKey:S.customProgramCacheKey()}}function x(S){const R=[];if(S.shaderID?R.push(S.shaderID):(R.push(P1(S.fragmentShader)),R.push(P1(S.vertexShader))),S.defines!==void 0)for(const k in S.defines)R.push(k),R.push(S.defines[k]);if(S.isRawShaderMaterial===!1){for(let k=0;k<m.length;k++)R.push(S[m[k]]);R.push(r.outputEncoding),R.push(r.gammaFactor)}return R.push(S.customProgramCacheKey),R.join()}function w(S){const R=f[S.type];let k;if(R){const O=Kn[R];k=pA.clone(O.uniforms)}else k=S.uniforms;return k}function T(S,R){let k;for(let O=0,A=o.length;O<A;O++){const Y=o[O];if(Y.cacheKey===R){k=Y,++k.usedTimes;break}}return k===void 0&&(k=new fC(r,R,S,i),o.push(k)),k}function M(S){if(--S.usedTimes==0){const R=o.indexOf(S);o[R]=o[o.length-1],o.pop(),S.destroy()}}return{getParameters:y,getProgramCacheKey:x,getUniforms:w,acquireProgram:T,releaseProgram:M,programs:o}}function gC(){let r=new WeakMap;function e(i){let a=r.get(i);return a===void 0&&(a={},r.set(i,a)),a}function t(i){r.delete(i)}function n(i,a,o){r.get(i)[a]=o}function s(){r=new WeakMap}return{get:e,remove:t,update:n,dispose:s}}function yC(r,e){return r.groupOrder!==e.groupOrder?r.groupOrder-e.groupOrder:r.renderOrder!==e.renderOrder?r.renderOrder-e.renderOrder:r.program!==e.program?r.program.id-e.program.id:r.material.id!==e.material.id?r.material.id-e.material.id:r.z!==e.z?r.z-e.z:r.id-e.id}function Ig(r,e){return r.groupOrder!==e.groupOrder?r.groupOrder-e.groupOrder:r.renderOrder!==e.renderOrder?r.renderOrder-e.renderOrder:r.z!==e.z?e.z-r.z:r.id-e.id}function Ng(r){const e=[];let t=0;const n=[],s=[],i=[],a={id:-1};function o(){t=0,n.length=0,s.length=0,i.length=0}function c(p,f,m,_,g,y){let x=e[t];const w=r.get(m);return x===void 0?(x={id:p.id,object:p,geometry:f,material:m,program:w.program||a,groupOrder:_,renderOrder:p.renderOrder,z:g,group:y},e[t]=x):(x.id=p.id,x.object=p,x.geometry=f,x.material=m,x.program=w.program||a,x.groupOrder=_,x.renderOrder=p.renderOrder,x.z=g,x.group=y),t++,x}function l(p,f,m,_,g,y){const x=c(p,f,m,_,g,y);m.transmission>0?s.push(x):m.transparent===!0?i.push(x):n.push(x)}function u(p,f,m,_,g,y){const x=c(p,f,m,_,g,y);m.transmission>0?s.unshift(x):m.transparent===!0?i.unshift(x):n.unshift(x)}function h(p,f){n.length>1&&n.sort(p||yC),s.length>1&&s.sort(f||Ig),i.length>1&&i.sort(f||Ig)}function d(){for(let p=t,f=e.length;p<f;p++){const m=e[p];if(m.id===null)break;m.id=null,m.object=null,m.geometry=null,m.material=null,m.program=null,m.group=null}}return{opaque:n,transmissive:s,transparent:i,init:o,push:l,unshift:u,finish:d,sort:h}}function _C(r){let e=new WeakMap;function t(s,i){let a;return e.has(s)===!1?(a=new Ng(r),e.set(s,[a])):i>=e.get(s).length?(a=new Ng(r),e.get(s).push(a)):a=e.get(s)[i],a}function n(){e=new WeakMap}return{get:t,dispose:n}}function xC(){const r={};return{get:function(e){if(r[e.id]!==void 0)return r[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new L,color:new Le};break;case"SpotLight":t={position:new L,direction:new L,color:new Le,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new L,color:new Le,distance:0,decay:0};break;case"HemisphereLight":t={direction:new L,skyColor:new Le,groundColor:new Le};break;case"RectAreaLight":t={color:new Le,position:new L,halfWidth:new L,halfHeight:new L};break}return r[e.id]=t,t}}}function bC(){const r={};return{get:function(e){if(r[e.id]!==void 0)return r[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new fe};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new fe};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new fe,shadowCameraNear:1,shadowCameraFar:1e3};break}return r[e.id]=t,t}}}let vC=0;function wC(r,e){return(e.castShadow?1:0)-(r.castShadow?1:0)}function SC(r,e){const t=new xC,n=bC(),s={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let u=0;u<9;u++)s.probe.push(new L);const i=new L,a=new Be,o=new Be;function c(u,h){let d=0,p=0,f=0;for(let k=0;k<9;k++)s.probe[k].set(0,0,0);let m=0,_=0,g=0,y=0,x=0,w=0,T=0,M=0;u.sort(wC);const S=h!==!0?Math.PI:1;for(let k=0,O=u.length;k<O;k++){const A=u[k],Y=A.color,B=A.intensity,H=A.distance,U=A.shadow&&A.shadow.map?A.shadow.map.texture:null;if(A.isAmbientLight)d+=Y.r*B*S,p+=Y.g*B*S,f+=Y.b*B*S;else if(A.isLightProbe)for(let j=0;j<9;j++)s.probe[j].addScaledVector(A.sh.coefficients[j],B);else if(A.isDirectionalLight){const j=t.get(A);if(j.color.copy(A.color).multiplyScalar(A.intensity*S),A.castShadow){const K=A.shadow,se=n.get(A);se.shadowBias=K.bias,se.shadowNormalBias=K.normalBias,se.shadowRadius=K.radius,se.shadowMapSize=K.mapSize,s.directionalShadow[m]=se,s.directionalShadowMap[m]=U,s.directionalShadowMatrix[m]=A.shadow.matrix,w++}s.directional[m]=j,m++}else if(A.isSpotLight){const j=t.get(A);if(j.position.setFromMatrixPosition(A.matrixWorld),j.color.copy(Y).multiplyScalar(B*S),j.distance=H,j.coneCos=Math.cos(A.angle),j.penumbraCos=Math.cos(A.angle*(1-A.penumbra)),j.decay=A.decay,A.castShadow){const K=A.shadow,se=n.get(A);se.shadowBias=K.bias,se.shadowNormalBias=K.normalBias,se.shadowRadius=K.radius,se.shadowMapSize=K.mapSize,s.spotShadow[g]=se,s.spotShadowMap[g]=U,s.spotShadowMatrix[g]=A.shadow.matrix,M++}s.spot[g]=j,g++}else if(A.isRectAreaLight){const j=t.get(A);j.color.copy(Y).multiplyScalar(B),j.halfWidth.set(A.width*.5,0,0),j.halfHeight.set(0,A.height*.5,0),s.rectArea[y]=j,y++}else if(A.isPointLight){const j=t.get(A);if(j.color.copy(A.color).multiplyScalar(A.intensity*S),j.distance=A.distance,j.decay=A.decay,A.castShadow){const K=A.shadow,se=n.get(A);se.shadowBias=K.bias,se.shadowNormalBias=K.normalBias,se.shadowRadius=K.radius,se.shadowMapSize=K.mapSize,se.shadowCameraNear=K.camera.near,se.shadowCameraFar=K.camera.far,s.pointShadow[_]=se,s.pointShadowMap[_]=U,s.pointShadowMatrix[_]=A.shadow.matrix,T++}s.point[_]=j,_++}else if(A.isHemisphereLight){const j=t.get(A);j.skyColor.copy(A.color).multiplyScalar(B*S),j.groundColor.copy(A.groundColor).multiplyScalar(B*S),s.hemi[x]=j,x++}}y>0&&(e.isWebGL2||r.has("OES_texture_float_linear")===!0?(s.rectAreaLTC1=Te.LTC_FLOAT_1,s.rectAreaLTC2=Te.LTC_FLOAT_2):r.has("OES_texture_half_float_linear")===!0?(s.rectAreaLTC1=Te.LTC_HALF_1,s.rectAreaLTC2=Te.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),s.ambient[0]=d,s.ambient[1]=p,s.ambient[2]=f;const R=s.hash;(R.directionalLength!==m||R.pointLength!==_||R.spotLength!==g||R.rectAreaLength!==y||R.hemiLength!==x||R.numDirectionalShadows!==w||R.numPointShadows!==T||R.numSpotShadows!==M)&&(s.directional.length=m,s.spot.length=g,s.rectArea.length=y,s.point.length=_,s.hemi.length=x,s.directionalShadow.length=w,s.directionalShadowMap.length=w,s.pointShadow.length=T,s.pointShadowMap.length=T,s.spotShadow.length=M,s.spotShadowMap.length=M,s.directionalShadowMatrix.length=w,s.pointShadowMatrix.length=T,s.spotShadowMatrix.length=M,R.directionalLength=m,R.pointLength=_,R.spotLength=g,R.rectAreaLength=y,R.hemiLength=x,R.numDirectionalShadows=w,R.numPointShadows=T,R.numSpotShadows=M,s.version=vC++)}function l(u,h){let d=0,p=0,f=0,m=0,_=0;const g=h.matrixWorldInverse;for(let y=0,x=u.length;y<x;y++){const w=u[y];if(w.isDirectionalLight){const T=s.directional[d];T.direction.setFromMatrixPosition(w.matrixWorld),i.setFromMatrixPosition(w.target.matrixWorld),T.direction.sub(i),T.direction.transformDirection(g),d++}else if(w.isSpotLight){const T=s.spot[f];T.position.setFromMatrixPosition(w.matrixWorld),T.position.applyMatrix4(g),T.direction.setFromMatrixPosition(w.matrixWorld),i.setFromMatrixPosition(w.target.matrixWorld),T.direction.sub(i),T.direction.transformDirection(g),f++}else if(w.isRectAreaLight){const T=s.rectArea[m];T.position.setFromMatrixPosition(w.matrixWorld),T.position.applyMatrix4(g),o.identity(),a.copy(w.matrixWorld),a.premultiply(g),o.extractRotation(a),T.halfWidth.set(w.width*.5,0,0),T.halfHeight.set(0,w.height*.5,0),T.halfWidth.applyMatrix4(o),T.halfHeight.applyMatrix4(o),m++}else if(w.isPointLight){const T=s.point[p];T.position.setFromMatrixPosition(w.matrixWorld),T.position.applyMatrix4(g),p++}else if(w.isHemisphereLight){const T=s.hemi[_];T.direction.setFromMatrixPosition(w.matrixWorld),T.direction.transformDirection(g),T.direction.normalize(),_++}}}return{setup:c,setupView:l,state:s}}function Rg(r,e){const t=new SC(r,e),n=[],s=[];function i(){n.length=0,s.length=0}function a(h){n.push(h)}function o(h){s.push(h)}function c(h){t.setup(n,h)}function l(h){t.setupView(n,h)}return{init:i,state:{lightsArray:n,shadowsArray:s,lights:t},setupLights:c,setupLightsView:l,pushLight:a,pushShadow:o}}function TC(r,e){let t=new WeakMap;function n(i,a=0){let o;return t.has(i)===!1?(o=new Rg(r,e),t.set(i,[o])):a>=t.get(i).length?(o=new Rg(r,e),t.get(i).push(o)):o=t.get(i)[a],o}function s(){t=new WeakMap}return{get:n,dispose:s}}class Cg extends Ht{constructor(e){super();this.type="MeshDepthMaterial",this.depthPacking=PM,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}Cg.prototype.isMeshDepthMaterial=!0;class Lg extends Ht{constructor(e){super();this.type="MeshDistanceMaterial",this.referencePosition=new L,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}Lg.prototype.isMeshDistanceMaterial=!0;const EC=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,MC=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function kg(r,e,t){let n=new ic;const s=new fe,i=new fe,a=new pt,o=new Cg({depthPacking:FM}),c=new Lg,l={},u=t.maxTextureSize,h={0:zt,1:oi,2:ys},d=new Es({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new fe},radius:{value:4}},vertexShader:EC,fragmentShader:MC}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const f=new yt;f.setAttribute("position",new It(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const m=new $t(f,d),_=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=i1,this.render=function(w,T,M){if(_.enabled===!1||_.autoUpdate===!1&&_.needsUpdate===!1||w.length===0)return;const S=r.getRenderTarget(),R=r.getActiveCubeFace(),k=r.getActiveMipmapLevel(),O=r.state;O.setBlending(Dr),O.buffers.color.setClear(1,1,1,1),O.buffers.depth.setTest(!0),O.setScissorTest(!1);for(let A=0,Y=w.length;A<Y;A++){const B=w[A],H=B.shadow;if(H===void 0){console.warn("THREE.WebGLShadowMap:",B,"has no shadow.");continue}if(H.autoUpdate===!1&&H.needsUpdate===!1)continue;s.copy(H.mapSize);const U=H.getFrameExtents();if(s.multiply(U),i.copy(H.mapSize),(s.x>u||s.y>u)&&(s.x>u&&(i.x=Math.floor(u/U.x),s.x=i.x*U.x,H.mapSize.x=i.x),s.y>u&&(i.y=Math.floor(u/U.y),s.y=i.y*U.y,H.mapSize.y=i.y)),H.map===null&&!H.isPointLightShadow&&this.type===ba){const K={minFilter:gn,magFilter:gn,format:sn};H.map=new Rn(s.x,s.y,K),H.map.texture.name=B.name+".shadowMap",H.mapPass=new Rn(s.x,s.y,K),H.camera.updateProjectionMatrix()}if(H.map===null){const K={minFilter:Ut,magFilter:Ut,format:sn};H.map=new Rn(s.x,s.y,K),H.map.texture.name=B.name+".shadowMap",H.camera.updateProjectionMatrix()}r.setRenderTarget(H.map),r.clear();const j=H.getViewportCount();for(let K=0;K<j;K++){const se=H.getViewport(K);a.set(i.x*se.x,i.y*se.y,i.x*se.z,i.y*se.w),O.viewport(a),H.updateMatrices(B,K),n=H.getFrustum(),x(T,M,H.camera,B,this.type)}!H.isPointLightShadow&&this.type===ba&&g(H,M),H.needsUpdate=!1}_.needsUpdate=!1,r.setRenderTarget(S,R,k)};function g(w,T){const M=e.update(m);d.defines.VSM_SAMPLES!==w.blurSamples&&(d.defines.VSM_SAMPLES=w.blurSamples,p.defines.VSM_SAMPLES=w.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),d.uniforms.shadow_pass.value=w.map.texture,d.uniforms.resolution.value=w.mapSize,d.uniforms.radius.value=w.radius,r.setRenderTarget(w.mapPass),r.clear(),r.renderBufferDirect(T,null,M,d,m,null),p.uniforms.shadow_pass.value=w.mapPass.texture,p.uniforms.resolution.value=w.mapSize,p.uniforms.radius.value=w.radius,r.setRenderTarget(w.map),r.clear(),r.renderBufferDirect(T,null,M,p,m,null)}function y(w,T,M,S,R,k,O){let A=null;const Y=S.isPointLight===!0?w.customDistanceMaterial:w.customDepthMaterial;if(Y!==void 0?A=Y:A=S.isPointLight===!0?c:o,r.localClippingEnabled&&M.clipShadows===!0&&M.clippingPlanes.length!==0||M.displacementMap&&M.displacementScale!==0||M.alphaMap&&M.alphaTest>0){const B=A.uuid,H=M.uuid;let U=l[B];U===void 0&&(U={},l[B]=U);let j=U[H];j===void 0&&(j=A.clone(),U[H]=j),A=j}return A.visible=M.visible,A.wireframe=M.wireframe,O===ba?A.side=M.shadowSide!==null?M.shadowSide:M.side:A.side=M.shadowSide!==null?M.shadowSide:h[M.side],A.alphaMap=M.alphaMap,A.alphaTest=M.alphaTest,A.clipShadows=M.clipShadows,A.clippingPlanes=M.clippingPlanes,A.clipIntersection=M.clipIntersection,A.displacementMap=M.displacementMap,A.displacementScale=M.displacementScale,A.displacementBias=M.displacementBias,A.wireframeLinewidth=M.wireframeLinewidth,A.linewidth=M.linewidth,S.isPointLight===!0&&A.isMeshDistanceMaterial===!0&&(A.referencePosition.setFromMatrixPosition(S.matrixWorld),A.nearDistance=R,A.farDistance=k),A}function x(w,T,M,S,R){if(w.visible===!1)return;if(w.layers.test(T.layers)&&(w.isMesh||w.isLine||w.isPoints)&&(w.castShadow||w.receiveShadow&&R===ba)&&(!w.frustumCulled||n.intersectsObject(w))){w.modelViewMatrix.multiplyMatrices(M.matrixWorldInverse,w.matrixWorld);const A=e.update(w),Y=w.material;if(Array.isArray(Y)){const B=A.groups;for(let H=0,U=B.length;H<U;H++){const j=B[H],K=Y[j.materialIndex];if(K&&K.visible){const se=y(w,A,K,S,M.near,M.far,R);r.renderBufferDirect(M,null,A,se,w,j)}}}else if(Y.visible){const B=y(w,A,Y,S,M.near,M.far,R);r.renderBufferDirect(M,null,A,B,w,null)}}const O=w.children;for(let A=0,Y=O.length;A<Y;A++)x(O[A],T,M,S,R)}}function AC(r,e,t){const n=t.isWebGL2;function s(){let $=!1;const de=new pt;let le=null;const Se=new pt(0,0,0,0);return{setMask:function(ve){le!==ve&&!$&&(r.colorMask(ve,ve,ve,ve),le=ve)},setLocked:function(ve){$=ve},setClear:function(ve,Ee,Ce,qe,_t){_t===!0&&(ve*=qe,Ee*=qe,Ce*=qe),de.set(ve,Ee,Ce,qe),Se.equals(de)===!1&&(r.clearColor(ve,Ee,Ce,qe),Se.copy(de))},reset:function(){$=!1,le=null,Se.set(-1,0,0,0)}}}function i(){let $=!1,de=null,le=null,Se=null;return{setTest:function(ve){ve?he(2929):Me(2929)},setMask:function(ve){de!==ve&&!$&&(r.depthMask(ve),de=ve)},setFunc:function(ve){if(le!==ve){if(ve)switch(ve){case TE:r.depthFunc(512);break;case EE:r.depthFunc(519);break;case ME:r.depthFunc(513);break;case Vl:r.depthFunc(515);break;case AE:r.depthFunc(514);break;case IE:r.depthFunc(518);break;case NE:r.depthFunc(516);break;case RE:r.depthFunc(517);break;default:r.depthFunc(515)}else r.depthFunc(515);le=ve}},setLocked:function(ve){$=ve},setClear:function(ve){Se!==ve&&(r.clearDepth(ve),Se=ve)},reset:function(){$=!1,de=null,le=null,Se=null}}}function a(){let $=!1,de=null,le=null,Se=null,ve=null,Ee=null,Ce=null,qe=null,_t=null;return{setTest:function(Je){$||(Je?he(2960):Me(2960))},setMask:function(Je){de!==Je&&!$&&(r.stencilMask(Je),de=Je)},setFunc:function(Je,en,Gt){(le!==Je||Se!==en||ve!==Gt)&&(r.stencilFunc(Je,en,Gt),le=Je,Se=en,ve=Gt)},setOp:function(Je,en,Gt){(Ee!==Je||Ce!==en||qe!==Gt)&&(r.stencilOp(Je,en,Gt),Ee=Je,Ce=en,qe=Gt)},setLocked:function(Je){$=Je},setClear:function(Je){_t!==Je&&(r.clearStencil(Je),_t=Je)},reset:function(){$=!1,de=null,le=null,Se=null,ve=null,Ee=null,Ce=null,qe=null,_t=null}}}const o=new s,c=new i,l=new a;let u={},h={},d=null,p=!1,f=null,m=null,_=null,g=null,y=null,x=null,w=null,T=!1,M=null,S=null,R=null,k=null,O=null;const A=r.getParameter(35661);let Y=!1,B=0;const H=r.getParameter(7938);H.indexOf("WebGL")!==-1?(B=parseFloat(/^WebGL (\d)/.exec(H)[1]),Y=B>=1):H.indexOf("OpenGL ES")!==-1&&(B=parseFloat(/^OpenGL ES (\d)/.exec(H)[1]),Y=B>=2);let U=null,j={};const K=r.getParameter(3088),se=r.getParameter(2978),ue=new pt().fromArray(K),Q=new pt().fromArray(se);function ee($,de,le){const Se=new Uint8Array(4),ve=r.createTexture();r.bindTexture($,ve),r.texParameteri($,10241,9728),r.texParameteri($,10240,9728);for(let Ee=0;Ee<le;Ee++)r.texImage2D(de+Ee,0,6408,1,1,0,6408,5121,Se);return ve}const ge={};ge[3553]=ee(3553,3553,1),ge[34067]=ee(34067,34069,6),o.setClear(0,0,0,1),c.setClear(1),l.setClear(0),he(2929),c.setFunc(Vl),Ye(!1),te(s1),he(2884),Re(Dr);function he($){u[$]!==!0&&(r.enable($),u[$]=!0)}function Me($){u[$]!==!1&&(r.disable($),u[$]=!1)}function je($,de){return h[$]!==de?(r.bindFramebuffer($,de),h[$]=de,n&&($===36009&&(h[36160]=de),$===36160&&(h[36009]=de)),!0):!1}function ae($){return d!==$?(r.useProgram($),d=$,!0):!1}const Ve={[ci]:32774,[pE]:32778,[fE]:32779};if(n)Ve[l1]=32775,Ve[h1]=32776;else{const $=e.get("EXT_blend_minmax");$!==null&&(Ve[l1]=$.MIN_EXT,Ve[h1]=$.MAX_EXT)}const He={[mE]:0,[gE]:1,[yE]:768,[d1]:770,[SE]:776,[vE]:774,[xE]:772,[_E]:769,[p1]:771,[wE]:775,[bE]:773};function Re($,de,le,Se,ve,Ee,Ce,qe){if($===Dr){p===!0&&(Me(3042),p=!1);return}if(p===!1&&(he(3042),p=!0),$!==dE){if($!==f||qe!==T){if((m!==ci||y!==ci)&&(r.blendEquation(32774),m=ci,y=ci),qe)switch($){case va:r.blendFuncSeparate(1,771,1,771);break;case o1:r.blendFunc(1,1);break;case c1:r.blendFuncSeparate(0,0,769,771);break;case u1:r.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",$);break}else switch($){case va:r.blendFuncSeparate(770,771,1,771);break;case o1:r.blendFunc(770,1);break;case c1:r.blendFunc(0,769);break;case u1:r.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",$);break}_=null,g=null,x=null,w=null,f=$,T=qe}return}ve=ve||de,Ee=Ee||le,Ce=Ce||Se,(de!==m||ve!==y)&&(r.blendEquationSeparate(Ve[de],Ve[ve]),m=de,y=ve),(le!==_||Se!==g||Ee!==x||Ce!==w)&&(r.blendFuncSeparate(He[le],He[Se],He[Ee],He[Ce]),_=le,g=Se,x=Ee,w=Ce),f=$,T=null}function ze($,de){$.side===ys?Me(2884):he(2884);let le=$.side===zt;de&&(le=!le),Ye(le),$.blending===va&&$.transparent===!1?Re(Dr):Re($.blending,$.blendEquation,$.blendSrc,$.blendDst,$.blendEquationAlpha,$.blendSrcAlpha,$.blendDstAlpha,$.premultipliedAlpha),c.setFunc($.depthFunc),c.setTest($.depthTest),c.setMask($.depthWrite),o.setMask($.colorWrite);const Se=$.stencilWrite;l.setTest(Se),Se&&(l.setMask($.stencilWriteMask),l.setFunc($.stencilFunc,$.stencilRef,$.stencilFuncMask),l.setOp($.stencilFail,$.stencilZFail,$.stencilZPass)),me($.polygonOffset,$.polygonOffsetFactor,$.polygonOffsetUnits),$.alphaToCoverage===!0?he(32926):Me(32926)}function Ye($){M!==$&&($?r.frontFace(2304):r.frontFace(2305),M=$)}function te($){$!==uE?(he(2884),$!==S&&($===s1?r.cullFace(1029):$===lE?r.cullFace(1028):r.cullFace(1032))):Me(2884),S=$}function ie($){$!==R&&(Y&&r.lineWidth($),R=$)}function me($,de,le){$?(he(32823),(k!==de||O!==le)&&(r.polygonOffset(de,le),k=de,O=le)):Me(32823)}function Ie($){$?he(3089):Me(3089)}function be($){$===void 0&&($=33984+A-1),U!==$&&(r.activeTexture($),U=$)}function Ge($,de){U===null&&be();let le=j[U];le===void 0&&(le={type:void 0,texture:void 0},j[U]=le),(le.type!==$||le.texture!==de)&&(r.bindTexture($,de||ge[$]),le.type=$,le.texture=de)}function $e(){const $=j[U];$!==void 0&&$.type!==void 0&&(r.bindTexture($.type,null),$.type=void 0,$.texture=void 0)}function We(){try{r.compressedTexImage2D.apply(r,arguments)}catch($){console.error("THREE.WebGLState:",$)}}function ot(){try{r.texSubImage2D.apply(r,arguments)}catch($){console.error("THREE.WebGLState:",$)}}function D(){try{r.texStorage2D.apply(r,arguments)}catch($){console.error("THREE.WebGLState:",$)}}function I(){try{r.texImage2D.apply(r,arguments)}catch($){console.error("THREE.WebGLState:",$)}}function oe(){try{r.texImage3D.apply(r,arguments)}catch($){console.error("THREE.WebGLState:",$)}}function ce($){ue.equals($)===!1&&(r.scissor($.x,$.y,$.z,$.w),ue.copy($))}function ke($){Q.equals($)===!1&&(r.viewport($.x,$.y,$.z,$.w),Q.copy($))}function Pe(){r.disable(3042),r.disable(2884),r.disable(2929),r.disable(32823),r.disable(3089),r.disable(2960),r.disable(32926),r.blendEquation(32774),r.blendFunc(1,0),r.blendFuncSeparate(1,0,1,0),r.colorMask(!0,!0,!0,!0),r.clearColor(0,0,0,0),r.depthMask(!0),r.depthFunc(513),r.clearDepth(1),r.stencilMask(4294967295),r.stencilFunc(519,0,4294967295),r.stencilOp(7680,7680,7680),r.clearStencil(0),r.cullFace(1029),r.frontFace(2305),r.polygonOffset(0,0),r.activeTexture(33984),r.bindFramebuffer(36160,null),n===!0&&(r.bindFramebuffer(36009,null),r.bindFramebuffer(36008,null)),r.useProgram(null),r.lineWidth(1),r.scissor(0,0,r.canvas.width,r.canvas.height),r.viewport(0,0,r.canvas.width,r.canvas.height),u={},U=null,j={},h={},d=null,p=!1,f=null,m=null,_=null,g=null,y=null,x=null,w=null,T=!1,M=null,S=null,R=null,k=null,O=null,ue.set(0,0,r.canvas.width,r.canvas.height),Q.set(0,0,r.canvas.width,r.canvas.height),o.reset(),c.reset(),l.reset()}return{buffers:{color:o,depth:c,stencil:l},enable:he,disable:Me,bindFramebuffer:je,useProgram:ae,setBlending:Re,setMaterial:ze,setFlipSided:Ye,setCullFace:te,setLineWidth:ie,setPolygonOffset:me,setScissorTest:Ie,activeTexture:be,bindTexture:Ge,unbindTexture:$e,compressedTexImage2D:We,texImage2D:I,texImage3D:oe,texStorage2D:D,texSubImage2D:ot,scissor:ce,viewport:ke,reset:Pe}}function IC(r,e,t,n,s,i,a){const o=s.isWebGL2,c=s.maxTextures,l=s.maxCubemapSize,u=s.maxTextureSize,h=s.maxSamples,p=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):void 0,f=new WeakMap;let m,_=!1;try{_=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function g(D,I){return _?new OffscreenCanvas(D,I):Uo("canvas")}function y(D,I,oe,ce){let ke=1;if((D.width>ce||D.height>ce)&&(ke=ce/Math.max(D.width,D.height)),ke<1||I===!0)if(typeof HTMLImageElement!="undefined"&&D instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&D instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&D instanceof ImageBitmap){const Pe=I?k1:Math.floor,$=Pe(ke*D.width),de=Pe(ke*D.height);m===void 0&&(m=g($,de));const le=oe?g($,de):m;return le.width=$,le.height=de,le.getContext("2d").drawImage(D,0,0,$,de),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+D.width+"x"+D.height+") to ("+$+"x"+de+")."),le}else return"data"in D&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+D.width+"x"+D.height+")."),D;return D}function x(D){return Ql(D.width)&&Ql(D.height)}function w(D){return o?!1:D.wrapS!==mn||D.wrapT!==mn||D.minFilter!==Ut&&D.minFilter!==gn}function T(D,I){return D.generateMipmaps&&I&&D.minFilter!==Ut&&D.minFilter!==gn}function M(D){r.generateMipmap(D)}function S(D,I,oe){if(o===!1)return I;if(D!==null){if(r[D]!==void 0)return r[D];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+D+"'")}let ce=I;return I===6403&&(oe===5126&&(ce=33326),oe===5131&&(ce=33325),oe===5121&&(ce=33321)),I===6407&&(oe===5126&&(ce=34837),oe===5131&&(ce=34843),oe===5121&&(ce=32849)),I===6408&&(oe===5126&&(ce=34836),oe===5131&&(ce=34842),oe===5121&&(ce=32856)),(ce===33325||ce===33326||ce===34842||ce===34836)&&e.get("EXT_color_buffer_float"),ce}function R(D,I,oe){return T(D,oe)===!0?Math.log2(Math.max(I.width,I.height))+1:D.mipmaps.length>0?D.mipmaps.length:1}function k(D){return D===Ut||D===Wl||D===jl?9728:9729}function O(D){const I=D.target;I.removeEventListener("dispose",O),Y(I),I.isVideoTexture&&f.delete(I),a.memory.textures--}function A(D){const I=D.target;I.removeEventListener("dispose",A),B(I)}function Y(D){const I=n.get(D);I.__webglInit!==void 0&&(r.deleteTexture(I.__webglTexture),n.remove(D))}function B(D){const I=D.texture,oe=n.get(D),ce=n.get(I);if(!!D){if(ce.__webglTexture!==void 0&&(r.deleteTexture(ce.__webglTexture),a.memory.textures--),D.depthTexture&&D.depthTexture.dispose(),D.isWebGLCubeRenderTarget)for(let ke=0;ke<6;ke++)r.deleteFramebuffer(oe.__webglFramebuffer[ke]),oe.__webglDepthbuffer&&r.deleteRenderbuffer(oe.__webglDepthbuffer[ke]);else r.deleteFramebuffer(oe.__webglFramebuffer),oe.__webglDepthbuffer&&r.deleteRenderbuffer(oe.__webglDepthbuffer),oe.__webglMultisampledFramebuffer&&r.deleteFramebuffer(oe.__webglMultisampledFramebuffer),oe.__webglColorRenderbuffer&&r.deleteRenderbuffer(oe.__webglColorRenderbuffer),oe.__webglDepthRenderbuffer&&r.deleteRenderbuffer(oe.__webglDepthRenderbuffer);if(D.isWebGLMultipleRenderTargets)for(let ke=0,Pe=I.length;ke<Pe;ke++){const $=n.get(I[ke]);$.__webglTexture&&(r.deleteTexture($.__webglTexture),a.memory.textures--),n.remove(I[ke])}n.remove(I),n.remove(D)}}let H=0;function U(){H=0}function j(){const D=H;return D>=c&&console.warn("THREE.WebGLTextures: Trying to use "+D+" texture units while this GPU supports only "+c),H+=1,D}function K(D,I){const oe=n.get(D);if(D.isVideoTexture&&be(D),D.version>0&&oe.__version!==D.version){const ce=D.image;if(ce===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(ce.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{je(oe,D,I);return}}t.activeTexture(33984+I),t.bindTexture(3553,oe.__webglTexture)}function se(D,I){const oe=n.get(D);if(D.version>0&&oe.__version!==D.version){je(oe,D,I);return}t.activeTexture(33984+I),t.bindTexture(35866,oe.__webglTexture)}function ue(D,I){const oe=n.get(D);if(D.version>0&&oe.__version!==D.version){je(oe,D,I);return}t.activeTexture(33984+I),t.bindTexture(32879,oe.__webglTexture)}function Q(D,I){const oe=n.get(D);if(D.version>0&&oe.__version!==D.version){ae(oe,D,I);return}t.activeTexture(33984+I),t.bindTexture(34067,oe.__webglTexture)}const ee={[ui]:10497,[mn]:33071,[Po]:33648},ge={[Ut]:9728,[Wl]:9984,[jl]:9986,[gn]:9729,[m1]:9985,[li]:9987};function he(D,I,oe){if(oe?(r.texParameteri(D,10242,ee[I.wrapS]),r.texParameteri(D,10243,ee[I.wrapT]),(D===32879||D===35866)&&r.texParameteri(D,32882,ee[I.wrapR]),r.texParameteri(D,10240,ge[I.magFilter]),r.texParameteri(D,10241,ge[I.minFilter])):(r.texParameteri(D,10242,33071),r.texParameteri(D,10243,33071),(D===32879||D===35866)&&r.texParameteri(D,32882,33071),(I.wrapS!==mn||I.wrapT!==mn)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),r.texParameteri(D,10240,k(I.magFilter)),r.texParameteri(D,10241,k(I.minFilter)),I.minFilter!==Ut&&I.minFilter!==gn&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){const ce=e.get("EXT_texture_filter_anisotropic");if(I.type===ar&&e.has("OES_texture_float_linear")===!1||o===!1&&I.type===hi&&e.has("OES_texture_half_float_linear")===!1)return;(I.anisotropy>1||n.get(I).__currentAnisotropy)&&(r.texParameterf(D,ce.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(I.anisotropy,s.getMaxAnisotropy())),n.get(I).__currentAnisotropy=I.anisotropy)}}function Me(D,I){D.__webglInit===void 0&&(D.__webglInit=!0,I.addEventListener("dispose",O),D.__webglTexture=r.createTexture(),a.memory.textures++)}function je(D,I,oe){let ce=3553;I.isDataTexture2DArray&&(ce=35866),I.isDataTexture3D&&(ce=32879),Me(D,I),t.activeTexture(33984+oe),t.bindTexture(ce,D.__webglTexture),r.pixelStorei(37440,I.flipY),r.pixelStorei(37441,I.premultiplyAlpha),r.pixelStorei(3317,I.unpackAlignment),r.pixelStorei(37443,0);const ke=w(I)&&x(I.image)===!1,Pe=y(I.image,ke,!1,u),$=x(Pe)||o,de=i.convert(I.format);let le=i.convert(I.type),Se=S(I.internalFormat,de,le,I.encoding);he(ce,I,$);let ve;const Ee=I.mipmaps;if(I.isDepthTexture)Se=6402,o?I.type===ar?Se=36012:I.type===Fo?Se=33190:I.type===di?Se=35056:Se=33189:I.type===ar&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),I.format===xs&&Se===6402&&I.type!==Ta&&I.type!==Fo&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),I.type=Ta,le=i.convert(I.type)),I.format===pi&&Se===6402&&(Se=34041,I.type!==di&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),I.type=di,le=i.convert(I.type))),t.texImage2D(3553,0,Se,Pe.width,Pe.height,0,de,le,null);else if(I.isDataTexture)if(Ee.length>0&&$){for(let Ce=0,qe=Ee.length;Ce<qe;Ce++)ve=Ee[Ce],t.texImage2D(3553,Ce,Se,ve.width,ve.height,0,de,le,ve.data);I.generateMipmaps=!1}else t.texImage2D(3553,0,Se,Pe.width,Pe.height,0,de,le,Pe.data);else if(I.isCompressedTexture)for(let Ce=0,qe=Ee.length;Ce<qe;Ce++)ve=Ee[Ce],I.format!==sn&&I.format!==Fr?de!==null?t.compressedTexImage2D(3553,Ce,Se,ve.width,ve.height,0,ve.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):t.texImage2D(3553,Ce,Se,ve.width,ve.height,0,de,le,ve.data);else if(I.isDataTexture2DArray)t.texImage3D(35866,0,Se,Pe.width,Pe.height,Pe.depth,0,de,le,Pe.data);else if(I.isDataTexture3D)t.texImage3D(32879,0,Se,Pe.width,Pe.height,Pe.depth,0,de,le,Pe.data);else{const Ce=R(I,Pe,$),qe=o&&I.isVideoTexture!==!0,_t=D.__version===void 0;if(Ee.length>0&&$){qe&&_t&&t.texStorage2D(3553,Ce,Se,Ee[0].width,Ee[0].height);for(let Je=0,en=Ee.length;Je<en;Je++)ve=Ee[Je],qe?t.texSubImage2D(3553,Je,0,0,de,le,ve):t.texImage2D(3553,Je,Se,de,le,ve);I.generateMipmaps=!1}else qe?(_t&&t.texStorage2D(3553,Ce,Se,Pe.width,Pe.height),t.texSubImage2D(3553,0,0,0,de,le,Pe)):t.texImage2D(3553,0,Se,de,le,Pe)}T(I,$)&&M(ce),D.__version=I.version,I.onUpdate&&I.onUpdate(I)}function ae(D,I,oe){if(I.image.length!==6)return;Me(D,I),t.activeTexture(33984+oe),t.bindTexture(34067,D.__webglTexture),r.pixelStorei(37440,I.flipY),r.pixelStorei(37441,I.premultiplyAlpha),r.pixelStorei(3317,I.unpackAlignment),r.pixelStorei(37443,0);const ce=I&&(I.isCompressedTexture||I.image[0].isCompressedTexture),ke=I.image[0]&&I.image[0].isDataTexture,Pe=[];for(let Ce=0;Ce<6;Ce++)!ce&&!ke?Pe[Ce]=y(I.image[Ce],!1,!0,l):Pe[Ce]=ke?I.image[Ce].image:I.image[Ce];const $=Pe[0],de=x($)||o,le=i.convert(I.format),Se=i.convert(I.type),ve=S(I.internalFormat,le,Se,I.encoding);he(34067,I,de);let Ee;if(ce)for(let Ce=0;Ce<6;Ce++){Ee=Pe[Ce].mipmaps;for(let qe=0;qe<Ee.length;qe++){const _t=Ee[qe];I.format!==sn&&I.format!==Fr?le!==null?t.compressedTexImage2D(34069+Ce,qe,ve,_t.width,_t.height,0,_t.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):t.texImage2D(34069+Ce,qe,ve,_t.width,_t.height,0,le,Se,_t.data)}}else{Ee=I.mipmaps;for(let Ce=0;Ce<6;Ce++)if(ke){t.texImage2D(34069+Ce,0,ve,Pe[Ce].width,Pe[Ce].height,0,le,Se,Pe[Ce].data);for(let qe=0;qe<Ee.length;qe++){const Je=Ee[qe].image[Ce].image;t.texImage2D(34069+Ce,qe+1,ve,Je.width,Je.height,0,le,Se,Je.data)}}else{t.texImage2D(34069+Ce,0,ve,le,Se,Pe[Ce]);for(let qe=0;qe<Ee.length;qe++){const _t=Ee[qe];t.texImage2D(34069+Ce,qe+1,ve,le,Se,_t.image[Ce])}}}T(I,de)&&M(34067),D.__version=I.version,I.onUpdate&&I.onUpdate(I)}function Ve(D,I,oe,ce,ke){const Pe=i.convert(oe.format),$=i.convert(oe.type),de=S(oe.internalFormat,Pe,$,oe.encoding);n.get(I).__hasExternalTextures||(ke===32879||ke===35866?t.texImage3D(ke,0,de,I.width,I.height,I.depth,0,Pe,$,null):t.texImage2D(ke,0,de,I.width,I.height,0,Pe,$,null)),t.bindFramebuffer(36160,D),I.useRenderToTexture?p.framebufferTexture2DMultisampleEXT(36160,ce,ke,n.get(oe).__webglTexture,0,Ie(I)):r.framebufferTexture2D(36160,ce,ke,n.get(oe).__webglTexture,0),t.bindFramebuffer(36160,null)}function He(D,I,oe){if(r.bindRenderbuffer(36161,D),I.depthBuffer&&!I.stencilBuffer){let ce=33189;if(oe||I.useRenderToTexture){const ke=I.depthTexture;ke&&ke.isDepthTexture&&(ke.type===ar?ce=36012:ke.type===Fo&&(ce=33190));const Pe=Ie(I);I.useRenderToTexture?p.renderbufferStorageMultisampleEXT(36161,Pe,ce,I.width,I.height):r.renderbufferStorageMultisample(36161,Pe,ce,I.width,I.height)}else r.renderbufferStorage(36161,ce,I.width,I.height);r.framebufferRenderbuffer(36160,36096,36161,D)}else if(I.depthBuffer&&I.stencilBuffer){const ce=Ie(I);oe&&I.useRenderbuffer?r.renderbufferStorageMultisample(36161,ce,35056,I.width,I.height):I.useRenderToTexture?p.renderbufferStorageMultisampleEXT(36161,ce,35056,I.width,I.height):r.renderbufferStorage(36161,34041,I.width,I.height),r.framebufferRenderbuffer(36160,33306,36161,D)}else{const ce=I.isWebGLMultipleRenderTargets===!0?I.texture[0]:I.texture,ke=i.convert(ce.format),Pe=i.convert(ce.type),$=S(ce.internalFormat,ke,Pe,ce.encoding),de=Ie(I);oe&&I.useRenderbuffer?r.renderbufferStorageMultisample(36161,de,$,I.width,I.height):I.useRenderToTexture?p.renderbufferStorageMultisampleEXT(36161,de,$,I.width,I.height):r.renderbufferStorage(36161,$,I.width,I.height)}r.bindRenderbuffer(36161,null)}function Re(D,I){if(I&&I.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,D),!(I.depthTexture&&I.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(I.depthTexture).__webglTexture||I.depthTexture.image.width!==I.width||I.depthTexture.image.height!==I.height)&&(I.depthTexture.image.width=I.width,I.depthTexture.image.height=I.height,I.depthTexture.needsUpdate=!0),K(I.depthTexture,0);const ce=n.get(I.depthTexture).__webglTexture,ke=Ie(I);if(I.depthTexture.format===xs)I.useRenderToTexture?p.framebufferTexture2DMultisampleEXT(36160,36096,3553,ce,0,ke):r.framebufferTexture2D(36160,36096,3553,ce,0);else if(I.depthTexture.format===pi)I.useRenderToTexture?p.framebufferTexture2DMultisampleEXT(36160,33306,3553,ce,0,ke):r.framebufferTexture2D(36160,33306,3553,ce,0);else throw new Error("Unknown depthTexture format")}function ze(D){const I=n.get(D),oe=D.isWebGLCubeRenderTarget===!0;if(D.depthTexture&&!I.__autoAllocateDepthBuffer){if(oe)throw new Error("target.depthTexture not supported in Cube render targets");Re(I.__webglFramebuffer,D)}else if(oe){I.__webglDepthbuffer=[];for(let ce=0;ce<6;ce++)t.bindFramebuffer(36160,I.__webglFramebuffer[ce]),I.__webglDepthbuffer[ce]=r.createRenderbuffer(),He(I.__webglDepthbuffer[ce],D,!1)}else t.bindFramebuffer(36160,I.__webglFramebuffer),I.__webglDepthbuffer=r.createRenderbuffer(),He(I.__webglDepthbuffer,D,!1);t.bindFramebuffer(36160,null)}function Ye(D,I,oe){const ce=n.get(D);I!==void 0&&Ve(ce.__webglFramebuffer,D,D.texture,36064,3553),oe!==void 0&&ze(D)}function te(D){const I=D.texture,oe=n.get(D),ce=n.get(I);D.addEventListener("dispose",A),D.isWebGLMultipleRenderTargets!==!0&&(ce.__webglTexture===void 0&&(ce.__webglTexture=r.createTexture()),ce.__version=I.version,a.memory.textures++);const ke=D.isWebGLCubeRenderTarget===!0,Pe=D.isWebGLMultipleRenderTargets===!0,$=I.isDataTexture3D||I.isDataTexture2DArray,de=x(D)||o;if(o&&I.format===Fr&&(I.type===ar||I.type===hi)&&(I.format=sn,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),ke){oe.__webglFramebuffer=[];for(let le=0;le<6;le++)oe.__webglFramebuffer[le]=r.createFramebuffer()}else if(oe.__webglFramebuffer=r.createFramebuffer(),Pe)if(s.drawBuffers){const le=D.texture;for(let Se=0,ve=le.length;Se<ve;Se++){const Ee=n.get(le[Se]);Ee.__webglTexture===void 0&&(Ee.__webglTexture=r.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(D.useRenderbuffer)if(o){oe.__webglMultisampledFramebuffer=r.createFramebuffer(),oe.__webglColorRenderbuffer=r.createRenderbuffer(),r.bindRenderbuffer(36161,oe.__webglColorRenderbuffer);const le=i.convert(I.format),Se=i.convert(I.type),ve=S(I.internalFormat,le,Se,I.encoding),Ee=Ie(D);r.renderbufferStorageMultisample(36161,Ee,ve,D.width,D.height),t.bindFramebuffer(36160,oe.__webglMultisampledFramebuffer),r.framebufferRenderbuffer(36160,36064,36161,oe.__webglColorRenderbuffer),r.bindRenderbuffer(36161,null),D.depthBuffer&&(oe.__webglDepthRenderbuffer=r.createRenderbuffer(),He(oe.__webglDepthRenderbuffer,D,!0)),t.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(ke){t.bindTexture(34067,ce.__webglTexture),he(34067,I,de);for(let le=0;le<6;le++)Ve(oe.__webglFramebuffer[le],D,I,36064,34069+le);T(I,de)&&M(34067),t.unbindTexture()}else if(Pe){const le=D.texture;for(let Se=0,ve=le.length;Se<ve;Se++){const Ee=le[Se],Ce=n.get(Ee);t.bindTexture(3553,Ce.__webglTexture),he(3553,Ee,de),Ve(oe.__webglFramebuffer,D,Ee,36064+Se,3553),T(Ee,de)&&M(3553)}t.unbindTexture()}else{let le=3553;$&&(o?le=I.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),t.bindTexture(le,ce.__webglTexture),he(le,I,de),Ve(oe.__webglFramebuffer,D,I,36064,le),T(I,de)&&M(le),t.unbindTexture()}D.depthBuffer&&ze(D)}function ie(D){const I=x(D)||o,oe=D.isWebGLMultipleRenderTargets===!0?D.texture:[D.texture];for(let ce=0,ke=oe.length;ce<ke;ce++){const Pe=oe[ce];if(T(Pe,I)){const $=D.isWebGLCubeRenderTarget?34067:3553,de=n.get(Pe).__webglTexture;t.bindTexture($,de),M($),t.unbindTexture()}}}function me(D){if(D.useRenderbuffer)if(o){const I=D.width,oe=D.height;let ce=16384;const ke=[36064],Pe=D.stencilBuffer?33306:36096;D.depthBuffer&&ke.push(Pe),D.ignoreDepthForMultisampleCopy||(D.depthBuffer&&(ce|=256),D.stencilBuffer&&(ce|=1024));const $=n.get(D);t.bindFramebuffer(36008,$.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,$.__webglFramebuffer),D.ignoreDepthForMultisampleCopy&&(r.invalidateFramebuffer(36008,[Pe]),r.invalidateFramebuffer(36009,[Pe])),r.blitFramebuffer(0,0,I,oe,0,0,I,oe,ce,9728),r.invalidateFramebuffer(36008,ke),t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,$.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function Ie(D){return o&&(D.useRenderbuffer||D.useRenderToTexture)?Math.min(h,D.samples):0}function be(D){const I=a.render.frame;f.get(D)!==I&&(f.set(D,I),D.update())}let Ge=!1,$e=!1;function We(D,I){D&&D.isWebGLRenderTarget&&(Ge===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),Ge=!0),D=D.texture),K(D,I)}function ot(D,I){D&&D.isWebGLCubeRenderTarget&&($e===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),$e=!0),D=D.texture),Q(D,I)}this.allocateTextureUnit=j,this.resetTextureUnits=U,this.setTexture2D=K,this.setTexture2DArray=se,this.setTexture3D=ue,this.setTextureCube=Q,this.rebindTextures=Ye,this.setupRenderTarget=te,this.updateRenderTargetMipmap=ie,this.updateMultisampleRenderTarget=me,this.setupDepthRenderbuffer=ze,this.setupFrameBufferTexture=Ve,this.safeSetTexture2D=We,this.safeSetTextureCube=ot}function NC(r,e,t){const n=t.isWebGL2;function s(i){let a;if(i===Pr)return 5121;if(i===VE)return 32819;if(i===HE)return 32820;if(i===$E)return 33635;if(i===BE)return 5120;if(i===zE)return 5122;if(i===Ta)return 5123;if(i===UE)return 5124;if(i===Fo)return 5125;if(i===ar)return 5126;if(i===hi)return n?5131:(a=e.get("OES_texture_half_float"),a!==null?a.HALF_FLOAT_OES:null);if(i===GE)return 6406;if(i===Fr)return 6407;if(i===sn)return 6408;if(i===WE)return 6409;if(i===jE)return 6410;if(i===xs)return 6402;if(i===pi)return 34041;if(i===KE)return 6403;if(i===XE)return 36244;if(i===YE)return 33319;if(i===JE)return 33320;if(i===ZE)return 36248;if(i===QE)return 36249;if(i===g1||i===y1||i===_1||i===x1)if(a=e.get("WEBGL_compressed_texture_s3tc"),a!==null){if(i===g1)return a.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===y1)return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===_1)return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===x1)return a.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(i===b1||i===v1||i===w1||i===S1)if(a=e.get("WEBGL_compressed_texture_pvrtc"),a!==null){if(i===b1)return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===v1)return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===w1)return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===S1)return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(i===eM)return a=e.get("WEBGL_compressed_texture_etc1"),a!==null?a.COMPRESSED_RGB_ETC1_WEBGL:null;if((i===T1||i===E1)&&(a=e.get("WEBGL_compressed_texture_etc"),a!==null)){if(i===T1)return a.COMPRESSED_RGB8_ETC2;if(i===E1)return a.COMPRESSED_RGBA8_ETC2_EAC}if(i===tM||i===nM||i===rM||i===sM||i===iM||i===aM||i===oM||i===cM||i===uM||i===lM||i===hM||i===dM||i===pM||i===fM||i===gM||i===yM||i===_M||i===xM||i===bM||i===vM||i===wM||i===SM||i===TM||i===EM||i===MM||i===AM||i===IM||i===NM)return a=e.get("WEBGL_compressed_texture_astc"),a!==null?i:null;if(i===mM)return a=e.get("EXT_texture_compression_bptc"),a!==null?i:null;if(i===di)return n?34042:(a=e.get("WEBGL_depth_texture"),a!==null?a.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:s}}class Dg extends dn{constructor(e=[]){super();this.cameras=e}}Dg.prototype.isArrayCamera=!0;class qr extends it{constructor(){super();this.type="Group"}}qr.prototype.isGroup=!0;const RC={type:"move"};class kh{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new qr,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new qr,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new L,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new L),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new qr,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new L,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new L),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,n){let s=null,i=null,a=null;const o=this._targetRay,c=this._grip,l=this._hand;if(e&&t.session.visibilityState!=="visible-blurred")if(o!==null&&(s=t.getPose(e.targetRaySpace,n),s!==null&&(o.matrix.fromArray(s.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),s.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(s.linearVelocity)):o.hasLinearVelocity=!1,s.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(s.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(RC))),l&&e.hand){a=!0;for(const m of e.hand.values()){const _=t.getJointPose(m,n);if(l.joints[m.jointName]===void 0){const y=new qr;y.matrixAutoUpdate=!1,y.visible=!1,l.joints[m.jointName]=y,l.add(y)}const g=l.joints[m.jointName];_!==null&&(g.matrix.fromArray(_.transform.matrix),g.matrix.decompose(g.position,g.rotation,g.scale),g.jointRadius=_.radius),g.visible=_!==null}const u=l.joints["index-finger-tip"],h=l.joints["thumb-tip"],d=u.position.distanceTo(h.position),p=.02,f=.005;l.inputState.pinching&&d>p+f?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!l.inputState.pinching&&d<=p-f&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else c!==null&&e.gripSpace&&(i=t.getPose(e.gripSpace,n),i!==null&&(c.matrix.fromArray(i.transform.matrix),c.matrix.decompose(c.position,c.rotation,c.scale),i.linearVelocity?(c.hasLinearVelocity=!0,c.linearVelocity.copy(i.linearVelocity)):c.hasLinearVelocity=!1,i.angularVelocity?(c.hasAngularVelocity=!0,c.angularVelocity.copy(i.angularVelocity)):c.hasAngularVelocity=!1));return o!==null&&(o.visible=s!==null),c!==null&&(c.visible=i!==null),l!==null&&(l.visible=a!==null),this}}class Dh extends Vt{constructor(e,t,n,s,i,a,o,c,l,u){if(u=u!==void 0?u:xs,u!==xs&&u!==pi)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&u===xs&&(n=Ta),n===void 0&&u===pi&&(n=di);super(null,s,i,a,o,c,u,n,l);this.image={width:e,height:t},this.magFilter=o!==void 0?o:Ut,this.minFilter=c!==void 0?c:Ut,this.flipY=!1,this.generateMipmaps=!1}}Dh.prototype.isDepthTexture=!0;class CC extends vs{constructor(e,t){super();const n=this;let s=null,i=1,a=null,o="local-floor";const c=e.extensions.has("WEBGL_multisampled_render_to_texture");let l=null,u=null,h=null,d=null,p=!1,f=null;const m=t.getContextAttributes();let _=null,g=null;const y=[],x=new Map,w=new dn;w.layers.enable(1),w.viewport=new pt;const T=new dn;T.layers.enable(2),T.viewport=new pt;const M=[w,T],S=new Dg;S.layers.enable(1),S.layers.enable(2);let R=null,k=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(Q){let ee=y[Q];return ee===void 0&&(ee=new kh,y[Q]=ee),ee.getTargetRaySpace()},this.getControllerGrip=function(Q){let ee=y[Q];return ee===void 0&&(ee=new kh,y[Q]=ee),ee.getGripSpace()},this.getHand=function(Q){let ee=y[Q];return ee===void 0&&(ee=new kh,y[Q]=ee),ee.getHandSpace()};function O(Q){const ee=x.get(Q.inputSource);ee&&ee.dispatchEvent({type:Q.type,data:Q.inputSource})}function A(){x.forEach(function(Q,ee){Q.disconnect(ee)}),x.clear(),R=null,k=null,e.setRenderTarget(_),d=null,h=null,u=null,s=null,g=null,ue.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(Q){i=Q,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(Q){o=Q,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return a},this.getBaseLayer=function(){return h!==null?h:d},this.getBinding=function(){return u},this.getFrame=function(){return f},this.getSession=function(){return s},this.setSession=async function(Q){if(s=Q,s!==null){if(_=e.getRenderTarget(),s.addEventListener("select",O),s.addEventListener("selectstart",O),s.addEventListener("selectend",O),s.addEventListener("squeeze",O),s.addEventListener("squeezestart",O),s.addEventListener("squeezeend",O),s.addEventListener("end",A),s.addEventListener("inputsourceschange",Y),m.xrCompatible!==!0&&await t.makeXRCompatible(),s.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const ee={antialias:s.renderState.layers===void 0?m.antialias:!0,alpha:m.alpha,depth:m.depth,stencil:m.stencil,framebufferScaleFactor:i};d=new XRWebGLLayer(s,t,ee),s.updateRenderState({baseLayer:d}),g=new Rn(d.framebufferWidth,d.framebufferHeight)}else{p=m.antialias;let ee=null,ge=null,he=null;m.depth&&(he=m.stencil?35056:33189,ee=m.stencil?pi:xs,ge=m.stencil?di:Ta);const Me={colorFormat:m.alpha||p?32856:32849,depthFormat:he,scaleFactor:i};u=new XRWebGLBinding(s,t),h=u.createProjectionLayer(Me),s.updateRenderState({layers:[h]}),p?g=new th(h.textureWidth,h.textureHeight,{format:sn,type:Pr,depthTexture:new Dh(h.textureWidth,h.textureHeight,ge,void 0,void 0,void 0,void 0,void 0,void 0,ee),stencilBuffer:m.stencil,ignoreDepth:h.ignoreDepthValues,useRenderToTexture:c}):g=new Rn(h.textureWidth,h.textureHeight,{format:m.alpha?sn:Fr,type:Pr,depthTexture:new Dh(h.textureWidth,h.textureHeight,ge,void 0,void 0,void 0,void 0,void 0,void 0,ee),stencilBuffer:m.stencil,ignoreDepth:h.ignoreDepthValues})}this.setFoveation(0),a=await s.requestReferenceSpace(o),ue.setContext(s),ue.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}};function Y(Q){const ee=s.inputSources;for(let ge=0;ge<y.length;ge++)x.set(ee[ge],y[ge]);for(let ge=0;ge<Q.removed.length;ge++){const he=Q.removed[ge],Me=x.get(he);Me&&(Me.dispatchEvent({type:"disconnected",data:he}),x.delete(he))}for(let ge=0;ge<Q.added.length;ge++){const he=Q.added[ge],Me=x.get(he);Me&&Me.dispatchEvent({type:"connected",data:he})}}const B=new L,H=new L;function U(Q,ee,ge){B.setFromMatrixPosition(ee.matrixWorld),H.setFromMatrixPosition(ge.matrixWorld);const he=B.distanceTo(H),Me=ee.projectionMatrix.elements,je=ge.projectionMatrix.elements,ae=Me[14]/(Me[10]-1),Ve=Me[14]/(Me[10]+1),He=(Me[9]+1)/Me[5],Re=(Me[9]-1)/Me[5],ze=(Me[8]-1)/Me[0],Ye=(je[8]+1)/je[0],te=ae*ze,ie=ae*Ye,me=he/(-ze+Ye),Ie=me*-ze;ee.matrixWorld.decompose(Q.position,Q.quaternion,Q.scale),Q.translateX(Ie),Q.translateZ(me),Q.matrixWorld.compose(Q.position,Q.quaternion,Q.scale),Q.matrixWorldInverse.copy(Q.matrixWorld).invert();const be=ae+me,Ge=Ve+me,$e=te-Ie,We=ie+(he-Ie),ot=He*Ve/Ge*be,D=Re*Ve/Ge*be;Q.projectionMatrix.makePerspective($e,We,ot,D,be,Ge)}function j(Q,ee){ee===null?Q.matrixWorld.copy(Q.matrix):Q.matrixWorld.multiplyMatrices(ee.matrixWorld,Q.matrix),Q.matrixWorldInverse.copy(Q.matrixWorld).invert()}this.updateCamera=function(Q){if(s===null)return;S.near=T.near=w.near=Q.near,S.far=T.far=w.far=Q.far,(R!==S.near||k!==S.far)&&(s.updateRenderState({depthNear:S.near,depthFar:S.far}),R=S.near,k=S.far);const ee=Q.parent,ge=S.cameras;j(S,ee);for(let Me=0;Me<ge.length;Me++)j(ge[Me],ee);S.matrixWorld.decompose(S.position,S.quaternion,S.scale),Q.position.copy(S.position),Q.quaternion.copy(S.quaternion),Q.scale.copy(S.scale),Q.matrix.copy(S.matrix),Q.matrixWorld.copy(S.matrixWorld);const he=Q.children;for(let Me=0,je=he.length;Me<je;Me++)he[Me].updateMatrixWorld(!0);ge.length===2?U(S,w,T):S.projectionMatrix.copy(w.projectionMatrix)},this.getCamera=function(){return S},this.getFoveation=function(){if(h!==null)return h.fixedFoveation;if(d!==null)return d.fixedFoveation},this.setFoveation=function(Q){h!==null&&(h.fixedFoveation=Q),d!==null&&d.fixedFoveation!==void 0&&(d.fixedFoveation=Q)};let K=null;function se(Q,ee){if(l=ee.getViewerPose(a),f=ee,l!==null){const he=l.views;d!==null&&(e.setRenderTargetFramebuffer(g,d.framebuffer),e.setRenderTarget(g));let Me=!1;he.length!==S.cameras.length&&(S.cameras.length=0,Me=!0);for(let je=0;je<he.length;je++){const ae=he[je];let Ve=null;if(d!==null)Ve=d.getViewport(ae);else{const Re=u.getViewSubImage(h,ae);Ve=Re.viewport,je===0&&(e.setRenderTargetTextures(g,Re.colorTexture,h.ignoreDepthValues?void 0:Re.depthStencilTexture),e.setRenderTarget(g))}const He=M[je];He.matrix.fromArray(ae.transform.matrix),He.projectionMatrix.fromArray(ae.projectionMatrix),He.viewport.set(Ve.x,Ve.y,Ve.width,Ve.height),je===0&&S.matrix.copy(He.matrix),Me===!0&&S.cameras.push(He)}}const ge=s.inputSources;for(let he=0;he<y.length;he++){const Me=y[he],je=ge[he];Me.update(je,ee,a)}K&&K(Q,ee),f=null}const ue=new J1;ue.setAnimationLoop(se),this.setAnimationLoop=function(Q){K=Q},this.dispose=function(){}}}function LC(r){function e(g,y){g.fogColor.value.copy(y.color),y.isFog?(g.fogNear.value=y.near,g.fogFar.value=y.far):y.isFogExp2&&(g.fogDensity.value=y.density)}function t(g,y,x,w,T){y.isMeshBasicMaterial?n(g,y):y.isMeshLambertMaterial?(n(g,y),c(g,y)):y.isMeshToonMaterial?(n(g,y),u(g,y)):y.isMeshPhongMaterial?(n(g,y),l(g,y)):y.isMeshStandardMaterial?(n(g,y),y.isMeshPhysicalMaterial?d(g,y,T):h(g,y)):y.isMeshMatcapMaterial?(n(g,y),p(g,y)):y.isMeshDepthMaterial?(n(g,y),f(g,y)):y.isMeshDistanceMaterial?(n(g,y),m(g,y)):y.isMeshNormalMaterial?(n(g,y),_(g,y)):y.isLineBasicMaterial?(s(g,y),y.isLineDashedMaterial&&i(g,y)):y.isPointsMaterial?a(g,y,x,w):y.isSpriteMaterial?o(g,y):y.isShadowMaterial?(g.color.value.copy(y.color),g.opacity.value=y.opacity):y.isShaderMaterial&&(y.uniformsNeedUpdate=!1)}function n(g,y){g.opacity.value=y.opacity,y.color&&g.diffuse.value.copy(y.color),y.emissive&&g.emissive.value.copy(y.emissive).multiplyScalar(y.emissiveIntensity),y.map&&(g.map.value=y.map),y.alphaMap&&(g.alphaMap.value=y.alphaMap),y.specularMap&&(g.specularMap.value=y.specularMap),y.alphaTest>0&&(g.alphaTest.value=y.alphaTest);const x=r.get(y).envMap;x&&(g.envMap.value=x,g.flipEnvMap.value=x.isCubeTexture&&x.isRenderTargetTexture===!1?-1:1,g.reflectivity.value=y.reflectivity,g.ior.value=y.ior,g.refractionRatio.value=y.refractionRatio),y.lightMap&&(g.lightMap.value=y.lightMap,g.lightMapIntensity.value=y.lightMapIntensity),y.aoMap&&(g.aoMap.value=y.aoMap,g.aoMapIntensity.value=y.aoMapIntensity);let w;y.map?w=y.map:y.specularMap?w=y.specularMap:y.displacementMap?w=y.displacementMap:y.normalMap?w=y.normalMap:y.bumpMap?w=y.bumpMap:y.roughnessMap?w=y.roughnessMap:y.metalnessMap?w=y.metalnessMap:y.alphaMap?w=y.alphaMap:y.emissiveMap?w=y.emissiveMap:y.clearcoatMap?w=y.clearcoatMap:y.clearcoatNormalMap?w=y.clearcoatNormalMap:y.clearcoatRoughnessMap?w=y.clearcoatRoughnessMap:y.specularIntensityMap?w=y.specularIntensityMap:y.specularColorMap?w=y.specularColorMap:y.transmissionMap?w=y.transmissionMap:y.thicknessMap?w=y.thicknessMap:y.sheenColorMap?w=y.sheenColorMap:y.sheenRoughnessMap&&(w=y.sheenRoughnessMap),w!==void 0&&(w.isWebGLRenderTarget&&(w=w.texture),w.matrixAutoUpdate===!0&&w.updateMatrix(),g.uvTransform.value.copy(w.matrix));let T;y.aoMap?T=y.aoMap:y.lightMap&&(T=y.lightMap),T!==void 0&&(T.isWebGLRenderTarget&&(T=T.texture),T.matrixAutoUpdate===!0&&T.updateMatrix(),g.uv2Transform.value.copy(T.matrix))}function s(g,y){g.diffuse.value.copy(y.color),g.opacity.value=y.opacity}function i(g,y){g.dashSize.value=y.dashSize,g.totalSize.value=y.dashSize+y.gapSize,g.scale.value=y.scale}function a(g,y,x,w){g.diffuse.value.copy(y.color),g.opacity.value=y.opacity,g.size.value=y.size*x,g.scale.value=w*.5,y.map&&(g.map.value=y.map),y.alphaMap&&(g.alphaMap.value=y.alphaMap),y.alphaTest>0&&(g.alphaTest.value=y.alphaTest);let T;y.map?T=y.map:y.alphaMap&&(T=y.alphaMap),T!==void 0&&(T.matrixAutoUpdate===!0&&T.updateMatrix(),g.uvTransform.value.copy(T.matrix))}function o(g,y){g.diffuse.value.copy(y.color),g.opacity.value=y.opacity,g.rotation.value=y.rotation,y.map&&(g.map.value=y.map),y.alphaMap&&(g.alphaMap.value=y.alphaMap),y.alphaTest>0&&(g.alphaTest.value=y.alphaTest);let x;y.map?x=y.map:y.alphaMap&&(x=y.alphaMap),x!==void 0&&(x.matrixAutoUpdate===!0&&x.updateMatrix(),g.uvTransform.value.copy(x.matrix))}function c(g,y){y.emissiveMap&&(g.emissiveMap.value=y.emissiveMap)}function l(g,y){g.specular.value.copy(y.specular),g.shininess.value=Math.max(y.shininess,1e-4),y.emissiveMap&&(g.emissiveMap.value=y.emissiveMap),y.bumpMap&&(g.bumpMap.value=y.bumpMap,g.bumpScale.value=y.bumpScale,y.side===zt&&(g.bumpScale.value*=-1)),y.normalMap&&(g.normalMap.value=y.normalMap,g.normalScale.value.copy(y.normalScale),y.side===zt&&g.normalScale.value.negate()),y.displacementMap&&(g.displacementMap.value=y.displacementMap,g.displacementScale.value=y.displacementScale,g.displacementBias.value=y.displacementBias)}function u(g,y){y.gradientMap&&(g.gradientMap.value=y.gradientMap),y.emissiveMap&&(g.emissiveMap.value=y.emissiveMap),y.bumpMap&&(g.bumpMap.value=y.bumpMap,g.bumpScale.value=y.bumpScale,y.side===zt&&(g.bumpScale.value*=-1)),y.normalMap&&(g.normalMap.value=y.normalMap,g.normalScale.value.copy(y.normalScale),y.side===zt&&g.normalScale.value.negate()),y.displacementMap&&(g.displacementMap.value=y.displacementMap,g.displacementScale.value=y.displacementScale,g.displacementBias.value=y.displacementBias)}function h(g,y){g.roughness.value=y.roughness,g.metalness.value=y.metalness,y.roughnessMap&&(g.roughnessMap.value=y.roughnessMap),y.metalnessMap&&(g.metalnessMap.value=y.metalnessMap),y.emissiveMap&&(g.emissiveMap.value=y.emissiveMap),y.bumpMap&&(g.bumpMap.value=y.bumpMap,g.bumpScale.value=y.bumpScale,y.side===zt&&(g.bumpScale.value*=-1)),y.normalMap&&(g.normalMap.value=y.normalMap,g.normalScale.value.copy(y.normalScale),y.side===zt&&g.normalScale.value.negate()),y.displacementMap&&(g.displacementMap.value=y.displacementMap,g.displacementScale.value=y.displacementScale,g.displacementBias.value=y.displacementBias),r.get(y).envMap&&(g.envMapIntensity.value=y.envMapIntensity)}function d(g,y,x){h(g,y),g.ior.value=y.ior,y.sheen>0&&(g.sheenColor.value.copy(y.sheenColor).multiplyScalar(y.sheen),g.sheenRoughness.value=y.sheenRoughness,y.sheenColorMap&&(g.sheenColorMap.value=y.sheenColorMap),y.sheenRoughnessMap&&(g.sheenRoughnessMap.value=y.sheenRoughnessMap)),y.clearcoat>0&&(g.clearcoat.value=y.clearcoat,g.clearcoatRoughness.value=y.clearcoatRoughness,y.clearcoatMap&&(g.clearcoatMap.value=y.clearcoatMap),y.clearcoatRoughnessMap&&(g.clearcoatRoughnessMap.value=y.clearcoatRoughnessMap),y.clearcoatNormalMap&&(g.clearcoatNormalScale.value.copy(y.clearcoatNormalScale),g.clearcoatNormalMap.value=y.clearcoatNormalMap,y.side===zt&&g.clearcoatNormalScale.value.negate())),y.transmission>0&&(g.transmission.value=y.transmission,g.transmissionSamplerMap.value=x.texture,g.transmissionSamplerSize.value.set(x.width,x.height),y.transmissionMap&&(g.transmissionMap.value=y.transmissionMap),g.thickness.value=y.thickness,y.thicknessMap&&(g.thicknessMap.value=y.thicknessMap),g.attenuationDistance.value=y.attenuationDistance,g.attenuationColor.value.copy(y.attenuationColor)),g.specularIntensity.value=y.specularIntensity,g.specularColor.value.copy(y.specularColor),y.specularIntensityMap&&(g.specularIntensityMap.value=y.specularIntensityMap),y.specularColorMap&&(g.specularColorMap.value=y.specularColorMap)}function p(g,y){y.matcap&&(g.matcap.value=y.matcap),y.bumpMap&&(g.bumpMap.value=y.bumpMap,g.bumpScale.value=y.bumpScale,y.side===zt&&(g.bumpScale.value*=-1)),y.normalMap&&(g.normalMap.value=y.normalMap,g.normalScale.value.copy(y.normalScale),y.side===zt&&g.normalScale.value.negate()),y.displacementMap&&(g.displacementMap.value=y.displacementMap,g.displacementScale.value=y.displacementScale,g.displacementBias.value=y.displacementBias)}function f(g,y){y.displacementMap&&(g.displacementMap.value=y.displacementMap,g.displacementScale.value=y.displacementScale,g.displacementBias.value=y.displacementBias)}function m(g,y){y.displacementMap&&(g.displacementMap.value=y.displacementMap,g.displacementScale.value=y.displacementScale,g.displacementBias.value=y.displacementBias),g.referencePosition.value.copy(y.referencePosition),g.nearDistance.value=y.nearDistance,g.farDistance.value=y.farDistance}function _(g,y){y.bumpMap&&(g.bumpMap.value=y.bumpMap,g.bumpScale.value=y.bumpScale,y.side===zt&&(g.bumpScale.value*=-1)),y.normalMap&&(g.normalMap.value=y.normalMap,g.normalScale.value.copy(y.normalScale),y.side===zt&&g.normalScale.value.negate()),y.displacementMap&&(g.displacementMap.value=y.displacementMap,g.displacementScale.value=y.displacementScale,g.displacementBias.value=y.displacementBias)}return{refreshFogUniforms:e,refreshMaterialUniforms:t}}function kC(){const r=Uo("canvas");return r.style.display="block",r}function dt(r={}){const e=r.canvas!==void 0?r.canvas:kC(),t=r.context!==void 0?r.context:null,n=r.alpha!==void 0?r.alpha:!1,s=r.depth!==void 0?r.depth:!0,i=r.stencil!==void 0?r.stencil:!0,a=r.antialias!==void 0?r.antialias:!1,o=r.premultipliedAlpha!==void 0?r.premultipliedAlpha:!0,c=r.preserveDrawingBuffer!==void 0?r.preserveDrawingBuffer:!1,l=r.powerPreference!==void 0?r.powerPreference:"default",u=r.failIfMajorPerformanceCaveat!==void 0?r.failIfMajorPerformanceCaveat:!1;let h=null,d=null;const p=[],f=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=yn,this.physicallyCorrectLights=!1,this.toneMapping=_s,this.toneMappingExposure=1;const m=this;let _=!1,g=0,y=0,x=null,w=-1,T=null;const M=new pt,S=new pt;let R=null,k=e.width,O=e.height,A=1,Y=null,B=null;const H=new pt(0,0,k,O),U=new pt(0,0,k,O);let j=!1;const K=[],se=new ic;let ue=!1,Q=!1,ee=null;const ge=new Be,he=new L,Me={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function je(){return x===null?A:1}let ae=t;function Ve(N,F){for(let Z=0;Z<N.length;Z++){const J=N[Z],re=e.getContext(J,F);if(re!==null)return re}return null}try{const N={alpha:n,depth:s,stencil:i,antialias:a,premultipliedAlpha:o,preserveDrawingBuffer:c,powerPreference:l,failIfMajorPerformanceCaveat:u};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${Ul}`),e.addEventListener("webglcontextlost",Ce,!1),e.addEventListener("webglcontextrestored",qe,!1),ae===null){const F=["webgl2","webgl","experimental-webgl"];if(m.isWebGL1Renderer===!0&&F.shift(),ae=Ve(F,N),ae===null)throw Ve(F)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}ae.getShaderPrecisionFormat===void 0&&(ae.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(N){throw console.error("THREE.WebGLRenderer: "+N.message),N}let He,Re,ze,Ye,te,ie,me,Ie,be,Ge,$e,We,ot,D,I,oe,ce,ke,Pe,$,de,le,Se;function ve(){He=new nR(ae),Re=new KN(ae,He,r),He.init(Re),le=new NC(ae,He,Re),ze=new AC(ae,He,Re),K[0]=1029,Ye=new iR(ae),te=new gC,ie=new IC(ae,He,ze,te,Re,le,Ye),me=new YN(m),Ie=new tR(m),be=new _A(ae,Re),Se=new jN(ae,He,be,Re),Ge=new rR(ae,be,Ye,Se),$e=new uR(ae,Ge,be,Ye),Pe=new cR(ae,Re,ie),oe=new XN(te),We=new mC(m,me,Ie,He,Re,Se,oe),ot=new LC(te),D=new _C(te),I=new TC(He,Re),ke=new WN(m,me,ze,$e,o),ce=new kg(m,$e,Re),$=new qN(ae,He,Ye,Re),de=new sR(ae,He,Ye,Re),Ye.programs=We.programs,m.capabilities=Re,m.extensions=He,m.properties=te,m.renderLists=D,m.shadowMap=ce,m.state=ze,m.info=Ye}ve();const Ee=new CC(m,ae);this.xr=Ee,this.getContext=function(){return ae},this.getContextAttributes=function(){return ae.getContextAttributes()},this.forceContextLoss=function(){const N=He.get("WEBGL_lose_context");N&&N.loseContext()},this.forceContextRestore=function(){const N=He.get("WEBGL_lose_context");N&&N.restoreContext()},this.getPixelRatio=function(){return A},this.setPixelRatio=function(N){N!==void 0&&(A=N,this.setSize(k,O,!1))},this.getSize=function(N){return N.set(k,O)},this.setSize=function(N,F,Z){if(Ee.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}k=N,O=F,e.width=Math.floor(N*A),e.height=Math.floor(F*A),Z!==!1&&(e.style.width=N+"px",e.style.height=F+"px"),this.setViewport(0,0,N,F)},this.getDrawingBufferSize=function(N){return N.set(k*A,O*A).floor()},this.setDrawingBufferSize=function(N,F,Z){k=N,O=F,A=Z,e.width=Math.floor(N*Z),e.height=Math.floor(F*Z),this.setViewport(0,0,N,F)},this.getCurrentViewport=function(N){return N.copy(M)},this.getViewport=function(N){return N.copy(H)},this.setViewport=function(N,F,Z,J){N.isVector4?H.set(N.x,N.y,N.z,N.w):H.set(N,F,Z,J),ze.viewport(M.copy(H).multiplyScalar(A).floor())},this.getScissor=function(N){return N.copy(U)},this.setScissor=function(N,F,Z,J){N.isVector4?U.set(N.x,N.y,N.z,N.w):U.set(N,F,Z,J),ze.scissor(S.copy(U).multiplyScalar(A).floor())},this.getScissorTest=function(){return j},this.setScissorTest=function(N){ze.setScissorTest(j=N)},this.setOpaqueSort=function(N){Y=N},this.setTransparentSort=function(N){B=N},this.getClearColor=function(N){return N.copy(ke.getClearColor())},this.setClearColor=function(){ke.setClearColor.apply(ke,arguments)},this.getClearAlpha=function(){return ke.getClearAlpha()},this.setClearAlpha=function(){ke.setClearAlpha.apply(ke,arguments)},this.clear=function(N,F,Z){let J=0;(N===void 0||N)&&(J|=16384),(F===void 0||F)&&(J|=256),(Z===void 0||Z)&&(J|=1024),ae.clear(J)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Ce,!1),e.removeEventListener("webglcontextrestored",qe,!1),D.dispose(),I.dispose(),te.dispose(),me.dispose(),Ie.dispose(),$e.dispose(),Se.dispose(),Ee.dispose(),Ee.removeEventListener("sessionstart",Ps),Ee.removeEventListener("sessionend",Qr),ee&&(ee.dispose(),ee=null),St.stop()};function Ce(N){N.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),_=!0}function qe(){console.log("THREE.WebGLRenderer: Context Restored."),_=!1;const N=Ye.autoReset,F=ce.enabled,Z=ce.autoUpdate,J=ce.needsUpdate,re=ce.type;ve(),Ye.autoReset=N,ce.enabled=F,ce.autoUpdate=Z,ce.needsUpdate=J,ce.type=re}function _t(N){const F=N.target;F.removeEventListener("dispose",_t),Je(F)}function Je(N){en(N),te.remove(N)}function en(N){const F=te.get(N).programs;F!==void 0&&F.forEach(function(Z){We.releaseProgram(Z)})}this.renderBufferDirect=function(N,F,Z,J,re,V){F===null&&(F=Me);const q=re.isMesh&&re.matrixWorld.determinant()<0,ne=yr(N,F,Z,J,re);ze.setMaterial(J,q);let we=Z.index;const Ue=Z.attributes.position;if(we===null){if(Ue===void 0||Ue.count===0)return}else if(we.count===0)return;let Fe=1;J.wireframe===!0&&(we=Ge.getWireframeAttribute(Z),Fe=2),Se.setup(re,J,ne,Z,we);let Ae,Oe=$;we!==null&&(Ae=be.get(we),Oe=de,Oe.setIndex(Ae));const ft=we!==null?we.count:Ue.count,Xe=Z.drawRange.start*Fe,cn=Z.drawRange.count*Fe,ct=V!==null?V.start*Fe:0,Wt=V!==null?V.count*Fe:1/0,xt=Math.max(Xe,ct),jt=Math.min(ft,Xe+cn,ct+Wt)-1,xn=Math.max(0,jt-xt+1);if(xn!==0){if(re.isMesh)J.wireframe===!0?(ze.setLineWidth(J.wireframeLinewidth*je()),Oe.setMode(1)):Oe.setMode(4);else if(re.isLine){let bt=J.linewidth;bt===void 0&&(bt=1),ze.setLineWidth(bt*je()),re.isLineSegments?Oe.setMode(1):re.isLineLoop?Oe.setMode(2):Oe.setMode(3)}else re.isPoints?Oe.setMode(0):re.isSprite&&Oe.setMode(4);if(re.isInstancedMesh)Oe.renderInstances(xt,xn,re.count);else if(Z.isInstancedBufferGeometry){const bt=Math.min(Z.instanceCount,Z._maxInstanceCount);Oe.renderInstances(xt,xn,bt)}else Oe.render(xt,xn)}},this.compile=function(N,F){d=I.get(N),d.init(),f.push(d),N.traverseVisible(function(Z){Z.isLight&&Z.layers.test(F.layers)&&(d.pushLight(Z),Z.castShadow&&d.pushShadow(Z))}),d.setupLights(m.physicallyCorrectLights),N.traverse(function(Z){const J=Z.material;if(J)if(Array.isArray(J))for(let re=0;re<J.length;re++){const V=J[re];Dn(V,N,Z)}else Dn(J,N,Z)}),f.pop(),d=null};let Gt=null;function Ds(N){Gt&&Gt(N)}function Ps(){St.stop()}function Qr(){St.start()}const St=new J1;St.setAnimationLoop(Ds),typeof window!="undefined"&&St.setContext(window),this.setAnimationLoop=function(N){Gt=N,Ee.setAnimationLoop(N),N===null?St.stop():St.start()},Ee.addEventListener("sessionstart",Ps),Ee.addEventListener("sessionend",Qr),this.render=function(N,F){if(F!==void 0&&F.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(_===!0)return;N.autoUpdate===!0&&N.updateMatrixWorld(),F.parent===null&&F.updateMatrixWorld(),Ee.enabled===!0&&Ee.isPresenting===!0&&(Ee.cameraAutoUpdate===!0&&Ee.updateCamera(F),F=Ee.getCamera()),N.isScene===!0&&N.onBeforeRender(m,N,F,x),d=I.get(N,f.length),d.init(),f.push(d),ge.multiplyMatrices(F.projectionMatrix,F.matrixWorldInverse),se.setFromProjectionMatrix(ge),Q=this.localClippingEnabled,ue=oe.init(this.clippingPlanes,Q,F),h=D.get(N,p.length),h.init(),p.push(h),es(N,F,0,m.sortObjects),h.finish(),m.sortObjects===!0&&h.sort(Y,B),ue===!0&&oe.beginShadows();const Z=d.state.shadowsArray;if(ce.render(Z,N,F),ue===!0&&oe.endShadows(),this.info.autoReset===!0&&this.info.reset(),ke.render(h,N),d.setupLights(m.physicallyCorrectLights),F.isArrayCamera){const J=F.cameras;for(let re=0,V=J.length;re<V;re++){const q=J[re];Fs(h,N,q,q.viewport)}}else Fs(h,N,F);x!==null&&(ie.updateMultisampleRenderTarget(x),ie.updateRenderTargetMipmap(x)),N.isScene===!0&&N.onAfterRender(m,N,F),ze.buffers.depth.setTest(!0),ze.buffers.depth.setMask(!0),ze.buffers.color.setMask(!0),ze.setPolygonOffset(!1),Se.resetDefaultState(),w=-1,T=null,f.pop(),f.length>0?d=f[f.length-1]:d=null,p.pop(),p.length>0?h=p[p.length-1]:h=null};function es(N,F,Z,J){if(N.visible===!1)return;if(N.layers.test(F.layers)){if(N.isGroup)Z=N.renderOrder;else if(N.isLOD)N.autoUpdate===!0&&N.update(F);else if(N.isLight)d.pushLight(N),N.castShadow&&d.pushShadow(N);else if(N.isSprite){if(!N.frustumCulled||se.intersectsSprite(N)){J&&he.setFromMatrixPosition(N.matrixWorld).applyMatrix4(ge);const q=$e.update(N),ne=N.material;ne.visible&&h.push(N,q,ne,Z,he.z,null)}}else if((N.isMesh||N.isLine||N.isPoints)&&(N.isSkinnedMesh&&N.skeleton.frame!==Ye.render.frame&&(N.skeleton.update(),N.skeleton.frame=Ye.render.frame),!N.frustumCulled||se.intersectsObject(N))){J&&he.setFromMatrixPosition(N.matrixWorld).applyMatrix4(ge);const q=$e.update(N),ne=N.material;if(Array.isArray(ne)){const we=q.groups;for(let Ue=0,Fe=we.length;Ue<Fe;Ue++){const Ae=we[Ue],Oe=ne[Ae.materialIndex];Oe&&Oe.visible&&h.push(N,q,Oe,Z,he.z,Ae)}}else ne.visible&&h.push(N,q,ne,Z,he.z,null)}}const V=N.children;for(let q=0,ne=V.length;q<ne;q++)es(V[q],F,Z,J)}function Fs(N,F,Z,J){const re=N.opaque,V=N.transmissive,q=N.transparent;d.setupLightsView(Z),V.length>0&&Ji(re,F,Z),J&&ze.viewport(M.copy(J)),re.length>0&&Zn(re,F,Z),V.length>0&&Zn(V,F,Z),q.length>0&&Zn(q,F,Z)}function Ji(N,F,Z){if(ee===null){const q=a===!0&&Re.isWebGL2===!0?th:Rn;ee=new q(1024,1024,{generateMipmaps:!0,type:le.convert(hi)!==null?hi:Pr,minFilter:li,magFilter:Ut,wrapS:mn,wrapT:mn,useRenderToTexture:He.has("WEBGL_multisampled_render_to_texture")})}const J=m.getRenderTarget();m.setRenderTarget(ee),m.clear();const re=m.toneMapping;m.toneMapping=_s,Zn(N,F,Z),m.toneMapping=re,ie.updateMultisampleRenderTarget(ee),ie.updateRenderTargetMipmap(ee),m.setRenderTarget(J)}function Zn(N,F,Z){const J=F.isScene===!0?F.overrideMaterial:null;for(let re=0,V=N.length;re<V;re++){const q=N[re],ne=q.object,we=q.geometry,Ue=J===null?q.material:J,Fe=q.group;ne.layers.test(Z.layers)&&Os(ne,F,Z,we,Ue,Fe)}}function Os(N,F,Z,J,re,V){N.onBeforeRender(m,F,Z,J,re,V),N.modelViewMatrix.multiplyMatrices(Z.matrixWorldInverse,N.matrixWorld),N.normalMatrix.getNormalMatrix(N.modelViewMatrix),re.onBeforeRender(m,F,Z,J,N,V),re.transparent===!0&&re.side===ys?(re.side=zt,re.needsUpdate=!0,m.renderBufferDirect(Z,F,J,re,N,V),re.side=oi,re.needsUpdate=!0,m.renderBufferDirect(Z,F,J,re,N,V),re.side=ys):m.renderBufferDirect(Z,F,J,re,N,V),N.onAfterRender(m,F,Z,J,re,V)}function Dn(N,F,Z){F.isScene!==!0&&(F=Me);const J=te.get(N),re=d.state.lights,V=d.state.shadowsArray,q=re.state.version,ne=We.getParameters(N,re.state,V,F,Z),we=We.getProgramCacheKey(ne);let Ue=J.programs;J.environment=N.isMeshStandardMaterial?F.environment:null,J.fog=F.fog,J.envMap=(N.isMeshStandardMaterial?Ie:me).get(N.envMap||J.environment),Ue===void 0&&(N.addEventListener("dispose",_t),Ue=new Map,J.programs=Ue);let Fe=Ue.get(we);if(Fe!==void 0){if(J.currentProgram===Fe&&J.lightsStateVersion===q)return Sn(N,ne),Fe}else ne.uniforms=We.getUniforms(N),N.onBuild(Z,ne,m),N.onBeforeCompile(ne,m),Fe=We.acquireProgram(ne,we),Ue.set(we,Fe),J.uniforms=ne.uniforms;const Ae=J.uniforms;(!N.isShaderMaterial&&!N.isRawShaderMaterial||N.clipping===!0)&&(Ae.clippingPlanes=oe.uniform),Sn(N,ne),J.needsLights=_r(N),J.lightsStateVersion=q,J.needsLights&&(Ae.ambientLightColor.value=re.state.ambient,Ae.lightProbe.value=re.state.probe,Ae.directionalLights.value=re.state.directional,Ae.directionalLightShadows.value=re.state.directionalShadow,Ae.spotLights.value=re.state.spot,Ae.spotLightShadows.value=re.state.spotShadow,Ae.rectAreaLights.value=re.state.rectArea,Ae.ltc_1.value=re.state.rectAreaLTC1,Ae.ltc_2.value=re.state.rectAreaLTC2,Ae.pointLights.value=re.state.point,Ae.pointLightShadows.value=re.state.pointShadow,Ae.hemisphereLights.value=re.state.hemi,Ae.directionalShadowMap.value=re.state.directionalShadowMap,Ae.directionalShadowMatrix.value=re.state.directionalShadowMatrix,Ae.spotShadowMap.value=re.state.spotShadowMap,Ae.spotShadowMatrix.value=re.state.spotShadowMatrix,Ae.pointShadowMap.value=re.state.pointShadowMap,Ae.pointShadowMatrix.value=re.state.pointShadowMatrix);const Oe=Fe.getUniforms(),ft=jr.seqWithValue(Oe.seq,Ae);return J.currentProgram=Fe,J.uniformsList=ft,Fe}function Sn(N,F){const Z=te.get(N);Z.outputEncoding=F.outputEncoding,Z.instancing=F.instancing,Z.skinning=F.skinning,Z.morphTargets=F.morphTargets,Z.morphNormals=F.morphNormals,Z.morphTargetsCount=F.morphTargetsCount,Z.numClippingPlanes=F.numClippingPlanes,Z.numIntersection=F.numClipIntersection,Z.vertexAlphas=F.vertexAlphas,Z.vertexTangents=F.vertexTangents}function yr(N,F,Z,J,re){F.isScene!==!0&&(F=Me),ie.resetTextureUnits();const V=F.fog,q=J.isMeshStandardMaterial?F.environment:null,ne=x===null?m.outputEncoding:x.texture.encoding,we=(J.isMeshStandardMaterial?Ie:me).get(J.envMap||q),Ue=J.vertexColors===!0&&!!Z.attributes.color&&Z.attributes.color.itemSize===4,Fe=!!J.normalMap&&!!Z.attributes.tangent,Ae=!!Z.morphAttributes.position,Oe=!!Z.morphAttributes.normal,ft=Z.morphAttributes.position?Z.morphAttributes.position.length:0,Xe=te.get(J),cn=d.state.lights;if(ue===!0&&(Q===!0||N!==T)){const bn=N===T&&J.id===w;oe.setState(J,N,bn)}let ct=!1;J.version===Xe.__version?(Xe.needsLights&&Xe.lightsStateVersion!==cn.state.version||Xe.outputEncoding!==ne||re.isInstancedMesh&&Xe.instancing===!1||!re.isInstancedMesh&&Xe.instancing===!0||re.isSkinnedMesh&&Xe.skinning===!1||!re.isSkinnedMesh&&Xe.skinning===!0||Xe.envMap!==we||J.fog&&Xe.fog!==V||Xe.numClippingPlanes!==void 0&&(Xe.numClippingPlanes!==oe.numPlanes||Xe.numIntersection!==oe.numIntersection)||Xe.vertexAlphas!==Ue||Xe.vertexTangents!==Fe||Xe.morphTargets!==Ae||Xe.morphNormals!==Oe||Re.isWebGL2===!0&&Xe.morphTargetsCount!==ft)&&(ct=!0):(ct=!0,Xe.__version=J.version);let Wt=Xe.currentProgram;ct===!0&&(Wt=Dn(J,F,re));let xt=!1,jt=!1,xn=!1;const bt=Wt.getUniforms(),ns=Xe.uniforms;if(ze.useProgram(Wt.program)&&(xt=!0,jt=!0,xn=!0),J.id!==w&&(w=J.id,jt=!0),xt||T!==N){if(bt.setValue(ae,"projectionMatrix",N.projectionMatrix),Re.logarithmicDepthBuffer&&bt.setValue(ae,"logDepthBufFC",2/(Math.log(N.far+1)/Math.LN2)),T!==N&&(T=N,jt=!0,xn=!0),J.isShaderMaterial||J.isMeshPhongMaterial||J.isMeshToonMaterial||J.isMeshStandardMaterial||J.envMap){const bn=bt.map.cameraPosition;bn!==void 0&&bn.setValue(ae,he.setFromMatrixPosition(N.matrixWorld))}(J.isMeshPhongMaterial||J.isMeshToonMaterial||J.isMeshLambertMaterial||J.isMeshBasicMaterial||J.isMeshStandardMaterial||J.isShaderMaterial)&&bt.setValue(ae,"isOrthographic",N.isOrthographicCamera===!0),(J.isMeshPhongMaterial||J.isMeshToonMaterial||J.isMeshLambertMaterial||J.isMeshBasicMaterial||J.isMeshStandardMaterial||J.isShaderMaterial||J.isShadowMaterial||re.isSkinnedMesh)&&bt.setValue(ae,"viewMatrix",N.matrixWorldInverse)}if(re.isSkinnedMesh){bt.setOptional(ae,re,"bindMatrix"),bt.setOptional(ae,re,"bindMatrixInverse");const bn=re.skeleton;bn&&(Re.floatVertexTextures?(bn.boneTexture===null&&bn.computeBoneTexture(),bt.setValue(ae,"boneTexture",bn.boneTexture,ie),bt.setValue(ae,"boneTextureSize",bn.boneTextureSize)):bt.setOptional(ae,bn,"boneMatrices"))}return!!Z&&(Z.morphAttributes.position!==void 0||Z.morphAttributes.normal!==void 0)&&Pe.update(re,Z,J,Wt),(jt||Xe.receiveShadow!==re.receiveShadow)&&(Xe.receiveShadow=re.receiveShadow,bt.setValue(ae,"receiveShadow",re.receiveShadow)),jt&&(bt.setValue(ae,"toneMappingExposure",m.toneMappingExposure),Xe.needsLights&&ts(ns,xn),V&&J.fog&&ot.refreshFogUniforms(ns,V),ot.refreshMaterialUniforms(ns,J,A,O,ee),jr.upload(ae,Xe.uniformsList,ns,ie)),J.isShaderMaterial&&J.uniformsNeedUpdate===!0&&(jr.upload(ae,Xe.uniformsList,ns,ie),J.uniformsNeedUpdate=!1),J.isSpriteMaterial&&bt.setValue(ae,"center",re.center),bt.setValue(ae,"modelViewMatrix",re.modelViewMatrix),bt.setValue(ae,"normalMatrix",re.normalMatrix),bt.setValue(ae,"modelMatrix",re.matrixWorld),Wt}function ts(N,F){N.ambientLightColor.needsUpdate=F,N.lightProbe.needsUpdate=F,N.directionalLights.needsUpdate=F,N.directionalLightShadows.needsUpdate=F,N.pointLights.needsUpdate=F,N.pointLightShadows.needsUpdate=F,N.spotLights.needsUpdate=F,N.spotLightShadows.needsUpdate=F,N.rectAreaLights.needsUpdate=F,N.hemisphereLights.needsUpdate=F}function _r(N){return N.isMeshLambertMaterial||N.isMeshToonMaterial||N.isMeshPhongMaterial||N.isMeshStandardMaterial||N.isShadowMaterial||N.isShaderMaterial&&N.lights===!0}this.getActiveCubeFace=function(){return g},this.getActiveMipmapLevel=function(){return y},this.getRenderTarget=function(){return x},this.setRenderTargetTextures=function(N,F,Z){te.get(N.texture).__webglTexture=F,te.get(N.depthTexture).__webglTexture=Z;const J=te.get(N);J.__hasExternalTextures=!0,J.__hasExternalTextures&&(J.__autoAllocateDepthBuffer=Z===void 0,J.__autoAllocateDepthBuffer||N.useRenderToTexture&&(console.warn("render-to-texture extension was disabled because an external texture was provided"),N.useRenderToTexture=!1,N.useRenderbuffer=!0))},this.setRenderTargetFramebuffer=function(N,F){const Z=te.get(N);Z.__webglFramebuffer=F,Z.__useDefaultFramebuffer=F===void 0},this.setRenderTarget=function(N,F=0,Z=0){x=N,g=F,y=Z;let J=!0;if(N){const we=te.get(N);we.__useDefaultFramebuffer!==void 0?(ze.bindFramebuffer(36160,null),J=!1):we.__webglFramebuffer===void 0?ie.setupRenderTarget(N):we.__hasExternalTextures&&ie.rebindTextures(N,te.get(N.texture).__webglTexture,te.get(N.depthTexture).__webglTexture)}let re=null,V=!1,q=!1;if(N){const we=N.texture;(we.isDataTexture3D||we.isDataTexture2DArray)&&(q=!0);const Ue=te.get(N).__webglFramebuffer;N.isWebGLCubeRenderTarget?(re=Ue[F],V=!0):N.useRenderbuffer?re=te.get(N).__webglMultisampledFramebuffer:re=Ue,M.copy(N.viewport),S.copy(N.scissor),R=N.scissorTest}else M.copy(H).multiplyScalar(A).floor(),S.copy(U).multiplyScalar(A).floor(),R=j;if(ze.bindFramebuffer(36160,re)&&Re.drawBuffers&&J){let we=!1;if(N)if(N.isWebGLMultipleRenderTargets){const Ue=N.texture;if(K.length!==Ue.length||K[0]!==36064){for(let Fe=0,Ae=Ue.length;Fe<Ae;Fe++)K[Fe]=36064+Fe;K.length=Ue.length,we=!0}}else(K.length!==1||K[0]!==36064)&&(K[0]=36064,K.length=1,we=!0);else(K.length!==1||K[0]!==1029)&&(K[0]=1029,K.length=1,we=!0);we&&(Re.isWebGL2?ae.drawBuffers(K):He.get("WEBGL_draw_buffers").drawBuffersWEBGL(K))}if(ze.viewport(M),ze.scissor(S),ze.setScissorTest(R),V){const we=te.get(N.texture);ae.framebufferTexture2D(36160,36064,34069+F,we.__webglTexture,Z)}else if(q){const we=te.get(N.texture),Ue=F||0;ae.framebufferTextureLayer(36160,36064,we.__webglTexture,Z||0,Ue)}w=-1},this.readRenderTargetPixels=function(N,F,Z,J,re,V,q){if(!(N&&N.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let ne=te.get(N).__webglFramebuffer;if(N.isWebGLCubeRenderTarget&&q!==void 0&&(ne=ne[q]),ne){ze.bindFramebuffer(36160,ne);try{const we=N.texture,Ue=we.format,Fe=we.type;if(Ue!==sn&&le.convert(Ue)!==ae.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Ae=Fe===hi&&(He.has("EXT_color_buffer_half_float")||Re.isWebGL2&&He.has("EXT_color_buffer_float"));if(Fe!==Pr&&le.convert(Fe)!==ae.getParameter(35738)&&!(Fe===ar&&(Re.isWebGL2||He.has("OES_texture_float")||He.has("WEBGL_color_buffer_float")))&&!Ae){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}ae.checkFramebufferStatus(36160)===36053?F>=0&&F<=N.width-J&&Z>=0&&Z<=N.height-re&&ae.readPixels(F,Z,J,re,le.convert(Ue),le.convert(Fe),V):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const we=x!==null?te.get(x).__webglFramebuffer:null;ze.bindFramebuffer(36160,we)}}},this.copyFramebufferToTexture=function(N,F,Z=0){const J=Math.pow(2,-Z),re=Math.floor(F.image.width*J),V=Math.floor(F.image.height*J);let q=le.convert(F.format);Re.isWebGL2&&(q===6407&&(q=32849),q===6408&&(q=32856)),ie.setTexture2D(F,0),ae.copyTexImage2D(3553,Z,q,N.x,N.y,re,V,0),ze.unbindTexture()},this.copyTextureToTexture=function(N,F,Z,J=0){const re=F.image.width,V=F.image.height,q=le.convert(Z.format),ne=le.convert(Z.type);ie.setTexture2D(Z,0),ae.pixelStorei(37440,Z.flipY),ae.pixelStorei(37441,Z.premultiplyAlpha),ae.pixelStorei(3317,Z.unpackAlignment),F.isDataTexture?ae.texSubImage2D(3553,J,N.x,N.y,re,V,q,ne,F.image.data):F.isCompressedTexture?ae.compressedTexSubImage2D(3553,J,N.x,N.y,F.mipmaps[0].width,F.mipmaps[0].height,q,F.mipmaps[0].data):ae.texSubImage2D(3553,J,N.x,N.y,q,ne,F.image),J===0&&Z.generateMipmaps&&ae.generateMipmap(3553),ze.unbindTexture()},this.copyTextureToTexture3D=function(N,F,Z,J,re=0){if(m.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const V=N.max.x-N.min.x+1,q=N.max.y-N.min.y+1,ne=N.max.z-N.min.z+1,we=le.convert(J.format),Ue=le.convert(J.type);let Fe;if(J.isDataTexture3D)ie.setTexture3D(J,0),Fe=32879;else if(J.isDataTexture2DArray)ie.setTexture2DArray(J,0),Fe=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}ae.pixelStorei(37440,J.flipY),ae.pixelStorei(37441,J.premultiplyAlpha),ae.pixelStorei(3317,J.unpackAlignment);const Ae=ae.getParameter(3314),Oe=ae.getParameter(32878),ft=ae.getParameter(3316),Xe=ae.getParameter(3315),cn=ae.getParameter(32877),ct=Z.isCompressedTexture?Z.mipmaps[0]:Z.image;ae.pixelStorei(3314,ct.width),ae.pixelStorei(32878,ct.height),ae.pixelStorei(3316,N.min.x),ae.pixelStorei(3315,N.min.y),ae.pixelStorei(32877,N.min.z),Z.isDataTexture||Z.isDataTexture3D?ae.texSubImage3D(Fe,re,F.x,F.y,F.z,V,q,ne,we,Ue,ct.data):Z.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),ae.compressedTexSubImage3D(Fe,re,F.x,F.y,F.z,V,q,ne,we,ct.data)):ae.texSubImage3D(Fe,re,F.x,F.y,F.z,V,q,ne,we,Ue,ct),ae.pixelStorei(3314,Ae),ae.pixelStorei(32878,Oe),ae.pixelStorei(3316,ft),ae.pixelStorei(3315,Xe),ae.pixelStorei(32877,cn),re===0&&J.generateMipmaps&&ae.generateMipmap(Fe),ze.unbindTexture()},this.initTexture=function(N){ie.setTexture2D(N,0),ze.unbindTexture()},this.resetState=function(){g=0,y=0,x=null,ze.reset(),Se.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}dt.prototype.isWebGLRenderer=!0;class DC extends dt{}DC.prototype.isWebGL1Renderer=!0;class lc extends it{constructor(){super();this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}lc.prototype.isScene=!0;class zi{constructor(e,t){this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=Ma,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Nn()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let s=0,i=this.stride;s<i;s++)this.array[e+s]=t.array[n+s];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Nn()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Nn()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}zi.prototype.isInterleavedBuffer=!0;const Rt=new L;class Ui{constructor(e,t,n,s=!1){this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=s===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)Rt.x=this.getX(t),Rt.y=this.getY(t),Rt.z=this.getZ(t),Rt.applyMatrix4(e),this.setXYZ(t,Rt.x,Rt.y,Rt.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)Rt.x=this.getX(t),Rt.y=this.getY(t),Rt.z=this.getZ(t),Rt.applyNormalMatrix(e),this.setXYZ(t,Rt.x,Rt.y,Rt.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)Rt.x=this.getX(t),Rt.y=this.getY(t),Rt.z=this.getZ(t),Rt.transformDirection(e),this.setXYZ(t,Rt.x,Rt.y,Rt.z);return this}setX(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){return this.data.array[e*this.data.stride+this.offset]}getY(e){return this.data.array[e*this.data.stride+this.offset+1]}getZ(e){return this.data.array[e*this.data.stride+this.offset+2]}getW(e){return this.data.array[e*this.data.stride+this.offset+3]}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,s){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=s,this}setXYZW(e,t,n,s,i){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=s,this.data.array[e+3]=i,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const s=n*this.data.stride+this.offset;for(let i=0;i<this.itemSize;i++)t.push(this.data.array[s+i])}return new It(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Ui(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const s=n*this.data.stride+this.offset;for(let i=0;i<this.itemSize;i++)t.push(this.data.array[s+i])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}Ui.prototype.isInterleavedBufferAttribute=!0;class Pg extends Ht{constructor(e){super();this.type="SpriteMaterial",this.color=new Le(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this}}Pg.prototype.isSpriteMaterial=!0;let Vi;const Ba=new L,Hi=new L,$i=new L,Gi=new fe,za=new fe,Fg=new Be,hc=new L,Ua=new L,dc=new L,Og=new fe,Ph=new fe,Bg=new fe;class PC extends it{constructor(e){super();if(this.type="Sprite",Vi===void 0){Vi=new yt;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new zi(t,5);Vi.setIndex([0,1,2,0,2,3]),Vi.setAttribute("position",new Ui(n,3,0,!1)),Vi.setAttribute("uv",new Ui(n,2,3,!1))}this.geometry=Vi,this.material=e!==void 0?e:new Pg,this.center=new fe(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Hi.setFromMatrixScale(this.matrixWorld),Fg.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),$i.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Hi.multiplyScalar(-$i.z);const n=this.material.rotation;let s,i;n!==0&&(i=Math.cos(n),s=Math.sin(n));const a=this.center;pc(hc.set(-.5,-.5,0),$i,a,Hi,s,i),pc(Ua.set(.5,-.5,0),$i,a,Hi,s,i),pc(dc.set(.5,.5,0),$i,a,Hi,s,i),Og.set(0,0),Ph.set(1,0),Bg.set(1,1);let o=e.ray.intersectTriangle(hc,Ua,dc,!1,Ba);if(o===null&&(pc(Ua.set(-.5,.5,0),$i,a,Hi,s,i),Ph.set(0,1),o=e.ray.intersectTriangle(hc,dc,Ua,!1,Ba),o===null))return;const c=e.ray.origin.distanceTo(Ba);c<e.near||c>e.far||t.push({distance:c,point:Ba.clone(),uv:Dt.getUV(Ba,hc,Ua,dc,Og,Ph,Bg,new fe),face:null,object:this})}copy(e){return super.copy(e),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}PC.prototype.isSprite=!0;function pc(r,e,t,n,s,i){Gi.subVectors(r,t).addScalar(.5).multiply(n),s!==void 0?(za.x=i*Gi.x-s*Gi.y,za.y=s*Gi.x+i*Gi.y):za.copy(Gi),r.copy(e),r.x+=za.x,r.y+=za.y,r.applyMatrix4(Fg)}const zg=new L,Ug=new pt,Vg=new pt,FC=new L,Hg=new Be;class Fh extends $t{constructor(e,t){super(e,t);this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Be,this.bindMatrixInverse=new Be}copy(e){return super.copy(e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new pt,t=this.geometry.attributes.skinWeight;for(let n=0,s=t.count;n<s;n++){e.x=t.getX(n),e.y=t.getY(n),e.z=t.getZ(n),e.w=t.getW(n);const i=1/e.manhattanLength();i!==1/0?e.multiplyScalar(i):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const n=this.skeleton,s=this.geometry;Ug.fromBufferAttribute(s.attributes.skinIndex,e),Vg.fromBufferAttribute(s.attributes.skinWeight,e),zg.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let i=0;i<4;i++){const a=Vg.getComponent(i);if(a!==0){const o=Ug.getComponent(i);Hg.multiplyMatrices(n.bones[o].matrixWorld,n.boneInverses[o]),t.addScaledVector(FC.copy(zg).applyMatrix4(Hg),a)}}return t.applyMatrix4(this.bindMatrixInverse)}}Fh.prototype.isSkinnedMesh=!0;class Oh extends it{constructor(){super();this.type="Bone"}}Oh.prototype.isBone=!0;class $g extends Vt{constructor(e=null,t=1,n=1,s,i,a,o,c,l=Ut,u=Ut,h,d){super(null,a,o,c,l,u,s,i,h,d);this.image={data:e,width:t,height:n},this.magFilter=l,this.minFilter=u,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}$g.prototype.isDataTexture=!0;const Gg=new Be,OC=new Be;class Bh{constructor(e=[],t=[]){this.uuid=Nn(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,s=this.bones.length;n<s;n++)this.boneInverses.push(new Be)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const n=new Be;this.bones[e]&&n.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(n)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&n.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}}update(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,s=this.boneTexture;for(let i=0,a=e.length;i<a;i++){const o=e[i]?e[i].matrixWorld:OC;Gg.multiplyMatrices(o,t[i]),Gg.toArray(n,i*16)}s!==null&&(s.needsUpdate=!0)}clone(){return new Bh(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=L1(e),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const n=new $g(t,e,e,sn,ar);return this.boneMatrices=t,this.boneTexture=n,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,n=this.bones.length;t<n;t++){const s=this.bones[t];if(s.name===e)return s}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let n=0,s=e.bones.length;n<s;n++){const i=e.bones[n];let a=t[i];a===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",i),a=new Oh),this.bones.push(a),this.boneInverses.push(new Be().fromArray(e.boneInverses[n]))}return this.init(),this}toJSON(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let s=0,i=t.length;s<i;s++){const a=t[s];e.bones.push(a.uuid);const o=n[s];e.boneInverses.push(o.toArray())}return e}}class zh extends It{constructor(e,t,n,s=1){typeof n=="number"&&(s=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."));super(e,t,n);this.meshPerAttribute=s}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}zh.prototype.isInstancedBufferAttribute=!0;const Wg=new Be,jg=new Be,fc=[],Va=new $t;class BC extends $t{constructor(e,t,n){super(e,t);this.instanceMatrix=new zh(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}copy(e){return super.copy(e),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const n=this.matrixWorld,s=this.count;if(Va.geometry=this.geometry,Va.material=this.material,Va.material!==void 0)for(let i=0;i<s;i++){this.getMatrixAt(i,Wg),jg.multiplyMatrices(n,Wg),Va.matrixWorld=jg,Va.raycast(e,fc);for(let a=0,o=fc.length;a<o;a++){const c=fc[a];c.instanceId=i,c.object=this,t.push(c)}fc.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new zh(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}BC.prototype.isInstancedMesh=!0;class Wi extends Ht{constructor(e){super();this.type="LineBasicMaterial",this.color=new Le(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this}}Wi.prototype.isLineBasicMaterial=!0;const qg=new L,Kg=new L,Xg=new Be,Uh=new wi,mc=new Ts;class gc extends it{constructor(e=new yt,t=new Wi){super();this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[0];for(let s=1,i=t.count;s<i;s++)qg.fromBufferAttribute(t,s-1),Kg.fromBufferAttribute(t,s),n[s]=n[s-1],n[s]+=qg.distanceTo(Kg);e.setAttribute("lineDistance",new Nt(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(e,t){const n=this.geometry,s=this.matrixWorld,i=e.params.Line.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),mc.copy(n.boundingSphere),mc.applyMatrix4(s),mc.radius+=i,e.ray.intersectsSphere(mc)===!1)return;Xg.copy(s).invert(),Uh.copy(e.ray).applyMatrix4(Xg);const o=i/((this.scale.x+this.scale.y+this.scale.z)/3),c=o*o,l=new L,u=new L,h=new L,d=new L,p=this.isLineSegments?2:1;if(n.isBufferGeometry){const f=n.index,_=n.attributes.position;if(f!==null){const g=Math.max(0,a.start),y=Math.min(f.count,a.start+a.count);for(let x=g,w=y-1;x<w;x+=p){const T=f.getX(x),M=f.getX(x+1);if(l.fromBufferAttribute(_,T),u.fromBufferAttribute(_,M),Uh.distanceSqToSegment(l,u,d,h)>c)continue;d.applyMatrix4(this.matrixWorld);const R=e.ray.origin.distanceTo(d);R<e.near||R>e.far||t.push({distance:R,point:h.clone().applyMatrix4(this.matrixWorld),index:x,face:null,faceIndex:null,object:this})}}else{const g=Math.max(0,a.start),y=Math.min(_.count,a.start+a.count);for(let x=g,w=y-1;x<w;x+=p){if(l.fromBufferAttribute(_,x),u.fromBufferAttribute(_,x+1),Uh.distanceSqToSegment(l,u,d,h)>c)continue;d.applyMatrix4(this.matrixWorld);const M=e.ray.origin.distanceTo(d);M<e.near||M>e.far||t.push({distance:M,point:h.clone().applyMatrix4(this.matrixWorld),index:x,face:null,faceIndex:null,object:this})}}}else n.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const s=t[n[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,a=s.length;i<a;i++){const o=s[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=i}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}gc.prototype.isLine=!0;const Yg=new L,Jg=new L;class yc extends gc{constructor(e,t){super(e,t);this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[];for(let s=0,i=t.count;s<i;s+=2)Yg.fromBufferAttribute(t,s),Jg.fromBufferAttribute(t,s+1),n[s]=s===0?0:n[s-1],n[s+1]=n[s]+Yg.distanceTo(Jg);e.setAttribute("lineDistance",new Nt(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}yc.prototype.isLineSegments=!0;class Zg extends gc{constructor(e,t){super(e,t);this.type="LineLoop"}}Zg.prototype.isLineLoop=!0;class Vh extends Ht{constructor(e){super();this.type="PointsMaterial",this.color=new Le(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this}}Vh.prototype.isPointsMaterial=!0;const Qg=new Be,Hh=new wi,_c=new Ts,xc=new L;class e2 extends it{constructor(e=new yt,t=new Vh){super();this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const n=this.geometry,s=this.matrixWorld,i=e.params.Points.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),_c.copy(n.boundingSphere),_c.applyMatrix4(s),_c.radius+=i,e.ray.intersectsSphere(_c)===!1)return;Qg.copy(s).invert(),Hh.copy(e.ray).applyMatrix4(Qg);const o=i/((this.scale.x+this.scale.y+this.scale.z)/3),c=o*o;if(n.isBufferGeometry){const l=n.index,h=n.attributes.position;if(l!==null){const d=Math.max(0,a.start),p=Math.min(l.count,a.start+a.count);for(let f=d,m=p;f<m;f++){const _=l.getX(f);xc.fromBufferAttribute(h,_),t2(xc,_,c,s,e,t,this)}}else{const d=Math.max(0,a.start),p=Math.min(h.count,a.start+a.count);for(let f=d,m=p;f<m;f++)xc.fromBufferAttribute(h,f),t2(xc,f,c,s,e,t,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const s=t[n[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,a=s.length;i<a;i++){const o=s[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=i}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}e2.prototype.isPoints=!0;function t2(r,e,t,n,s,i,a){const o=Hh.distanceSqToPoint(r);if(o<t){const c=new L;Hh.closestPointToPoint(r,c),c.applyMatrix4(n);const l=s.ray.origin.distanceTo(c);if(l<s.near||l>s.far)return;i.push({distance:l,distanceToRay:Math.sqrt(o),point:c,index:e,face:null,object:a})}}class n2 extends Vt{constructor(e,t,n,s,i,a,o,c,l){super(e,t,n,s,i,a,o,c,l);this.format=o!==void 0?o:Fr,this.minFilter=a!==void 0?a:gn,this.magFilter=i!==void 0?i:gn,this.generateMipmaps=!1;const u=this;function h(){u.needsUpdate=!0,e.requestVideoFrameCallback(h)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(h)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}n2.prototype.isVideoTexture=!0;class zC extends Vt{constructor(e,t,n,s,i,a,o,c,l,u,h,d){super(null,a,o,c,l,u,s,i,h,d);this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}zC.prototype.isCompressedTexture=!0;class UC extends Vt{constructor(e,t,n,s,i,a,o,c,l){super(e,t,n,s,i,a,o,c,l);this.needsUpdate=!0}}UC.prototype.isCanvasTexture=!0;new L;new L;new L;new Dt;class kn{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,s=this.getPoint(0),i=0;t.push(0);for(let a=1;a<=e;a++)n=this.getPoint(a/e),i+=n.distanceTo(s),t.push(i),s=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const n=this.getLengths();let s=0;const i=n.length;let a;t?a=t:a=e*n[i-1];let o=0,c=i-1,l;for(;o<=c;)if(s=Math.floor(o+(c-o)/2),l=n[s]-a,l<0)o=s+1;else if(l>0)c=s-1;else{c=s;break}if(s=c,n[s]===a)return s/(i-1);const u=n[s],d=n[s+1]-u,p=(a-u)/d;return(s+p)/(i-1)}getTangent(e,t){const n=1e-4;let s=e-n,i=e+n;s<0&&(s=0),i>1&&(i=1);const a=this.getPoint(s),o=this.getPoint(i),c=t||(a.isVector2?new fe:new L);return c.copy(o).sub(a).normalize(),c}getTangentAt(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t){const n=new L,s=[],i=[],a=[],o=new L,c=new Be;for(let p=0;p<=e;p++){const f=p/e;s[p]=this.getTangentAt(f,new L)}i[0]=new L,a[0]=new L;let l=Number.MAX_VALUE;const u=Math.abs(s[0].x),h=Math.abs(s[0].y),d=Math.abs(s[0].z);u<=l&&(l=u,n.set(1,0,0)),h<=l&&(l=h,n.set(0,1,0)),d<=l&&n.set(0,0,1),o.crossVectors(s[0],n).normalize(),i[0].crossVectors(s[0],o),a[0].crossVectors(s[0],i[0]);for(let p=1;p<=e;p++){if(i[p]=i[p-1].clone(),a[p]=a[p-1].clone(),o.crossVectors(s[p-1],s[p]),o.length()>Number.EPSILON){o.normalize();const f=Math.acos(_n(s[p-1].dot(s[p]),-1,1));i[p].applyMatrix4(c.makeRotationAxis(o,f))}a[p].crossVectors(s[p],i[p])}if(t===!0){let p=Math.acos(_n(i[0].dot(i[e]),-1,1));p/=e,s[0].dot(o.crossVectors(i[0],i[e]))>0&&(p=-p);for(let f=1;f<=e;f++)i[f].applyMatrix4(c.makeRotationAxis(s[f],p*f)),a[f].crossVectors(s[f],i[f])}return{tangents:s,normals:i,binormals:a}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class bc extends kn{constructor(e=0,t=0,n=1,s=1,i=0,a=Math.PI*2,o=!1,c=0){super();this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=s,this.aStartAngle=i,this.aEndAngle=a,this.aClockwise=o,this.aRotation=c}getPoint(e,t){const n=t||new fe,s=Math.PI*2;let i=this.aEndAngle-this.aStartAngle;const a=Math.abs(i)<Number.EPSILON;for(;i<0;)i+=s;for(;i>s;)i-=s;i<Number.EPSILON&&(a?i=0:i=s),this.aClockwise===!0&&!a&&(i===s?i=-s:i=i-s);const o=this.aStartAngle+e*i;let c=this.aX+this.xRadius*Math.cos(o),l=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const u=Math.cos(this.aRotation),h=Math.sin(this.aRotation),d=c-this.aX,p=l-this.aY;c=d*u-p*h+this.aX,l=d*h+p*u+this.aY}return n.set(c,l)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}bc.prototype.isEllipseCurve=!0;class r2 extends bc{constructor(e,t,n,s,i,a){super(e,t,n,n,s,i,a);this.type="ArcCurve"}}r2.prototype.isArcCurve=!0;function $h(){let r=0,e=0,t=0,n=0;function s(i,a,o,c){r=i,e=o,t=-3*i+3*a-2*o-c,n=2*i-2*a+o+c}return{initCatmullRom:function(i,a,o,c,l){s(a,o,l*(o-i),l*(c-a))},initNonuniformCatmullRom:function(i,a,o,c,l,u,h){let d=(a-i)/l-(o-i)/(l+u)+(o-a)/u,p=(o-a)/u-(c-a)/(u+h)+(c-o)/h;d*=u,p*=u,s(a,o,d,p)},calc:function(i){const a=i*i,o=a*i;return r+e*i+t*a+n*o}}}const vc=new L,Gh=new $h,Wh=new $h,jh=new $h;class s2 extends kn{constructor(e=[],t=!1,n="centripetal",s=.5){super();this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=s}getPoint(e,t=new L){const n=t,s=this.points,i=s.length,a=(i-(this.closed?0:1))*e;let o=Math.floor(a),c=a-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/i)+1)*i:c===0&&o===i-1&&(o=i-2,c=1);let l,u;this.closed||o>0?l=s[(o-1)%i]:(vc.subVectors(s[0],s[1]).add(s[0]),l=vc);const h=s[o%i],d=s[(o+1)%i];if(this.closed||o+2<i?u=s[(o+2)%i]:(vc.subVectors(s[i-1],s[i-2]).add(s[i-1]),u=vc),this.curveType==="centripetal"||this.curveType==="chordal"){const p=this.curveType==="chordal"?.5:.25;let f=Math.pow(l.distanceToSquared(h),p),m=Math.pow(h.distanceToSquared(d),p),_=Math.pow(d.distanceToSquared(u),p);m<1e-4&&(m=1),f<1e-4&&(f=m),_<1e-4&&(_=m),Gh.initNonuniformCatmullRom(l.x,h.x,d.x,u.x,f,m,_),Wh.initNonuniformCatmullRom(l.y,h.y,d.y,u.y,f,m,_),jh.initNonuniformCatmullRom(l.z,h.z,d.z,u.z,f,m,_)}else this.curveType==="catmullrom"&&(Gh.initCatmullRom(l.x,h.x,d.x,u.x,this.tension),Wh.initCatmullRom(l.y,h.y,d.y,u.y,this.tension),jh.initCatmullRom(l.z,h.z,d.z,u.z,this.tension));return n.set(Gh.calc(c),Wh.calc(c),jh.calc(c)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const s=e.points[t];this.points.push(s.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const s=this.points[t];e.points.push(s.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const s=e.points[t];this.points.push(new L().fromArray(s))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}s2.prototype.isCatmullRomCurve3=!0;function i2(r,e,t,n,s){const i=(n-e)*.5,a=(s-t)*.5,o=r*r,c=r*o;return(2*t-2*n+i+a)*c+(-3*t+3*n-2*i-a)*o+i*r+t}function VC(r,e){const t=1-r;return t*t*e}function HC(r,e){return 2*(1-r)*r*e}function $C(r,e){return r*r*e}function Ha(r,e,t,n){return VC(r,e)+HC(r,t)+$C(r,n)}function GC(r,e){const t=1-r;return t*t*t*e}function WC(r,e){const t=1-r;return 3*t*t*r*e}function jC(r,e){return 3*(1-r)*r*r*e}function qC(r,e){return r*r*r*e}function $a(r,e,t,n,s){return GC(r,e)+WC(r,t)+jC(r,n)+qC(r,s)}class qh extends kn{constructor(e=new fe,t=new fe,n=new fe,s=new fe){super();this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=s}getPoint(e,t=new fe){const n=t,s=this.v0,i=this.v1,a=this.v2,o=this.v3;return n.set($a(e,s.x,i.x,a.x,o.x),$a(e,s.y,i.y,a.y,o.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}qh.prototype.isCubicBezierCurve=!0;class a2 extends kn{constructor(e=new L,t=new L,n=new L,s=new L){super();this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=s}getPoint(e,t=new L){const n=t,s=this.v0,i=this.v1,a=this.v2,o=this.v3;return n.set($a(e,s.x,i.x,a.x,o.x),$a(e,s.y,i.y,a.y,o.y),$a(e,s.z,i.z,a.z,o.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}a2.prototype.isCubicBezierCurve3=!0;class wc extends kn{constructor(e=new fe,t=new fe){super();this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new fe){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){const n=t||new fe;return n.copy(this.v2).sub(this.v1).normalize(),n}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}wc.prototype.isLineCurve=!0;class KC extends kn{constructor(e=new L,t=new L){super();this.type="LineCurve3",this.isLineCurve3=!0,this.v1=e,this.v2=t}getPoint(e,t=new L){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class Kh extends kn{constructor(e=new fe,t=new fe,n=new fe){super();this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new fe){const n=t,s=this.v0,i=this.v1,a=this.v2;return n.set(Ha(e,s.x,i.x,a.x),Ha(e,s.y,i.y,a.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Kh.prototype.isQuadraticBezierCurve=!0;class o2 extends kn{constructor(e=new L,t=new L,n=new L){super();this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new L){const n=t,s=this.v0,i=this.v1,a=this.v2;return n.set(Ha(e,s.x,i.x,a.x),Ha(e,s.y,i.y,a.y),Ha(e,s.z,i.z,a.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}o2.prototype.isQuadraticBezierCurve3=!0;class Xh extends kn{constructor(e=[]){super();this.type="SplineCurve",this.points=e}getPoint(e,t=new fe){const n=t,s=this.points,i=(s.length-1)*e,a=Math.floor(i),o=i-a,c=s[a===0?a:a-1],l=s[a],u=s[a>s.length-2?s.length-1:a+1],h=s[a>s.length-3?s.length-1:a+2];return n.set(i2(o,c.x,l.x,u.x,h.x),i2(o,c.y,l.y,u.y,h.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const s=e.points[t];this.points.push(s.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const s=this.points[t];e.points.push(s.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const s=e.points[t];this.points.push(new fe().fromArray(s))}return this}}Xh.prototype.isSplineCurve=!0;var c2=Object.freeze({__proto__:null,ArcCurve:r2,CatmullRomCurve3:s2,CubicBezierCurve:qh,CubicBezierCurve3:a2,EllipseCurve:bc,LineCurve:wc,LineCurve3:KC,QuadraticBezierCurve:Kh,QuadraticBezierCurve3:o2,SplineCurve:Xh});class XC extends kn{constructor(){super();this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new wc(t,e))}getPoint(e,t){const n=e*this.getLength(),s=this.getCurveLengths();let i=0;for(;i<s.length;){if(s[i]>=n){const a=s[i]-n,o=this.curves[i],c=o.getLength(),l=c===0?0:1-a/c;return o.getPointAt(l,t)}i++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,s=this.curves.length;n<s;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let n;for(let s=0,i=this.curves;s<i.length;s++){const a=i[s],o=a&&a.isEllipseCurve?e*2:a&&(a.isLineCurve||a.isLineCurve3)?1:a&&a.isSplineCurve?e*a.points.length:e,c=a.getPoints(o);for(let l=0;l<c.length;l++){const u=c[l];n&&n.equals(u)||(t.push(u),n=u)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const s=e.curves[t];this.curves.push(s.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const s=this.curves[t];e.curves.push(s.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const s=e.curves[t];this.curves.push(new c2[s.type]().fromJSON(s))}return this}}class Yh extends XC{constructor(e){super();this.type="Path",this.currentPoint=new fe,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const n=new wc(this.currentPoint.clone(),new fe(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,s){const i=new Kh(this.currentPoint.clone(),new fe(e,t),new fe(n,s));return this.curves.push(i),this.currentPoint.set(n,s),this}bezierCurveTo(e,t,n,s,i,a){const o=new qh(this.currentPoint.clone(),new fe(e,t),new fe(n,s),new fe(i,a));return this.curves.push(o),this.currentPoint.set(i,a),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),n=new Xh(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,s,i,a){const o=this.currentPoint.x,c=this.currentPoint.y;return this.absarc(e+o,t+c,n,s,i,a),this}absarc(e,t,n,s,i,a){return this.absellipse(e,t,n,n,s,i,a),this}ellipse(e,t,n,s,i,a,o,c){const l=this.currentPoint.x,u=this.currentPoint.y;return this.absellipse(e+l,t+u,n,s,i,a,o,c),this}absellipse(e,t,n,s,i,a,o,c){const l=new bc(e,t,n,s,i,a,o,c);if(this.curves.length>0){const h=l.getPoint(0);h.equals(this.currentPoint)||this.lineTo(h.x,h.y)}this.curves.push(l);const u=l.getPoint(1);return this.currentPoint.copy(u),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class Ga extends Yh{constructor(e){super(e);this.uuid=Nn(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,s=this.holes.length;n<s;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const s=e.holes[t];this.holes.push(s.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const s=this.holes[t];e.holes.push(s.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const s=e.holes[t];this.holes.push(new Yh().fromJSON(s))}return this}}const YC={triangulate:function(r,e,t=2){const n=e&&e.length,s=n?e[0]*t:r.length;let i=u2(r,0,s,t,!0);const a=[];if(!i||i.next===i.prev)return a;let o,c,l,u,h,d,p;if(n&&(i=tL(r,e,i,t)),r.length>80*t){o=l=r[0],c=u=r[1];for(let f=t;f<s;f+=t)h=r[f],d=r[f+1],h<o&&(o=h),d<c&&(c=d),h>l&&(l=h),d>u&&(u=d);p=Math.max(l-o,u-c),p=p!==0?1/p:0}return Wa(i,a,t,o,c,p),a}};function u2(r,e,t,n,s){let i,a;if(s===dL(r,e,t,n)>0)for(i=e;i<t;i+=n)a=d2(i,r[i],r[i+1],a);else for(i=t-n;i>=e;i-=n)a=d2(i,r[i],r[i+1],a);return a&&Sc(a,a.next)&&(qa(a),a=a.next),a}function Kr(r,e){if(!r)return r;e||(e=r);let t=r,n;do if(n=!1,!t.steiner&&(Sc(t,t.next)||Mt(t.prev,t,t.next)===0)){if(qa(t),t=e=t.prev,t===t.next)break;n=!0}else t=t.next;while(n||t!==e);return e}function Wa(r,e,t,n,s,i,a){if(!r)return;!a&&i&&aL(r,n,s,i);let o=r,c,l;for(;r.prev!==r.next;){if(c=r.prev,l=r.next,i?ZC(r,n,s,i):JC(r)){e.push(c.i/t),e.push(r.i/t),e.push(l.i/t),qa(r),r=l.next,o=l.next;continue}if(r=l,r===o){a?a===1?(r=QC(Kr(r),e,t),Wa(r,e,t,n,s,i,2)):a===2&&eL(r,e,t,n,s,i):Wa(Kr(r),e,t,n,s,i,1);break}}}function JC(r){const e=r.prev,t=r,n=r.next;if(Mt(e,t,n)>=0)return!1;let s=r.next.next;for(;s!==r.prev;){if(ji(e.x,e.y,t.x,t.y,n.x,n.y,s.x,s.y)&&Mt(s.prev,s,s.next)>=0)return!1;s=s.next}return!0}function ZC(r,e,t,n){const s=r.prev,i=r,a=r.next;if(Mt(s,i,a)>=0)return!1;const o=s.x<i.x?s.x<a.x?s.x:a.x:i.x<a.x?i.x:a.x,c=s.y<i.y?s.y<a.y?s.y:a.y:i.y<a.y?i.y:a.y,l=s.x>i.x?s.x>a.x?s.x:a.x:i.x>a.x?i.x:a.x,u=s.y>i.y?s.y>a.y?s.y:a.y:i.y>a.y?i.y:a.y,h=Jh(o,c,e,t,n),d=Jh(l,u,e,t,n);let p=r.prevZ,f=r.nextZ;for(;p&&p.z>=h&&f&&f.z<=d;){if(p!==r.prev&&p!==r.next&&ji(s.x,s.y,i.x,i.y,a.x,a.y,p.x,p.y)&&Mt(p.prev,p,p.next)>=0||(p=p.prevZ,f!==r.prev&&f!==r.next&&ji(s.x,s.y,i.x,i.y,a.x,a.y,f.x,f.y)&&Mt(f.prev,f,f.next)>=0))return!1;f=f.nextZ}for(;p&&p.z>=h;){if(p!==r.prev&&p!==r.next&&ji(s.x,s.y,i.x,i.y,a.x,a.y,p.x,p.y)&&Mt(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;f&&f.z<=d;){if(f!==r.prev&&f!==r.next&&ji(s.x,s.y,i.x,i.y,a.x,a.y,f.x,f.y)&&Mt(f.prev,f,f.next)>=0)return!1;f=f.nextZ}return!0}function QC(r,e,t){let n=r;do{const s=n.prev,i=n.next.next;!Sc(s,i)&&l2(s,n,n.next,i)&&ja(s,i)&&ja(i,s)&&(e.push(s.i/t),e.push(n.i/t),e.push(i.i/t),qa(n),qa(n.next),n=r=i),n=n.next}while(n!==r);return Kr(n)}function eL(r,e,t,n,s,i){let a=r;do{let o=a.next.next;for(;o!==a.prev;){if(a.i!==o.i&&uL(a,o)){let c=h2(a,o);a=Kr(a,a.next),c=Kr(c,c.next),Wa(a,e,t,n,s,i),Wa(c,e,t,n,s,i);return}o=o.next}a=a.next}while(a!==r)}function tL(r,e,t,n){const s=[];let i,a,o,c,l;for(i=0,a=e.length;i<a;i++)o=e[i]*n,c=i<a-1?e[i+1]*n:r.length,l=u2(r,o,c,n,!1),l===l.next&&(l.steiner=!0),s.push(cL(l));for(s.sort(nL),i=0;i<s.length;i++)rL(s[i],t),t=Kr(t,t.next);return t}function nL(r,e){return r.x-e.x}function rL(r,e){if(e=sL(r,e),e){const t=h2(e,r);Kr(e,e.next),Kr(t,t.next)}}function sL(r,e){let t=e;const n=r.x,s=r.y;let i=-1/0,a;do{if(s<=t.y&&s>=t.next.y&&t.next.y!==t.y){const d=t.x+(s-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(d<=n&&d>i){if(i=d,d===n){if(s===t.y)return t;if(s===t.next.y)return t.next}a=t.x<t.next.x?t:t.next}}t=t.next}while(t!==e);if(!a)return null;if(n===i)return a;const o=a,c=a.x,l=a.y;let u=1/0,h;t=a;do n>=t.x&&t.x>=c&&n!==t.x&&ji(s<l?n:i,s,c,l,s<l?i:n,s,t.x,t.y)&&(h=Math.abs(s-t.y)/(n-t.x),ja(t,r)&&(h<u||h===u&&(t.x>a.x||t.x===a.x&&iL(a,t)))&&(a=t,u=h)),t=t.next;while(t!==o);return a}function iL(r,e){return Mt(r.prev,r,e.prev)<0&&Mt(e.next,r,r.next)<0}function aL(r,e,t,n){let s=r;do s.z===null&&(s.z=Jh(s.x,s.y,e,t,n)),s.prevZ=s.prev,s.nextZ=s.next,s=s.next;while(s!==r);s.prevZ.nextZ=null,s.prevZ=null,oL(s)}function oL(r){let e,t,n,s,i,a,o,c,l=1;do{for(t=r,r=null,i=null,a=0;t;){for(a++,n=t,o=0,e=0;e<l&&(o++,n=n.nextZ,!!n);e++);for(c=l;o>0||c>0&&n;)o!==0&&(c===0||!n||t.z<=n.z)?(s=t,t=t.nextZ,o--):(s=n,n=n.nextZ,c--),i?i.nextZ=s:r=s,s.prevZ=i,i=s;t=n}i.nextZ=null,l*=2}while(a>1);return r}function Jh(r,e,t,n,s){return r=32767*(r-t)*s,e=32767*(e-n)*s,r=(r|r<<8)&16711935,r=(r|r<<4)&252645135,r=(r|r<<2)&858993459,r=(r|r<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,r|e<<1}function cL(r){let e=r,t=r;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==r);return t}function ji(r,e,t,n,s,i,a,o){return(s-a)*(e-o)-(r-a)*(i-o)>=0&&(r-a)*(n-o)-(t-a)*(e-o)>=0&&(t-a)*(i-o)-(s-a)*(n-o)>=0}function uL(r,e){return r.next.i!==e.i&&r.prev.i!==e.i&&!lL(r,e)&&(ja(r,e)&&ja(e,r)&&hL(r,e)&&(Mt(r.prev,r,e.prev)||Mt(r,e.prev,e))||Sc(r,e)&&Mt(r.prev,r,r.next)>0&&Mt(e.prev,e,e.next)>0)}function Mt(r,e,t){return(e.y-r.y)*(t.x-e.x)-(e.x-r.x)*(t.y-e.y)}function Sc(r,e){return r.x===e.x&&r.y===e.y}function l2(r,e,t,n){const s=Ec(Mt(r,e,t)),i=Ec(Mt(r,e,n)),a=Ec(Mt(t,n,r)),o=Ec(Mt(t,n,e));return!!(s!==i&&a!==o||s===0&&Tc(r,t,e)||i===0&&Tc(r,n,e)||a===0&&Tc(t,r,n)||o===0&&Tc(t,e,n))}function Tc(r,e,t){return e.x<=Math.max(r.x,t.x)&&e.x>=Math.min(r.x,t.x)&&e.y<=Math.max(r.y,t.y)&&e.y>=Math.min(r.y,t.y)}function Ec(r){return r>0?1:r<0?-1:0}function lL(r,e){let t=r;do{if(t.i!==r.i&&t.next.i!==r.i&&t.i!==e.i&&t.next.i!==e.i&&l2(t,t.next,r,e))return!0;t=t.next}while(t!==r);return!1}function ja(r,e){return Mt(r.prev,r,r.next)<0?Mt(r,e,r.next)>=0&&Mt(r,r.prev,e)>=0:Mt(r,e,r.prev)<0||Mt(r,r.next,e)<0}function hL(r,e){let t=r,n=!1;const s=(r.x+e.x)/2,i=(r.y+e.y)/2;do t.y>i!=t.next.y>i&&t.next.y!==t.y&&s<(t.next.x-t.x)*(i-t.y)/(t.next.y-t.y)+t.x&&(n=!n),t=t.next;while(t!==r);return n}function h2(r,e){const t=new Zh(r.i,r.x,r.y),n=new Zh(e.i,e.x,e.y),s=r.next,i=e.prev;return r.next=e,e.prev=r,t.next=s,s.prev=t,n.next=t,t.prev=n,i.next=n,n.prev=i,n}function d2(r,e,t,n){const s=new Zh(r,e,t);return n?(s.next=n.next,s.prev=n,n.next.prev=s,n.next=s):(s.prev=s,s.next=s),s}function qa(r){r.next.prev=r.prev,r.prev.next=r.next,r.prevZ&&(r.prevZ.nextZ=r.nextZ),r.nextZ&&(r.nextZ.prevZ=r.prevZ)}function Zh(r,e,t){this.i=r,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function dL(r,e,t,n){let s=0;for(let i=e,a=t-n;i<t;i+=n)s+=(r[a]-r[i])*(r[i+1]+r[a+1]),a=i;return s}class Xr{static area(e){const t=e.length;let n=0;for(let s=t-1,i=0;i<t;s=i++)n+=e[s].x*e[i].y-e[i].x*e[s].y;return n*.5}static isClockWise(e){return Xr.area(e)<0}static triangulateShape(e,t){const n=[],s=[],i=[];p2(e),f2(n,e);let a=e.length;t.forEach(p2);for(let c=0;c<t.length;c++)s.push(a),a+=t[c].length,f2(n,t[c]);const o=YC.triangulate(n,s);for(let c=0;c<o.length;c+=3)i.push(o.slice(c,c+3));return i}}function p2(r){const e=r.length;e>2&&r[e-1].equals(r[0])&&r.pop()}function f2(r,e){for(let t=0;t<e.length;t++)r.push(e[t].x),r.push(e[t].y)}class qi extends yt{constructor(e=new Ga([new fe(.5,.5),new fe(-.5,.5),new fe(-.5,-.5),new fe(.5,-.5)]),t={}){super();this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,s=[],i=[];for(let o=0,c=e.length;o<c;o++){const l=e[o];a(l)}this.setAttribute("position",new Nt(s,3)),this.setAttribute("uv",new Nt(i,2)),this.computeVertexNormals();function a(o){const c=[],l=t.curveSegments!==void 0?t.curveSegments:12,u=t.steps!==void 0?t.steps:1;let h=t.depth!==void 0?t.depth:1,d=t.bevelEnabled!==void 0?t.bevelEnabled:!0,p=t.bevelThickness!==void 0?t.bevelThickness:.2,f=t.bevelSize!==void 0?t.bevelSize:p-.1,m=t.bevelOffset!==void 0?t.bevelOffset:0,_=t.bevelSegments!==void 0?t.bevelSegments:3;const g=t.extrudePath,y=t.UVGenerator!==void 0?t.UVGenerator:pL;t.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),h=t.amount);let x,w=!1,T,M,S,R;g&&(x=g.getSpacedPoints(u),w=!0,d=!1,T=g.computeFrenetFrames(u,!1),M=new L,S=new L,R=new L),d||(_=0,p=0,f=0,m=0);const k=o.extractPoints(l);let O=k.shape;const A=k.holes;if(!Xr.isClockWise(O)){O=O.reverse();for(let te=0,ie=A.length;te<ie;te++){const me=A[te];Xr.isClockWise(me)&&(A[te]=me.reverse())}}const B=Xr.triangulateShape(O,A),H=O;for(let te=0,ie=A.length;te<ie;te++){const me=A[te];O=O.concat(me)}function U(te,ie,me){return ie||console.error("THREE.ExtrudeGeometry: vec does not exist"),ie.clone().multiplyScalar(me).add(te)}const j=O.length,K=B.length;function se(te,ie,me){let Ie,be,Ge;const $e=te.x-ie.x,We=te.y-ie.y,ot=me.x-te.x,D=me.y-te.y,I=$e*$e+We*We,oe=$e*D-We*ot;if(Math.abs(oe)>Number.EPSILON){const ce=Math.sqrt(I),ke=Math.sqrt(ot*ot+D*D),Pe=ie.x-We/ce,$=ie.y+$e/ce,de=me.x-D/ke,le=me.y+ot/ke,Se=((de-Pe)*D-(le-$)*ot)/($e*D-We*ot);Ie=Pe+$e*Se-te.x,be=$+We*Se-te.y;const ve=Ie*Ie+be*be;if(ve<=2)return new fe(Ie,be);Ge=Math.sqrt(ve/2)}else{let ce=!1;$e>Number.EPSILON?ot>Number.EPSILON&&(ce=!0):$e<-Number.EPSILON?ot<-Number.EPSILON&&(ce=!0):Math.sign(We)===Math.sign(D)&&(ce=!0),ce?(Ie=-We,be=$e,Ge=Math.sqrt(I)):(Ie=$e,be=We,Ge=Math.sqrt(I/2))}return new fe(Ie/Ge,be/Ge)}const ue=[];for(let te=0,ie=H.length,me=ie-1,Ie=te+1;te<ie;te++,me++,Ie++)me===ie&&(me=0),Ie===ie&&(Ie=0),ue[te]=se(H[te],H[me],H[Ie]);const Q=[];let ee,ge=ue.concat();for(let te=0,ie=A.length;te<ie;te++){const me=A[te];ee=[];for(let Ie=0,be=me.length,Ge=be-1,$e=Ie+1;Ie<be;Ie++,Ge++,$e++)Ge===be&&(Ge=0),$e===be&&($e=0),ee[Ie]=se(me[Ie],me[Ge],me[$e]);Q.push(ee),ge=ge.concat(ee)}for(let te=0;te<_;te++){const ie=te/_,me=p*Math.cos(ie*Math.PI/2),Ie=f*Math.sin(ie*Math.PI/2)+m;for(let be=0,Ge=H.length;be<Ge;be++){const $e=U(H[be],ue[be],Ie);Ve($e.x,$e.y,-me)}for(let be=0,Ge=A.length;be<Ge;be++){const $e=A[be];ee=Q[be];for(let We=0,ot=$e.length;We<ot;We++){const D=U($e[We],ee[We],Ie);Ve(D.x,D.y,-me)}}}const he=f+m;for(let te=0;te<j;te++){const ie=d?U(O[te],ge[te],he):O[te];w?(S.copy(T.normals[0]).multiplyScalar(ie.x),M.copy(T.binormals[0]).multiplyScalar(ie.y),R.copy(x[0]).add(S).add(M),Ve(R.x,R.y,R.z)):Ve(ie.x,ie.y,0)}for(let te=1;te<=u;te++)for(let ie=0;ie<j;ie++){const me=d?U(O[ie],ge[ie],he):O[ie];w?(S.copy(T.normals[te]).multiplyScalar(me.x),M.copy(T.binormals[te]).multiplyScalar(me.y),R.copy(x[te]).add(S).add(M),Ve(R.x,R.y,R.z)):Ve(me.x,me.y,h/u*te)}for(let te=_-1;te>=0;te--){const ie=te/_,me=p*Math.cos(ie*Math.PI/2),Ie=f*Math.sin(ie*Math.PI/2)+m;for(let be=0,Ge=H.length;be<Ge;be++){const $e=U(H[be],ue[be],Ie);Ve($e.x,$e.y,h+me)}for(let be=0,Ge=A.length;be<Ge;be++){const $e=A[be];ee=Q[be];for(let We=0,ot=$e.length;We<ot;We++){const D=U($e[We],ee[We],Ie);w?Ve(D.x,D.y+x[u-1].y,x[u-1].x+me):Ve(D.x,D.y,h+me)}}}Me(),je();function Me(){const te=s.length/3;if(d){let ie=0,me=j*ie;for(let Ie=0;Ie<K;Ie++){const be=B[Ie];He(be[2]+me,be[1]+me,be[0]+me)}ie=u+_*2,me=j*ie;for(let Ie=0;Ie<K;Ie++){const be=B[Ie];He(be[0]+me,be[1]+me,be[2]+me)}}else{for(let ie=0;ie<K;ie++){const me=B[ie];He(me[2],me[1],me[0])}for(let ie=0;ie<K;ie++){const me=B[ie];He(me[0]+j*u,me[1]+j*u,me[2]+j*u)}}n.addGroup(te,s.length/3-te,0)}function je(){const te=s.length/3;let ie=0;ae(H,ie),ie+=H.length;for(let me=0,Ie=A.length;me<Ie;me++){const be=A[me];ae(be,ie),ie+=be.length}n.addGroup(te,s.length/3-te,1)}function ae(te,ie){let me=te.length;for(;--me>=0;){const Ie=me;let be=me-1;be<0&&(be=te.length-1);for(let Ge=0,$e=u+_*2;Ge<$e;Ge++){const We=j*Ge,ot=j*(Ge+1),D=ie+Ie+We,I=ie+be+We,oe=ie+be+ot,ce=ie+Ie+ot;Re(D,I,oe,ce)}}}function Ve(te,ie,me){c.push(te),c.push(ie),c.push(me)}function He(te,ie,me){ze(te),ze(ie),ze(me);const Ie=s.length/3,be=y.generateTopUV(n,s,Ie-3,Ie-2,Ie-1);Ye(be[0]),Ye(be[1]),Ye(be[2])}function Re(te,ie,me,Ie){ze(te),ze(ie),ze(Ie),ze(ie),ze(me),ze(Ie);const be=s.length/3,Ge=y.generateSideWallUV(n,s,be-6,be-3,be-2,be-1);Ye(Ge[0]),Ye(Ge[1]),Ye(Ge[3]),Ye(Ge[1]),Ye(Ge[2]),Ye(Ge[3])}function ze(te){s.push(c[te*3+0]),s.push(c[te*3+1]),s.push(c[te*3+2])}function Ye(te){i.push(te.x),i.push(te.y)}}}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,n=this.parameters.options;return fL(t,n,e)}static fromJSON(e,t){const n=[];for(let i=0,a=e.shapes.length;i<a;i++){const o=t[e.shapes[i]];n.push(o)}const s=e.options.extrudePath;return s!==void 0&&(e.options.extrudePath=new c2[s.type]().fromJSON(s)),new qi(n,e.options)}}const pL={generateTopUV:function(r,e,t,n,s){const i=e[t*3],a=e[t*3+1],o=e[n*3],c=e[n*3+1],l=e[s*3],u=e[s*3+1];return[new fe(i,a),new fe(o,c),new fe(l,u)]},generateSideWallUV:function(r,e,t,n,s,i){const a=e[t*3],o=e[t*3+1],c=e[t*3+2],l=e[n*3],u=e[n*3+1],h=e[n*3+2],d=e[s*3],p=e[s*3+1],f=e[s*3+2],m=e[i*3],_=e[i*3+1],g=e[i*3+2];return Math.abs(o-u)<Math.abs(a-l)?[new fe(a,1-c),new fe(l,1-h),new fe(d,1-f),new fe(m,1-g)]:[new fe(o,1-c),new fe(u,1-h),new fe(p,1-f),new fe(_,1-g)]}};function fL(r,e,t){if(t.shapes=[],Array.isArray(r))for(let n=0,s=r.length;n<s;n++){const i=r[n];t.shapes.push(i.uuid)}else t.shapes.push(r.uuid);return e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class Qh extends yt{constructor(e=new Ga([new fe(0,.5),new fe(-.5,-.5),new fe(.5,-.5)]),t=12){super();this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const n=[],s=[],i=[],a=[];let o=0,c=0;if(Array.isArray(e)===!1)l(e);else for(let u=0;u<e.length;u++)l(e[u]),this.addGroup(o,c,u),o+=c,c=0;this.setIndex(n),this.setAttribute("position",new Nt(s,3)),this.setAttribute("normal",new Nt(i,3)),this.setAttribute("uv",new Nt(a,2));function l(u){const h=s.length/3,d=u.extractPoints(t);let p=d.shape;const f=d.holes;Xr.isClockWise(p)===!1&&(p=p.reverse());for(let _=0,g=f.length;_<g;_++){const y=f[_];Xr.isClockWise(y)===!0&&(f[_]=y.reverse())}const m=Xr.triangulateShape(p,f);for(let _=0,g=f.length;_<g;_++){const y=f[_];p=p.concat(y)}for(let _=0,g=p.length;_<g;_++){const y=p[_];s.push(y.x,y.y,0),i.push(0,0,1),a.push(y.x,y.y)}for(let _=0,g=m.length;_<g;_++){const y=m[_],x=y[0]+h,w=y[1]+h,T=y[2]+h;n.push(x,w,T),c+=3}}}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return mL(t,e)}static fromJSON(e,t){const n=[];for(let s=0,i=e.shapes.length;s<i;s++){const a=t[e.shapes[s]];n.push(a)}return new Qh(n,e.curveSegments)}}function mL(r,e){if(e.shapes=[],Array.isArray(r))for(let t=0,n=r.length;t<n;t++){const s=r[t];e.shapes.push(s.uuid)}else e.shapes.push(r.uuid);return e}class gL extends Ht{constructor(e){super();this.type="ShadowMaterial",this.color=new Le(0),this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this}}gL.prototype.isShadowMaterial=!0;class Ns extends Ht{constructor(e){super();this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Le(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Le(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=bs,this.normalScale=new fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this}}Ns.prototype.isMeshStandardMaterial=!0;class Rs extends Ns{constructor(e){super();this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new fe(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return _n(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.sheenColor=new Le(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new Le(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Le(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(e)}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}Rs.prototype.isMeshPhysicalMaterial=!0;class yL extends Ht{constructor(e){super();this.type="MeshPhongMaterial",this.color=new Le(16777215),this.specular=new Le(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Le(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=bs,this.normalScale=new fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ko,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this}}yL.prototype.isMeshPhongMaterial=!0;class _L extends Ht{constructor(e){super();this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Le(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Le(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=bs,this.normalScale=new fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}_L.prototype.isMeshToonMaterial=!0;class xL extends Ht{constructor(e){super();this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=bs,this.normalScale=new fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}xL.prototype.isMeshNormalMaterial=!0;class bL extends Ht{constructor(e){super();this.type="MeshLambertMaterial",this.color=new Le(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Le(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ko,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}bL.prototype.isMeshLambertMaterial=!0;class vL extends Ht{constructor(e){super();this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Le(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=bs,this.normalScale=new fe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this}}vL.prototype.isMeshMatcapMaterial=!0;class wL extends Wi{constructor(e){super();this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}wL.prototype.isLineDashedMaterial=!0;const wt={arraySlice:function(r,e,t){return wt.isTypedArray(r)?new r.constructor(r.subarray(e,t!==void 0?t:r.length)):r.slice(e,t)},convertArray:function(r,e,t){return!r||!t&&r.constructor===e?r:typeof e.BYTES_PER_ELEMENT=="number"?new e(r):Array.prototype.slice.call(r)},isTypedArray:function(r){return ArrayBuffer.isView(r)&&!(r instanceof DataView)},getKeyframeOrder:function(r){function e(s,i){return r[s]-r[i]}const t=r.length,n=new Array(t);for(let s=0;s!==t;++s)n[s]=s;return n.sort(e),n},sortedArray:function(r,e,t){const n=r.length,s=new r.constructor(n);for(let i=0,a=0;a!==n;++i){const o=t[i]*e;for(let c=0;c!==e;++c)s[a++]=r[o+c]}return s},flattenJSON:function(r,e,t,n){let s=1,i=r[0];for(;i!==void 0&&i[n]===void 0;)i=r[s++];if(i===void 0)return;let a=i[n];if(a!==void 0)if(Array.isArray(a))do a=i[n],a!==void 0&&(e.push(i.time),t.push.apply(t,a)),i=r[s++];while(i!==void 0);else if(a.toArray!==void 0)do a=i[n],a!==void 0&&(e.push(i.time),a.toArray(t,t.length)),i=r[s++];while(i!==void 0);else do a=i[n],a!==void 0&&(e.push(i.time),t.push(a)),i=r[s++];while(i!==void 0)},subclip:function(r,e,t,n,s=30){const i=r.clone();i.name=e;const a=[];for(let c=0;c<i.tracks.length;++c){const l=i.tracks[c],u=l.getValueSize(),h=[],d=[];for(let p=0;p<l.times.length;++p){const f=l.times[p]*s;if(!(f<t||f>=n)){h.push(l.times[p]);for(let m=0;m<u;++m)d.push(l.values[p*u+m])}}h.length!==0&&(l.times=wt.convertArray(h,l.times.constructor),l.values=wt.convertArray(d,l.values.constructor),a.push(l))}i.tracks=a;let o=1/0;for(let c=0;c<i.tracks.length;++c)o>i.tracks[c].times[0]&&(o=i.tracks[c].times[0]);for(let c=0;c<i.tracks.length;++c)i.tracks[c].shift(-1*o);return i.resetDuration(),i},makeClipAdditive:function(r,e=0,t=r,n=30){n<=0&&(n=30);const s=t.tracks.length,i=e/n;for(let a=0;a<s;++a){const o=t.tracks[a],c=o.ValueTypeName;if(c==="bool"||c==="string")continue;const l=r.tracks.find(function(g){return g.name===o.name&&g.ValueTypeName===c});if(l===void 0)continue;let u=0;const h=o.getValueSize();o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=h/3);let d=0;const p=l.getValueSize();l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=p/3);const f=o.times.length-1;let m;if(i<=o.times[0]){const g=u,y=h-u;m=wt.arraySlice(o.values,g,y)}else if(i>=o.times[f]){const g=f*h+u,y=g+h-u;m=wt.arraySlice(o.values,g,y)}else{const g=o.createInterpolant(),y=u,x=h-u;g.evaluate(i),m=wt.arraySlice(g.resultBuffer,y,x)}c==="quaternion"&&new hn().fromArray(m).normalize().conjugate().toArray(m);const _=l.times.length;for(let g=0;g<_;++g){const y=g*p+d;if(c==="quaternion")hn.multiplyQuaternionsFlat(l.values,y,m,0,l.values,y);else{const x=p-d*2;for(let w=0;w<x;++w)l.values[y+w]-=m[w]}}}return r.blendMode=M1,r}};class pr{constructor(e,t,n,s){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=s!==void 0?s:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,s=t[n],i=t[n-1];e:{t:{let a;n:{r:if(!(e<s)){for(let o=n+2;;){if(s===void 0){if(e<i)break r;return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,e,i)}if(n===o)break;if(i=s,s=t[++n],e<s)break t}a=t.length;break n}if(!(e>=i)){const o=t[1];e<o&&(n=2,i=o);for(let c=n-2;;){if(i===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,s);if(n===c)break;if(s=i,i=t[--n-1],e>=i)break t}a=n,n=0;break n}break e}for(;n<a;){const o=n+a>>>1;e<t[o]?a=o:n=o+1}if(s=t[n],i=t[n-1],i===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,s);if(s===void 0)return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,i,e)}this._cachedIndex=n,this.intervalChanged_(n,i,s)}return this.interpolate_(n,i,e,s)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,s=this.valueSize,i=e*s;for(let a=0;a!==s;++a)t[a]=n[i+a];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}pr.prototype.beforeStart_=pr.prototype.copySampleValue_;pr.prototype.afterEnd_=pr.prototype.copySampleValue_;class SL extends pr{constructor(e,t,n,s){super(e,t,n,s);this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:mi,endingEnd:mi}}intervalChanged_(e,t,n){const s=this.parameterPositions;let i=e-2,a=e+1,o=s[i],c=s[a];if(o===void 0)switch(this.getSettings_().endingStart){case gi:i=e,o=2*t-n;break;case Oo:i=s.length-2,o=t+s[i]-s[i+1];break;default:i=e,o=n}if(c===void 0)switch(this.getSettings_().endingEnd){case gi:a=e,c=2*n-t;break;case Oo:a=1,c=n+s[1]-s[0];break;default:a=e-1,c=t}const l=(n-t)*.5,u=this.valueSize;this._weightPrev=l/(t-o),this._weightNext=l/(c-n),this._offsetPrev=i*u,this._offsetNext=a*u}interpolate_(e,t,n,s){const i=this.resultBuffer,a=this.sampleValues,o=this.valueSize,c=e*o,l=c-o,u=this._offsetPrev,h=this._offsetNext,d=this._weightPrev,p=this._weightNext,f=(n-t)/(s-t),m=f*f,_=m*f,g=-d*_+2*d*m-d*f,y=(1+d)*_+(-1.5-2*d)*m+(-.5+d)*f+1,x=(-1-p)*_+(1.5+p)*m+.5*f,w=p*_-p*m;for(let T=0;T!==o;++T)i[T]=g*a[u+T]+y*a[l+T]+x*a[c+T]+w*a[h+T];return i}}class m2 extends pr{constructor(e,t,n,s){super(e,t,n,s)}interpolate_(e,t,n,s){const i=this.resultBuffer,a=this.sampleValues,o=this.valueSize,c=e*o,l=c-o,u=(n-t)/(s-t),h=1-u;for(let d=0;d!==o;++d)i[d]=a[l+d]*h+a[c+d]*u;return i}}class TL extends pr{constructor(e,t,n,s){super(e,t,n,s)}interpolate_(e){return this.copySampleValue_(e-1)}}class Yn{constructor(e,t,n,s){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=wt.convertArray(t,this.TimeBufferType),this.values=wt.convertArray(n,this.ValueBufferType),this.setInterpolation(s||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:wt.convertArray(e.times,Array),values:wt.convertArray(e.values,Array)};const s=e.getInterpolation();s!==e.DefaultInterpolation&&(n.interpolation=s)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new TL(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new m2(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new SL(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case Ea:t=this.InterpolantFactoryMethodDiscrete;break;case fi:t=this.InterpolantFactoryMethodLinear;break;case ql:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return Ea;case this.InterpolantFactoryMethodLinear:return fi;case this.InterpolantFactoryMethodSmooth:return ql}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let n=0,s=t.length;n!==s;++n)t[n]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let n=0,s=t.length;n!==s;++n)t[n]*=e}return this}trim(e,t){const n=this.times,s=n.length;let i=0,a=s-1;for(;i!==s&&n[i]<e;)++i;for(;a!==-1&&n[a]>t;)--a;if(++a,i!==0||a!==s){i>=a&&(a=Math.max(a,1),i=a-1);const o=this.getValueSize();this.times=wt.arraySlice(n,i,a),this.values=wt.arraySlice(this.values,i*o,a*o)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,s=this.values,i=n.length;i===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let a=null;for(let o=0;o!==i;o++){const c=n[o];if(typeof c=="number"&&isNaN(c)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,c),e=!1;break}if(a!==null&&a>c){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,c,a),e=!1;break}a=c}if(s!==void 0&&wt.isTypedArray(s))for(let o=0,c=s.length;o!==c;++o){const l=s[o];if(isNaN(l)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,l),e=!1;break}}return e}optimize(){const e=wt.arraySlice(this.times),t=wt.arraySlice(this.values),n=this.getValueSize(),s=this.getInterpolation()===ql,i=e.length-1;let a=1;for(let o=1;o<i;++o){let c=!1;const l=e[o],u=e[o+1];if(l!==u&&(o!==1||l!==e[0]))if(s)c=!0;else{const h=o*n,d=h-n,p=h+n;for(let f=0;f!==n;++f){const m=t[h+f];if(m!==t[d+f]||m!==t[p+f]){c=!0;break}}}if(c){if(o!==a){e[a]=e[o];const h=o*n,d=a*n;for(let p=0;p!==n;++p)t[d+p]=t[h+p]}++a}}if(i>0){e[a]=e[i];for(let o=i*n,c=a*n,l=0;l!==n;++l)t[c+l]=t[o+l];++a}return a!==e.length?(this.times=wt.arraySlice(e,0,a),this.values=wt.arraySlice(t,0,a*n)):(this.times=e,this.values=t),this}clone(){const e=wt.arraySlice(this.times,0),t=wt.arraySlice(this.values,0),n=this.constructor,s=new n(this.name,e,t);return s.createInterpolant=this.createInterpolant,s}}Yn.prototype.TimeBufferType=Float32Array;Yn.prototype.ValueBufferType=Float32Array;Yn.prototype.DefaultInterpolation=fi;class Ki extends Yn{}Ki.prototype.ValueTypeName="bool";Ki.prototype.ValueBufferType=Array;Ki.prototype.DefaultInterpolation=Ea;Ki.prototype.InterpolantFactoryMethodLinear=void 0;Ki.prototype.InterpolantFactoryMethodSmooth=void 0;class g2 extends Yn{}g2.prototype.ValueTypeName="color";class Ka extends Yn{}Ka.prototype.ValueTypeName="number";class EL extends pr{constructor(e,t,n,s){super(e,t,n,s)}interpolate_(e,t,n,s){const i=this.resultBuffer,a=this.sampleValues,o=this.valueSize,c=(n-t)/(s-t);let l=e*o;for(let u=l+o;l!==u;l+=4)hn.slerpFlat(i,0,a,l-o,a,l,c);return i}}class Cs extends Yn{InterpolantFactoryMethodLinear(e){return new EL(this.times,this.values,this.getValueSize(),e)}}Cs.prototype.ValueTypeName="quaternion";Cs.prototype.DefaultInterpolation=fi;Cs.prototype.InterpolantFactoryMethodSmooth=void 0;class Xi extends Yn{}Xi.prototype.ValueTypeName="string";Xi.prototype.ValueBufferType=Array;Xi.prototype.DefaultInterpolation=Ea;Xi.prototype.InterpolantFactoryMethodLinear=void 0;Xi.prototype.InterpolantFactoryMethodSmooth=void 0;class Xa extends Yn{}Xa.prototype.ValueTypeName="vector";class ed{constructor(e,t=-1,n,s=Kl){this.name=e,this.tracks=n,this.duration=t,this.blendMode=s,this.uuid=Nn(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,s=1/(e.fps||1);for(let a=0,o=n.length;a!==o;++a)t.push(AL(n[a]).scale(s));const i=new this(e.name,e.duration,t,e.blendMode);return i.uuid=e.uuid,i}static toJSON(e){const t=[],n=e.tracks,s={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let i=0,a=n.length;i!==a;++i)t.push(Yn.toJSON(n[i]));return s}static CreateFromMorphTargetSequence(e,t,n,s){const i=t.length,a=[];for(let o=0;o<i;o++){let c=[],l=[];c.push((o+i-1)%i,o,(o+1)%i),l.push(0,1,0);const u=wt.getKeyframeOrder(c);c=wt.sortedArray(c,1,u),l=wt.sortedArray(l,1,u),!s&&c[0]===0&&(c.push(i),l.push(l[0])),a.push(new Ka(".morphTargetInfluences["+t[o].name+"]",c,l).scale(1/n))}return new this(e,-1,a)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const s=e;n=s.geometry&&s.geometry.animations||s.animations}for(let s=0;s<n.length;s++)if(n[s].name===t)return n[s];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const s={},i=/^([\w-]*?)([\d]+)$/;for(let o=0,c=e.length;o<c;o++){const l=e[o],u=l.name.match(i);if(u&&u.length>1){const h=u[1];let d=s[h];d||(s[h]=d=[]),d.push(l)}}const a=[];for(const o in s)a.push(this.CreateFromMorphTargetSequence(o,s[o],t,n));return a}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(h,d,p,f,m){if(p.length!==0){const _=[],g=[];wt.flattenJSON(p,_,g,f),_.length!==0&&m.push(new h(d,_,g))}},s=[],i=e.name||"default",a=e.fps||30,o=e.blendMode;let c=e.length||-1;const l=e.hierarchy||[];for(let h=0;h<l.length;h++){const d=l[h].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const p={};let f;for(f=0;f<d.length;f++)if(d[f].morphTargets)for(let m=0;m<d[f].morphTargets.length;m++)p[d[f].morphTargets[m]]=-1;for(const m in p){const _=[],g=[];for(let y=0;y!==d[f].morphTargets.length;++y){const x=d[f];_.push(x.time),g.push(x.morphTarget===m?1:0)}s.push(new Ka(".morphTargetInfluence["+m+"]",_,g))}c=p.length*(a||1)}else{const p=".bones["+t[h].name+"]";n(Xa,p+".position",d,"pos",s),n(Cs,p+".quaternion",d,"rot",s),n(Xa,p+".scale",d,"scl",s)}}return s.length===0?null:new this(i,c,s,o)}resetDuration(){const e=this.tracks;let t=0;for(let n=0,s=e.length;n!==s;++n){const i=this.tracks[n];t=Math.max(t,i.times[i.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function ML(r){switch(r.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Ka;case"vector":case"vector2":case"vector3":case"vector4":return Xa;case"color":return g2;case"quaternion":return Cs;case"bool":case"boolean":return Ki;case"string":return Xi}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+r)}function AL(r){if(r.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=ML(r.type);if(r.times===void 0){const t=[],n=[];wt.flattenJSON(r.keys,t,n,"value"),r.times=t,r.values=n}return e.parse!==void 0?e.parse(r):new e(r.name,r.times,r.values,r.interpolation)}const Yi={enabled:!1,files:{},add:function(r,e){this.enabled!==!1&&(this.files[r]=e)},get:function(r){if(this.enabled!==!1)return this.files[r]},remove:function(r){delete this.files[r]},clear:function(){this.files={}}};class IL{constructor(e,t,n){const s=this;let i=!1,a=0,o=0,c;const l=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(u){o++,i===!1&&s.onStart!==void 0&&s.onStart(u,a,o),i=!0},this.itemEnd=function(u){a++,s.onProgress!==void 0&&s.onProgress(u,a,o),a===o&&(i=!1,s.onLoad!==void 0&&s.onLoad())},this.itemError=function(u){s.onError!==void 0&&s.onError(u)},this.resolveURL=function(u){return c?c(u):u},this.setURLModifier=function(u){return c=u,this},this.addHandler=function(u,h){return l.push(u,h),this},this.removeHandler=function(u){const h=l.indexOf(u);return h!==-1&&l.splice(h,2),this},this.getHandler=function(u){for(let h=0,d=l.length;h<d;h+=2){const p=l[h],f=l[h+1];if(p.global&&(p.lastIndex=0),p.test(u))return f}return null}}}const NL=new IL;class fr{constructor(e){this.manager=e!==void 0?e:NL,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise(function(s,i){n.load(e,s,t,i)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}const mr={};class td extends fr{constructor(e){super(e)}load(e,t,n,s){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const i=Yi.get(e);if(i!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(i),this.manager.itemEnd(e)},0),i;if(mr[e]!==void 0){mr[e].push({onLoad:t,onProgress:n,onError:s});return}mr[e]=[],mr[e].push({onLoad:t,onProgress:n,onError:s});const a=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"});fetch(a).then(o=>{if(o.status===200||o.status===0){o.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received.");const c=mr[e],l=o.body.getReader(),u=o.headers.get("Content-Length"),h=u?parseInt(u):0,d=h!==0;let p=0;return new ReadableStream({start(f){m();function m(){l.read().then(({done:_,value:g})=>{if(_)f.close();else{p+=g.byteLength;const y=new ProgressEvent("progress",{lengthComputable:d,loaded:p,total:h});for(let x=0,w=c.length;x<w;x++){const T=c[x];T.onProgress&&T.onProgress(y)}f.enqueue(g),m()}})}}})}else throw Error(`fetch for "${o.url}" responded with ${o.status}: ${o.statusText}`)}).then(o=>{const c=new Response(o);switch(this.responseType){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(l=>new DOMParser().parseFromString(l,this.mimeType));case"json":return c.json();default:return c.text()}}).then(o=>{Yi.add(e,o);const c=mr[e];delete mr[e];for(let l=0,u=c.length;l<u;l++){const h=c[l];h.onLoad&&h.onLoad(o)}this.manager.itemEnd(e)}).catch(o=>{const c=mr[e];delete mr[e];for(let l=0,u=c.length;l<u;l++){const h=c[l];h.onError&&h.onError(o)}this.manager.itemError(e),this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class y2 extends fr{constructor(e){super(e)}load(e,t,n,s){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const i=this,a=Yi.get(e);if(a!==void 0)return i.manager.itemStart(e),setTimeout(function(){t&&t(a),i.manager.itemEnd(e)},0),a;const o=Uo("img");function c(){u(),Yi.add(e,this),t&&t(this),i.manager.itemEnd(e)}function l(h){u(),s&&s(h),i.manager.itemError(e),i.manager.itemEnd(e)}function u(){o.removeEventListener("load",c,!1),o.removeEventListener("error",l,!1)}return o.addEventListener("load",c,!1),o.addEventListener("error",l,!1),e.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),i.manager.itemStart(e),o.src=e,o}}class RL extends fr{constructor(e){super(e)}load(e,t,n,s){const i=new rc,a=new y2(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let o=0;function c(l){a.load(e[l],function(u){i.images[l]=u,o++,o===6&&(i.needsUpdate=!0,t&&t(i))},void 0,s)}for(let l=0;l<e.length;++l)c(l);return i}}class nd extends fr{constructor(e){super(e)}load(e,t,n,s){const i=new Vt,a=new y2(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(e,function(o){i.image=o,i.needsUpdate=!0,t!==void 0&&t(i)},n,s),i}}class Jn extends it{constructor(e,t=1){super();this.type="Light",this.color=new Le(e),this.intensity=t}dispose(){}copy(e){return super.copy(e),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}Jn.prototype.isLight=!0;class _2 extends Jn{constructor(e,t,n){super(e,n);this.type="HemisphereLight",this.position.copy(it.DefaultUp),this.updateMatrix(),this.groundColor=new Le(t)}copy(e){return Jn.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}_2.prototype.isHemisphereLight=!0;const x2=new Be,b2=new L,v2=new L;class rd{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new fe(512,512),this.map=null,this.mapPass=null,this.matrix=new Be,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new ic,this._frameExtents=new fe(1,1),this._viewportCount=1,this._viewports=[new pt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;b2.setFromMatrixPosition(e.matrixWorld),t.position.copy(b2),v2.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(v2),t.updateMatrixWorld(),x2.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(x2),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class w2 extends rd{constructor(){super(new dn(50,1,.5,500));this.focus=1}updateMatrices(e){const t=this.camera,n=Ia*2*e.angle*this.focus,s=this.mapSize.width/this.mapSize.height,i=e.distance||t.far;(n!==t.fov||s!==t.aspect||i!==t.far)&&(t.fov=n,t.aspect=s,t.far=i,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}w2.prototype.isSpotLightShadow=!0;class S2 extends Jn{constructor(e,t,n=0,s=Math.PI/3,i=0,a=1){super(e,t);this.type="SpotLight",this.position.copy(it.DefaultUp),this.updateMatrix(),this.target=new it,this.distance=n,this.angle=s,this.penumbra=i,this.decay=a,this.shadow=new w2}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}S2.prototype.isSpotLight=!0;const T2=new Be,Ya=new L,sd=new L;class E2 extends rd{constructor(){super(new dn(90,1,.5,500));this._frameExtents=new fe(4,2),this._viewportCount=6,this._viewports=[new pt(2,1,1,1),new pt(0,1,1,1),new pt(3,1,1,1),new pt(1,1,1,1),new pt(3,0,1,1),new pt(1,0,1,1)],this._cubeDirections=[new L(1,0,0),new L(-1,0,0),new L(0,0,1),new L(0,0,-1),new L(0,1,0),new L(0,-1,0)],this._cubeUps=[new L(0,1,0),new L(0,1,0),new L(0,1,0),new L(0,1,0),new L(0,0,1),new L(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,s=this.matrix,i=e.distance||n.far;i!==n.far&&(n.far=i,n.updateProjectionMatrix()),Ya.setFromMatrixPosition(e.matrixWorld),n.position.copy(Ya),sd.copy(n.position),sd.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(sd),n.updateMatrixWorld(),s.makeTranslation(-Ya.x,-Ya.y,-Ya.z),T2.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(T2)}}E2.prototype.isPointLightShadow=!0;class M2 extends Jn{constructor(e,t,n=0,s=1){super(e,t);this.type="PointLight",this.distance=n,this.decay=s,this.shadow=new E2}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}M2.prototype.isPointLight=!0;class A2 extends rd{constructor(){super(new Pa(-5,5,5,-5,.5,500))}}A2.prototype.isDirectionalLightShadow=!0;class id extends Jn{constructor(e,t){super(e,t);this.type="DirectionalLight",this.position.copy(it.DefaultUp),this.updateMatrix(),this.target=new it,this.shadow=new A2}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}id.prototype.isDirectionalLight=!0;class CL extends Jn{constructor(e,t){super(e,t);this.type="AmbientLight"}}CL.prototype.isAmbientLight=!0;class LL extends Jn{constructor(e,t,n=10,s=10){super(e,t);this.type="RectAreaLight",this.width=n,this.height=s}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}LL.prototype.isRectAreaLight=!0;class I2{constructor(){this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new L)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const n=e.x,s=e.y,i=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.282095),t.addScaledVector(a[1],.488603*s),t.addScaledVector(a[2],.488603*i),t.addScaledVector(a[3],.488603*n),t.addScaledVector(a[4],1.092548*(n*s)),t.addScaledVector(a[5],1.092548*(s*i)),t.addScaledVector(a[6],.315392*(3*i*i-1)),t.addScaledVector(a[7],1.092548*(n*i)),t.addScaledVector(a[8],.546274*(n*n-s*s)),t}getIrradianceAt(e,t){const n=e.x,s=e.y,i=e.z,a=this.coefficients;return t.copy(a[0]).multiplyScalar(.886227),t.addScaledVector(a[1],2*.511664*s),t.addScaledVector(a[2],2*.511664*i),t.addScaledVector(a[3],2*.511664*n),t.addScaledVector(a[4],2*.429043*n*s),t.addScaledVector(a[5],2*.429043*s*i),t.addScaledVector(a[6],.743125*i*i-.247708),t.addScaledVector(a[7],2*.429043*n*i),t.addScaledVector(a[8],.429043*(n*n-s*s)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let n=0;n<9;n++)this.coefficients[n].addScaledVector(e.coefficients[n],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let n=0;n<9;n++)this.coefficients[n].lerp(e.coefficients[n],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const n=this.coefficients;for(let s=0;s<9;s++)n[s].fromArray(e,t+s*3);return this}toArray(e=[],t=0){const n=this.coefficients;for(let s=0;s<9;s++)n[s].toArray(e,t+s*3);return e}static getBasisAt(e,t){const n=e.x,s=e.y,i=e.z;t[0]=.282095,t[1]=.488603*s,t[2]=.488603*i,t[3]=.488603*n,t[4]=1.092548*n*s,t[5]=1.092548*s*i,t[6]=.315392*(3*i*i-1),t[7]=1.092548*n*i,t[8]=.546274*(n*n-s*s)}}I2.prototype.isSphericalHarmonics3=!0;class ad extends Jn{constructor(e=new I2,t=1){super(void 0,t);this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}ad.prototype.isLightProbe=!0;class Yr{static decodeText(e){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(e);let t="";for(let n=0,s=e.length;n<s;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.substr(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class kL extends yt{constructor(){super();this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const e=super.toJSON(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}kL.prototype.isInstancedBufferGeometry=!0;class N2 extends fr{constructor(e){super(e);typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,n,s){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const i=this,a=Yi.get(e);if(a!==void 0)return i.manager.itemStart(e),setTimeout(function(){t&&t(a),i.manager.itemEnd(e)},0),a;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader,fetch(e,o).then(function(c){return c.blob()}).then(function(c){return createImageBitmap(c,Object.assign(i.options,{colorSpaceConversion:"none"}))}).then(function(c){Yi.add(e,c),t&&t(c),i.manager.itemEnd(e)}).catch(function(c){s&&s(c),i.manager.itemError(e),i.manager.itemEnd(e)}),i.manager.itemStart(e)}}N2.prototype.isImageBitmapLoader=!0;let Mc;const DL={getContext:function(){return Mc===void 0&&(Mc=new(window.AudioContext||window.webkitAudioContext)),Mc},setContext:function(r){Mc=r}};class PL extends fr{constructor(e){super(e)}load(e,t,n,s){const i=this,a=new td(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(o){try{const c=o.slice(0);DL.getContext().decodeAudioData(c,function(u){t(u)})}catch(c){s?s(c):console.error(c),i.manager.itemError(e)}},n,s)}}class FL extends ad{constructor(e,t,n=1){super(void 0,n);const s=new Le().set(e),i=new Le().set(t),a=new L(s.r,s.g,s.b),o=new L(i.r,i.g,i.b),c=Math.sqrt(Math.PI),l=c*Math.sqrt(.75);this.sh.coefficients[0].copy(a).add(o).multiplyScalar(c),this.sh.coefficients[1].copy(a).sub(o).multiplyScalar(l)}}FL.prototype.isHemisphereLightProbe=!0;class OL extends ad{constructor(e,t=1){super(void 0,t);const n=new Le().set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}}OL.prototype.isAmbientLightProbe=!0;class BL extends it{constructor(e){super();this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}class zL{constructor(e,t,n){this.binding=e,this.valueSize=n;let s,i,a;switch(t){case"quaternion":s=this._slerp,i=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":s=this._select,i=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:s=this._lerp,i=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=s,this._mixBufferRegionAdditive=i,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const n=this.buffer,s=this.valueSize,i=e*s+s;let a=this.cumulativeWeight;if(a===0){for(let o=0;o!==s;++o)n[i+o]=n[o];a=t}else{a+=t;const o=t/a;this._mixBufferRegion(n,i,0,o,s)}this.cumulativeWeight=a}accumulateAdditive(e){const t=this.buffer,n=this.valueSize,s=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,s,0,e,n),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,n=this.buffer,s=e*t+t,i=this.cumulativeWeight,a=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,i<1){const c=t*this._origIndex;this._mixBufferRegion(n,s,c,1-i,t)}a>0&&this._mixBufferRegionAdditive(n,s,this._addIndex*t,1,t);for(let c=t,l=t+t;c!==l;++c)if(n[c]!==n[c+t]){o.setValue(n,s);break}}saveOriginalState(){const e=this.binding,t=this.buffer,n=this.valueSize,s=n*this._origIndex;e.getValue(t,s);for(let i=n,a=s;i!==a;++i)t[i]=t[s+i%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]}_select(e,t,n,s,i){if(s>=.5)for(let a=0;a!==i;++a)e[t+a]=e[n+a]}_slerp(e,t,n,s){hn.slerpFlat(e,t,e,t,e,n,s)}_slerpAdditive(e,t,n,s,i){const a=this._workIndex*i;hn.multiplyQuaternionsFlat(e,a,e,t,e,n),hn.slerpFlat(e,t,e,t,e,a,s)}_lerp(e,t,n,s,i){const a=1-s;for(let o=0;o!==i;++o){const c=t+o;e[c]=e[c]*a+e[n+o]*s}}_lerpAdditive(e,t,n,s,i){for(let a=0;a!==i;++a){const o=t+a;e[o]=e[o]+e[n+a]*s}}}const od="\\[\\]\\.:\\/",UL=new RegExp("["+od+"]","g"),cd="[^"+od+"]",VL="[^"+od.replace("\\.","")+"]",HL=/((?:WC+[\/:])*)/.source.replace("WC",cd),$L=/(WCOD+)?/.source.replace("WCOD",VL),GL=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",cd),WL=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",cd),jL=new RegExp("^"+HL+$L+GL+WL+"$"),qL=["material","materials","bones"];class KL{constructor(e,t,n){const s=n||ht.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,s)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,s=this._bindings[n];s!==void 0&&s.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let s=this._targetGroup.nCachedObjects_,i=n.length;s!==i;++s)n[s].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}class ht{constructor(e,t,n){this.path=t,this.parsedPath=n||ht.parseTrackName(t),this.node=ht.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new ht.Composite(e,t,n):new ht(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(UL,"")}static parseTrackName(e){const t=jL.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},s=n.nodeName&&n.nodeName.lastIndexOf(".");if(s!==void 0&&s!==-1){const i=n.nodeName.substring(s+1);qL.indexOf(i)!==-1&&(n.nodeName=n.nodeName.substring(0,s),n.objectName=i)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(!t||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(n!==void 0)return n}if(e.children){const n=function(i){for(let a=0;a<i.length;a++){const o=i[a];if(o.name===t||o.uuid===t)return o;const c=n(o.children);if(c)return c}return null},s=n(e.children);if(s)return s}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let s=0,i=n.length;s!==i;++s)e[t++]=n[s]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let s=0,i=n.length;s!==i;++s)n[s]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let s=0,i=n.length;s!==i;++s)n[s]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let s=0,i=n.length;s!==i;++s)n[s]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,s=t.propertyName;let i=t.propertyIndex;if(e||(e=ht.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(n){let l=t.objectIndex;switch(n){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let u=0;u<e.length;u++)if(e[u].name===l){l=u;break}break;default:if(e[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[n]}if(l!==void 0){if(e[l]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[l]}}const a=e[s];if(a===void 0){const l=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+l+"."+s+" but it wasn't found.",e);return}let o=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let c=this.BindingType.Direct;if(i!==void 0){if(s==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(e.geometry.isBufferGeometry){if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[i]!==void 0&&(i=e.morphTargetDictionary[i])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}c=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=i}else a.fromArray!==void 0&&a.toArray!==void 0?(c=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(c=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=s;this.getValue=this.GetterByBindingType[c],this.setValue=this.SetterByBindingTypeAndVersioning[c][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}ht.Composite=KL;ht.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};ht.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};ht.prototype.GetterByBindingType=[ht.prototype._getValue_direct,ht.prototype._getValue_array,ht.prototype._getValue_arrayElement,ht.prototype._getValue_toArray];ht.prototype.SetterByBindingTypeAndVersioning=[[ht.prototype._setValue_direct,ht.prototype._setValue_direct_setNeedsUpdate,ht.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[ht.prototype._setValue_array,ht.prototype._setValue_array_setNeedsUpdate,ht.prototype._setValue_array_setMatrixWorldNeedsUpdate],[ht.prototype._setValue_arrayElement,ht.prototype._setValue_arrayElement_setNeedsUpdate,ht.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[ht.prototype._setValue_fromArray,ht.prototype._setValue_fromArray_setNeedsUpdate,ht.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class XL{constructor(e,t,n=null,s=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=n,this.blendMode=s;const i=t.tracks,a=i.length,o=new Array(a),c={endingStart:mi,endingEnd:mi};for(let l=0;l!==a;++l){const u=i[l].createInterpolant(null);o[l]=u,u.settings=c}this._interpolantSettings=c,this._interpolants=o,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=CM,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,n){if(e.fadeOut(t),this.fadeIn(t),n){const s=this._clip.duration,i=e._clip.duration,a=i/s,o=s/i;e.warp(1,a,t),this.warp(o,1,t)}return this}crossFadeTo(e,t,n){return e.crossFadeFrom(this,t,n)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,n){const s=this._mixer,i=s.time,a=this.timeScale;let o=this._timeScaleInterpolant;o===null&&(o=s._lendControlInterpolant(),this._timeScaleInterpolant=o);const c=o.parameterPositions,l=o.sampleValues;return c[0]=i,c[1]=i+n,l[0]=e/a,l[1]=t/a,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,n,s){if(!this.enabled){this._updateWeight(e);return}const i=this._startTime;if(i!==null){const c=(e-i)*n;if(c<0||n===0)return;this._startTime=null,t=n*c}t*=this._updateTimeScale(e);const a=this._updateTime(t),o=this._updateWeight(e);if(o>0){const c=this._interpolants,l=this._propertyBindings;switch(this.blendMode){case M1:for(let u=0,h=c.length;u!==h;++u)c[u].evaluate(a),l[u].accumulateAdditive(o);break;case Kl:default:for(let u=0,h=c.length;u!==h;++u)c[u].evaluate(a),l[u].accumulate(s,o)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const n=this._weightInterpolant;if(n!==null){const s=n.evaluate(e)[0];t*=s,e>n.parameterPositions[1]&&(this.stopFading(),s===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const n=this._timeScaleInterpolant;n!==null&&(t*=n.evaluate(e)[0],e>n.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t))}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,n=this.loop;let s=this.time+e,i=this._loopCount;const a=n===LM;if(e===0)return i===-1?s:a&&(i&1)==1?t-s:s;if(n===RM){i===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(s>=t)s=t;else if(s<0)s=0;else{this.time=s;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(i===-1&&(e>=0?(i=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),s>=t||s<0){const o=Math.floor(s/t);s-=t*o,i+=Math.abs(o);const c=this.repetitions-i;if(c<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,s=e>0?t:0,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(c===1){const l=e<0;this._setEndings(l,!l,a)}else this._setEndings(!1,!1,a);this._loopCount=i,this.time=s,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}else this.time=s;if(a&&(i&1)==1)return t-s}return s}_setEndings(e,t,n){const s=this._interpolantSettings;n?(s.endingStart=gi,s.endingEnd=gi):(e?s.endingStart=this.zeroSlopeAtStart?gi:mi:s.endingStart=Oo,t?s.endingEnd=this.zeroSlopeAtEnd?gi:mi:s.endingEnd=Oo)}_scheduleFading(e,t,n){const s=this._mixer,i=s.time;let a=this._weightInterpolant;a===null&&(a=s._lendControlInterpolant(),this._weightInterpolant=a);const o=a.parameterPositions,c=a.sampleValues;return o[0]=i,c[0]=t,o[1]=i+e,c[1]=n,this}}class YL extends vs{constructor(e){super();this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const n=e._localRoot||this._root,s=e._clip.tracks,i=s.length,a=e._propertyBindings,o=e._interpolants,c=n.uuid,l=this._bindingsByRootAndName;let u=l[c];u===void 0&&(u={},l[c]=u);for(let h=0;h!==i;++h){const d=s[h],p=d.name;let f=u[p];if(f!==void 0)a[h]=f;else{if(f=a[h],f!==void 0){f._cacheIndex===null&&(++f.referenceCount,this._addInactiveBinding(f,c,p));continue}const m=t&&t._propertyBindings[h].binding.parsedPath;f=new zL(ht.create(n,p,m),d.ValueTypeName,d.getValueSize()),++f.referenceCount,this._addInactiveBinding(f,c,p),a[h]=f}o[h].resultBuffer=f.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const n=(e._localRoot||this._root).uuid,s=e._clip.uuid,i=this._actionsByClip[s];this._bindAction(e,i&&i.knownActions[0]),this._addInactiveAction(e,s,n)}const t=e._propertyBindings;for(let n=0,s=t.length;n!==s;++n){const i=t[n];i.useCount++==0&&(this._lendBinding(i),i.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let n=0,s=t.length;n!==s;++n){const i=t[n];--i.useCount==0&&(i.restoreOriginalState(),this._takeBackBinding(i))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,n){const s=this._actions,i=this._actionsByClip;let a=i[t];if(a===void 0)a={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,i[t]=a;else{const o=a.knownActions;e._byClipCacheIndex=o.length,o.push(e)}e._cacheIndex=s.length,s.push(e),a.actionByRoot[n]=e}_removeInactiveAction(e){const t=this._actions,n=t[t.length-1],s=e._cacheIndex;n._cacheIndex=s,t[s]=n,t.pop(),e._cacheIndex=null;const i=e._clip.uuid,a=this._actionsByClip,o=a[i],c=o.knownActions,l=c[c.length-1],u=e._byClipCacheIndex;l._byClipCacheIndex=u,c[u]=l,c.pop(),e._byClipCacheIndex=null;const h=o.actionByRoot,d=(e._localRoot||this._root).uuid;delete h[d],c.length===0&&delete a[i],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let n=0,s=t.length;n!==s;++n){const i=t[n];--i.referenceCount==0&&this._removeInactiveBinding(i)}}_lendAction(e){const t=this._actions,n=e._cacheIndex,s=this._nActiveActions++,i=t[s];e._cacheIndex=s,t[s]=e,i._cacheIndex=n,t[n]=i}_takeBackAction(e){const t=this._actions,n=e._cacheIndex,s=--this._nActiveActions,i=t[s];e._cacheIndex=s,t[s]=e,i._cacheIndex=n,t[n]=i}_addInactiveBinding(e,t,n){const s=this._bindingsByRootAndName,i=this._bindings;let a=s[t];a===void 0&&(a={},s[t]=a),a[n]=e,e._cacheIndex=i.length,i.push(e)}_removeInactiveBinding(e){const t=this._bindings,n=e.binding,s=n.rootNode.uuid,i=n.path,a=this._bindingsByRootAndName,o=a[s],c=t[t.length-1],l=e._cacheIndex;c._cacheIndex=l,t[l]=c,t.pop(),delete o[i],Object.keys(o).length===0&&delete a[s]}_lendBinding(e){const t=this._bindings,n=e._cacheIndex,s=this._nActiveBindings++,i=t[s];e._cacheIndex=s,t[s]=e,i._cacheIndex=n,t[n]=i}_takeBackBinding(e){const t=this._bindings,n=e._cacheIndex,s=--this._nActiveBindings,i=t[s];e._cacheIndex=s,t[s]=e,i._cacheIndex=n,t[n]=i}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return n===void 0&&(n=new m2(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=t,e[t]=n),n}_takeBackControlInterpolant(e){const t=this._controlInterpolants,n=e.__cacheIndex,s=--this._nActiveControlInterpolants,i=t[s];e.__cacheIndex=s,t[s]=e,i.__cacheIndex=n,t[n]=i}clipAction(e,t,n){const s=t||this._root,i=s.uuid;let a=typeof e=="string"?ed.findByName(s,e):e;const o=a!==null?a.uuid:e,c=this._actionsByClip[o];let l=null;if(n===void 0&&(a!==null?n=a.blendMode:n=Kl),c!==void 0){const h=c.actionByRoot[i];if(h!==void 0&&h.blendMode===n)return h;l=c.knownActions[0],a===null&&(a=l._clip)}if(a===null)return null;const u=new XL(this,a,t,n);return this._bindAction(u,l),this._addInactiveAction(u,o,i),u}existingAction(e,t){const n=t||this._root,s=n.uuid,i=typeof e=="string"?ed.findByName(n,e):e,a=i?i.uuid:e,o=this._actionsByClip[a];return o!==void 0&&o.actionByRoot[s]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let n=t-1;n>=0;--n)e[n].stop();return this}update(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,s=this.time+=e,i=Math.sign(e),a=this._accuIndex^=1;for(let l=0;l!==n;++l)t[l]._update(s,e,i,a);const o=this._bindings,c=this._nActiveBindings;for(let l=0;l!==c;++l)o[l].apply(a);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,n=e.uuid,s=this._actionsByClip,i=s[n];if(i!==void 0){const a=i.knownActions;for(let o=0,c=a.length;o!==c;++o){const l=a[o];this._deactivateAction(l);const u=l._cacheIndex,h=t[t.length-1];l._cacheIndex=null,l._byClipCacheIndex=null,h._cacheIndex=u,t[u]=h,t.pop(),this._removeInactiveBindingsForAction(l)}delete s[n]}}uncacheRoot(e){const t=e.uuid,n=this._actionsByClip;for(const a in n){const o=n[a].actionByRoot,c=o[t];c!==void 0&&(this._deactivateAction(c),this._removeInactiveAction(c))}const s=this._bindingsByRootAndName,i=s[t];if(i!==void 0)for(const a in i){const o=i[a];o.restoreOriginalState(),this._removeInactiveBinding(o)}}uncacheAction(e,t){const n=this.existingAction(e,t);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}}YL.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class JL extends zi{constructor(e,t,n=1){super(e,t);this.meshPerAttribute=n}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}JL.prototype.isInstancedInterleavedBuffer=!0;const Jr=new L,Ac=new Be,ud=new Be;class ZL extends yc{constructor(e){const t=R2(e),n=new yt,s=[],i=[],a=new Le(0,0,1),o=new Le(0,1,0);for(let l=0;l<t.length;l++){const u=t[l];u.parent&&u.parent.isBone&&(s.push(0,0,0),s.push(0,0,0),i.push(a.r,a.g,a.b),i.push(o.r,o.g,o.b))}n.setAttribute("position",new Nt(s,3)),n.setAttribute("color",new Nt(i,3));const c=new Wi({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(n,c);this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,n=this.geometry,s=n.getAttribute("position");ud.copy(this.root.matrixWorld).invert();for(let i=0,a=0;i<t.length;i++){const o=t[i];o.parent&&o.parent.isBone&&(Ac.multiplyMatrices(ud,o.matrixWorld),Jr.setFromMatrixPosition(Ac),s.setXYZ(a,Jr.x,Jr.y,Jr.z),Ac.multiplyMatrices(ud,o.parent.matrixWorld),Jr.setFromMatrixPosition(Ac),s.setXYZ(a+1,Jr.x,Jr.y,Jr.z),a+=2)}n.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function R2(r){const e=[];r&&r.isBone&&e.push(r);for(let t=0;t<r.children.length;t++)e.push.apply(e,R2(r.children[t]));return e}class QL extends yc{constructor(e=10,t=10,n=4473924,s=8947848){n=new Le(n),s=new Le(s);const i=t/2,a=e/t,o=e/2,c=[],l=[];for(let d=0,p=0,f=-o;d<=t;d++,f+=a){c.push(-o,0,f,o,0,f),c.push(f,0,-o,f,0,o);const m=d===i?n:s;m.toArray(l,p),p+=3,m.toArray(l,p),p+=3,m.toArray(l,p),p+=3,m.toArray(l,p),p+=3}const u=new yt;u.setAttribute("position",new Nt(c,3)),u.setAttribute("color",new Nt(l,3));const h=new Wi({vertexColors:!0,toneMapped:!1});super(u,h);this.type="GridHelper"}}const ek=new Float32Array(1);new Int32Array(ek.buffer);kn.create=function(r,e){return console.log("THREE.Curve.create() has been deprecated"),r.prototype=Object.create(kn.prototype),r.prototype.constructor=r,r.prototype.getPoint=e,r};Yh.prototype.fromPoints=function(r){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(r)};QL.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};ZL.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};fr.prototype.extractUrlBase=function(r){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),Yr.extractUrlBase(r)};fr.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};Cn.prototype.center=function(r){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(r)};Cn.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};Cn.prototype.isIntersectionBox=function(r){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(r)};Cn.prototype.isIntersectionSphere=function(r){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(r)};Cn.prototype.size=function(r){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(r)};Ts.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};ic.prototype.setFromMatrix=function(r){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(r)};Qt.prototype.flattenToArrayOffset=function(r,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(r,e)};Qt.prototype.multiplyVector3=function(r){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),r.applyMatrix3(this)};Qt.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};Qt.prototype.applyToBufferAttribute=function(r){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),r.applyMatrix3(this)};Qt.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};Qt.prototype.getInverse=function(r){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(r).invert()};Be.prototype.extractPosition=function(r){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(r)};Be.prototype.flattenToArrayOffset=function(r,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(r,e)};Be.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new L().setFromMatrixColumn(this,3)};Be.prototype.setRotationFromQuaternion=function(r){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(r)};Be.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};Be.prototype.multiplyVector3=function(r){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),r.applyMatrix4(this)};Be.prototype.multiplyVector4=function(r){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),r.applyMatrix4(this)};Be.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};Be.prototype.rotateAxis=function(r){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),r.transformDirection(this)};Be.prototype.crossVector=function(r){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),r.applyMatrix4(this)};Be.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};Be.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};Be.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};Be.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};Be.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};Be.prototype.applyToBufferAttribute=function(r){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),r.applyMatrix4(this)};Be.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};Be.prototype.makeFrustum=function(r,e,t,n,s,i){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(r,e,n,t,s,i)};Be.prototype.getInverse=function(r){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(r).invert()};dr.prototype.isIntersectionLine=function(r){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(r)};hn.prototype.multiplyVector3=function(r){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),r.applyQuaternion(this)};hn.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};wi.prototype.isIntersectionBox=function(r){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(r)};wi.prototype.isIntersectionPlane=function(r){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(r)};wi.prototype.isIntersectionSphere=function(r){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(r)};Dt.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};Dt.prototype.barycoordFromPoint=function(r,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(r,e)};Dt.prototype.midpoint=function(r){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(r)};Dt.prototypenormal=function(r){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(r)};Dt.prototype.plane=function(r){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(r)};Dt.barycoordFromPoint=function(r,e,t,n,s){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),Dt.getBarycoord(r,e,t,n,s)};Dt.normal=function(r,e,t,n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),Dt.getNormal(r,e,t,n)};Ga.prototype.extractAllPoints=function(r){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(r)};Ga.prototype.extrude=function(r){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new qi(this,r)};Ga.prototype.makeGeometry=function(r){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new Qh(this,r)};fe.prototype.fromAttribute=function(r,e,t){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(r,e,t)};fe.prototype.distanceToManhattan=function(r){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(r)};fe.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};L.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};L.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};L.prototype.getPositionFromMatrix=function(r){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(r)};L.prototype.getScaleFromMatrix=function(r){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(r)};L.prototype.getColumnFromMatrix=function(r,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,r)};L.prototype.applyProjection=function(r){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(r)};L.prototype.fromAttribute=function(r,e,t){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(r,e,t)};L.prototype.distanceToManhattan=function(r){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(r)};L.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};pt.prototype.fromAttribute=function(r,e,t){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(r,e,t)};pt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};it.prototype.getChildByName=function(r){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(r)};it.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};it.prototype.translate=function(r,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,r)};it.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};it.prototype.applyMatrix=function(r){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(r)};Object.defineProperties(it.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(r){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=r}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});$t.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties($t.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),kM},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});Fh.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};dn.prototype.setLens=function(r,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),e!==void 0&&(this.filmGauge=e),this.setFocalLength(r)};Object.defineProperties(Jn.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(r){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=r}},shadowCameraLeft:{set:function(r){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=r}},shadowCameraRight:{set:function(r){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=r}},shadowCameraTop:{set:function(r){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=r}},shadowCameraBottom:{set:function(r){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=r}},shadowCameraNear:{set:function(r){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=r}},shadowCameraFar:{set:function(r){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=r}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(r){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=r}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(r){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=r}},shadowMapHeight:{set:function(r){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=r}}});Object.defineProperties(It.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Bo},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Bo)}}});It.prototype.setDynamic=function(r){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(r===!0?Bo:Ma),this};It.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},It.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};yt.prototype.addIndex=function(r){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(r)};yt.prototype.addAttribute=function(r,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(e&&e.isBufferAttribute)&&!(e&&e.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(r,new It(arguments[1],arguments[2]))):r==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(r,e)};yt.prototype.addDrawCall=function(r,e,t){t!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(r,e)};yt.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};yt.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};yt.prototype.removeAttribute=function(r){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(r)};yt.prototype.applyMatrix=function(r){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(r)};Object.defineProperties(yt.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});zi.prototype.setDynamic=function(r){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(r===!0?Bo:Ma),this};zi.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};qi.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};qi.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};qi.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};lc.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Object.defineProperties(Ht.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Le}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(r){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=r===a1}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(r){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=r}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}});Object.defineProperties(Es.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(r){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=r}}});dt.prototype.clearTarget=function(r,e,t,n){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(r),this.clear(e,t,n)};dt.prototype.animate=function(r){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(r)};dt.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};dt.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};dt.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};dt.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};dt.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};dt.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};dt.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};dt.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};dt.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};dt.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};dt.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};dt.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};dt.prototype.enableScissorTest=function(r){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(r)};dt.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};dt.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};dt.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};dt.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};dt.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};dt.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};dt.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};dt.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};dt.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};dt.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(dt.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(r){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=r}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(r){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=r}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(r){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=r===!0?Or:yn}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(kg.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(Rn.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(r){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=r}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(r){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=r}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(r){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=r}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(r){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=r}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(r){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=r}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(r){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=r}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(r){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=r}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(r){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=r}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(r){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=r}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(r){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=r}}});BL.prototype.load=function(r){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return new PL().load(r,function(n){e.setBuffer(n)}),this};Th.prototype.updateCubeMap=function(r,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(r,e)};Th.prototype.clear=function(r,e,t,n){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(r,e,t,n)};_i.crossOrigin=void 0;_i.loadTexture=function(r,e,t,n){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const s=new nd;s.setCrossOrigin(this.crossOrigin);const i=s.load(r,t,void 0,n);return e&&(i.mapping=e),i};_i.loadTextureCube=function(r,e,t,n){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const s=new RL;s.setCrossOrigin(this.crossOrigin);const i=s.load(r,t,void 0,n);return e&&(i.mapping=e),i};_i.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};_i.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Ul}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Ul);class tk extends fr{constructor(e){super(e);this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new ik(t)}),this.register(function(t){return new hk(t)}),this.register(function(t){return new dk(t)}),this.register(function(t){return new ak(t)}),this.register(function(t){return new ok(t)}),this.register(function(t){return new ck(t)}),this.register(function(t){return new uk(t)}),this.register(function(t){return new lk(t)}),this.register(function(t){return new rk(t)}),this.register(function(t){return new pk(t)})}load(e,t,n,s){const i=this;let a;this.resourcePath!==""?a=this.resourcePath:this.path!==""?a=this.path:a=Yr.extractUrlBase(e),this.manager.itemStart(e);const o=function(l){s?s(l):console.error(l),i.manager.itemError(e),i.manager.itemEnd(e)},c=new td(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(e,function(l){try{i.parse(l,a,function(u){t(u),i.manager.itemEnd(e)},o)}catch(u){o(u)}},n,o)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,s){let i;const a={},o={};if(typeof e=="string")i=e;else if(Yr.decodeText(new Uint8Array(e,0,4))===C2){try{a[st.KHR_BINARY_GLTF]=new fk(e)}catch(h){s&&s(h);return}i=a[st.KHR_BINARY_GLTF].content}else i=Yr.decodeText(new Uint8Array(e));const c=JSON.parse(i);if(c.asset===void 0||c.asset.version[0]<2){s&&s(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const l=new Mk(c,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let u=0;u<this.pluginCallbacks.length;u++){const h=this.pluginCallbacks[u](l);o[h.name]=h,a[h.name]=!0}if(c.extensionsUsed)for(let u=0;u<c.extensionsUsed.length;++u){const h=c.extensionsUsed[u],d=c.extensionsRequired||[];switch(h){case st.KHR_MATERIALS_UNLIT:a[h]=new sk;break;case st.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:a[h]=new yk;break;case st.KHR_DRACO_MESH_COMPRESSION:a[h]=new mk(c,this.dracoLoader);break;case st.KHR_TEXTURE_TRANSFORM:a[h]=new gk;break;case st.KHR_MESH_QUANTIZATION:a[h]=new _k;break;default:d.indexOf(h)>=0&&o[h]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+h+'".')}}l.setExtensions(a),l.setPlugins(o),l.parse(n,s)}parseAsync(e,t){const n=this;return new Promise(function(s,i){n.parse(e,t,s,i)})}}function nk(){let r={};return{get:function(e){return r[e]},add:function(e,t){r[e]=t},remove:function(e){delete r[e]},removeAll:function(){r={}}}}const st={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class rk{constructor(e){this.parser=e,this.name=st.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,s=t.length;n<s;n++){const i=t[n];i.extensions&&i.extensions[this.name]&&i.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(e){const t=this.parser,n="light:"+e;let s=t.cache.get(n);if(s)return s;const i=t.json,c=((i.extensions&&i.extensions[this.name]||{}).lights||[])[e];let l;const u=new Le(16777215);c.color!==void 0&&u.fromArray(c.color);const h=c.range!==void 0?c.range:0;switch(c.type){case"directional":l=new id(u),l.target.position.set(0,0,-1),l.add(l.target);break;case"point":l=new M2(u),l.distance=h;break;case"spot":l=new S2(u),l.distance=h,c.spot=c.spot||{},c.spot.innerConeAngle=c.spot.innerConeAngle!==void 0?c.spot.innerConeAngle:0,c.spot.outerConeAngle=c.spot.outerConeAngle!==void 0?c.spot.outerConeAngle:Math.PI/4,l.angle=c.spot.outerConeAngle,l.penumbra=1-c.spot.innerConeAngle/c.spot.outerConeAngle,l.target.position.set(0,0,-1),l.add(l.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+c.type)}return l.position.set(0,0,0),l.decay=2,c.intensity!==void 0&&(l.intensity=c.intensity),l.name=t.createUniqueName(c.name||"light_"+e),s=Promise.resolve(l),t.cache.add(n,s),s}createNodeAttachment(e){const t=this,n=this.parser,i=n.json.nodes[e],o=(i.extensions&&i.extensions[this.name]||{}).light;return o===void 0?null:this._loadLight(o).then(function(c){return n._getNodeRef(t.cache,o,c)})}}class sk{constructor(){this.name=st.KHR_MATERIALS_UNLIT}getMaterialType(){return qn}extendParams(e,t,n){const s=[];e.color=new Le(1,1,1),e.opacity=1;const i=t.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const a=i.baseColorFactor;e.color.fromArray(a),e.opacity=a[3]}i.baseColorTexture!==void 0&&s.push(n.assignTexture(e,"map",i.baseColorTexture))}return Promise.all(s)}}class ik{constructor(e){this.parser=e,this.name=st.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Rs}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],a=s.extensions[this.name];if(a.clearcoatFactor!==void 0&&(t.clearcoat=a.clearcoatFactor),a.clearcoatTexture!==void 0&&i.push(n.assignTexture(t,"clearcoatMap",a.clearcoatTexture)),a.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=a.clearcoatRoughnessFactor),a.clearcoatRoughnessTexture!==void 0&&i.push(n.assignTexture(t,"clearcoatRoughnessMap",a.clearcoatRoughnessTexture)),a.clearcoatNormalTexture!==void 0&&(i.push(n.assignTexture(t,"clearcoatNormalMap",a.clearcoatNormalTexture)),a.clearcoatNormalTexture.scale!==void 0)){const o=a.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new fe(o,o)}return Promise.all(i)}}class ak{constructor(e){this.parser=e,this.name=st.KHR_MATERIALS_SHEEN}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Rs}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[];t.sheenColor=new Le(0,0,0),t.sheenRoughness=0,t.sheen=1;const a=s.extensions[this.name];return a.sheenColorFactor!==void 0&&t.sheenColor.fromArray(a.sheenColorFactor),a.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=a.sheenRoughnessFactor),a.sheenColorTexture!==void 0&&i.push(n.assignTexture(t,"sheenColorMap",a.sheenColorTexture)),a.sheenRoughnessTexture!==void 0&&i.push(n.assignTexture(t,"sheenRoughnessMap",a.sheenRoughnessTexture)),Promise.all(i)}}class ok{constructor(e){this.parser=e,this.name=st.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Rs}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],a=s.extensions[this.name];return a.transmissionFactor!==void 0&&(t.transmission=a.transmissionFactor),a.transmissionTexture!==void 0&&i.push(n.assignTexture(t,"transmissionMap",a.transmissionTexture)),Promise.all(i)}}class ck{constructor(e){this.parser=e,this.name=st.KHR_MATERIALS_VOLUME}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Rs}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],a=s.extensions[this.name];t.thickness=a.thicknessFactor!==void 0?a.thicknessFactor:0,a.thicknessTexture!==void 0&&i.push(n.assignTexture(t,"thicknessMap",a.thicknessTexture)),t.attenuationDistance=a.attenuationDistance||0;const o=a.attenuationColor||[1,1,1];return t.attenuationColor=new Le(o[0],o[1],o[2]),Promise.all(i)}}class uk{constructor(e){this.parser=e,this.name=st.KHR_MATERIALS_IOR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Rs}extendMaterialParams(e,t){const s=this.parser.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=s.extensions[this.name];return t.ior=i.ior!==void 0?i.ior:1.5,Promise.resolve()}}class lk{constructor(e){this.parser=e,this.name=st.KHR_MATERIALS_SPECULAR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:Rs}extendMaterialParams(e,t){const n=this.parser,s=n.json.materials[e];if(!s.extensions||!s.extensions[this.name])return Promise.resolve();const i=[],a=s.extensions[this.name];t.specularIntensity=a.specularFactor!==void 0?a.specularFactor:1,a.specularTexture!==void 0&&i.push(n.assignTexture(t,"specularIntensityMap",a.specularTexture));const o=a.specularColorFactor||[1,1,1];return t.specularColor=new Le(o[0],o[1],o[2]),a.specularColorTexture!==void 0&&i.push(n.assignTexture(t,"specularColorMap",a.specularColorTexture).then(function(c){c.encoding=Or})),Promise.all(i)}}class hk{constructor(e){this.parser=e,this.name=st.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,n=t.json,s=n.textures[e];if(!s.extensions||!s.extensions[this.name])return null;const i=s.extensions[this.name],a=n.images[i.source],o=t.options.ktx2Loader;if(!o){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,a,o)}}class dk{constructor(e){this.parser=e,this.name=st.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,s=n.json,i=s.textures[e];if(!i.extensions||!i.extensions[t])return null;const a=i.extensions[t],o=s.images[a.source];let c=n.textureLoader;if(o.uri){const l=n.options.manager.getHandler(o.uri);l!==null&&(c=l)}return this.detectSupport().then(function(l){if(l)return n.loadTextureImage(e,o,c);if(s.extensionsRequired&&s.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class pk{constructor(e){this.name=st.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,n=t.bufferViews[e];if(n.extensions&&n.extensions[this.name]){const s=n.extensions[this.name],i=this.parser.getDependency("buffer",s.buffer),a=this.parser.options.meshoptDecoder;if(!a||!a.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([i,a.ready]).then(function(o){const c=s.byteOffset||0,l=s.byteLength||0,u=s.count,h=s.byteStride,d=new ArrayBuffer(u*h),p=new Uint8Array(o[0],c,l);return a.decodeGltfBuffer(new Uint8Array(d),u,h,p,s.mode,s.filter),d})}else return null}}const C2="glTF",Ja=12,L2={JSON:1313821514,BIN:5130562};class fk{constructor(e){this.name=st.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,Ja);if(this.header={magic:Yr.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==C2)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-Ja,s=new DataView(e,Ja);let i=0;for(;i<n;){const a=s.getUint32(i,!0);i+=4;const o=s.getUint32(i,!0);if(i+=4,o===L2.JSON){const c=new Uint8Array(e,Ja+i,a);this.content=Yr.decodeText(c)}else if(o===L2.BIN){const c=Ja+i;this.body=e.slice(c,c+a)}i+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class mk{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=st.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const n=this.json,s=this.dracoLoader,i=e.extensions[this.name].bufferView,a=e.extensions[this.name].attributes,o={},c={},l={};for(const u in a){const h=hd[u]||u.toLowerCase();o[h]=a[u]}for(const u in e.attributes){const h=hd[u]||u.toLowerCase();if(a[u]!==void 0){const d=n.accessors[e.attributes[u]],p=Za[d.componentType];l[h]=p,c[h]=d.normalized===!0}}return t.getDependency("bufferView",i).then(function(u){return new Promise(function(h){s.decodeDracoFile(u,function(d){for(const p in d.attributes){const f=d.attributes[p],m=c[p];m!==void 0&&(f.normalized=m)}h(d)},o,l)})})}}class gk{constructor(){this.name=st.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return t.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class ld extends Ns{constructor(e){super();this.isGLTFSpecularGlossinessMaterial=!0;const t=["#ifdef USE_SPECULARMAP","	uniform sampler2D specularMap;","#endif"].join(`
`),n=["#ifdef USE_GLOSSINESSMAP","	uniform sampler2D glossinessMap;","#endif"].join(`
`),s=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","	vec4 texelSpecular = texture2D( specularMap, vUv );","	texelSpecular = sRGBToLinear( texelSpecular );","	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","	specularFactor *= texelSpecular.rgb;","#endif"].join(`
`),i=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","	vec4 texelGlossiness = texture2D( glossinessMap, vUv );","	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","	glossinessFactor *= texelGlossiness.a;","#endif"].join(`
`),a=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join(`
`),o={specular:{value:new Le().setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=o,this.onBeforeCompile=function(c){for(const l in o)c.uniforms[l]=o[l];c.fragmentShader=c.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",t).replace("#include <metalnessmap_pars_fragment>",n).replace("#include <roughnessmap_fragment>",s).replace("#include <metalnessmap_fragment>",i).replace("#include <lights_physical_fragment>",a)},Object.defineProperties(this,{specular:{get:function(){return o.specular.value},set:function(c){o.specular.value=c}},specularMap:{get:function(){return o.specularMap.value},set:function(c){o.specularMap.value=c,c?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return o.glossiness.value},set:function(c){o.glossiness.value=c}},glossinessMap:{get:function(){return o.glossinessMap.value},set:function(c){o.glossinessMap.value=c,c?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(e)}copy(e){return super.copy(e),this.specularMap=e.specularMap,this.specular.copy(e.specular),this.glossinessMap=e.glossinessMap,this.glossiness=e.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class yk{constructor(){this.name=st.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity","refractionRatio"]}getMaterialType(){return ld}extendParams(e,t,n){const s=t.extensions[this.name];e.color=new Le(1,1,1),e.opacity=1;const i=[];if(Array.isArray(s.diffuseFactor)){const a=s.diffuseFactor;e.color.fromArray(a),e.opacity=a[3]}if(s.diffuseTexture!==void 0&&i.push(n.assignTexture(e,"map",s.diffuseTexture)),e.emissive=new Le(0,0,0),e.glossiness=s.glossinessFactor!==void 0?s.glossinessFactor:1,e.specular=new Le(1,1,1),Array.isArray(s.specularFactor)&&e.specular.fromArray(s.specularFactor),s.specularGlossinessTexture!==void 0){const a=s.specularGlossinessTexture;i.push(n.assignTexture(e,"glossinessMap",a)),i.push(n.assignTexture(e,"specularMap",a))}return Promise.all(i)}createMaterial(e){const t=new ld(e);return t.fog=!0,t.color=e.color,t.map=e.map===void 0?null:e.map,t.lightMap=null,t.lightMapIntensity=1,t.aoMap=e.aoMap===void 0?null:e.aoMap,t.aoMapIntensity=1,t.emissive=e.emissive,t.emissiveIntensity=1,t.emissiveMap=e.emissiveMap===void 0?null:e.emissiveMap,t.bumpMap=e.bumpMap===void 0?null:e.bumpMap,t.bumpScale=1,t.normalMap=e.normalMap===void 0?null:e.normalMap,t.normalMapType=bs,e.normalScale&&(t.normalScale=e.normalScale),t.displacementMap=null,t.displacementScale=1,t.displacementBias=0,t.specularMap=e.specularMap===void 0?null:e.specularMap,t.specular=e.specular,t.glossinessMap=e.glossinessMap===void 0?null:e.glossinessMap,t.glossiness=e.glossiness,t.alphaMap=null,t.envMap=e.envMap===void 0?null:e.envMap,t.envMapIntensity=1,t.refractionRatio=.98,t}}class _k{constructor(){this.name=st.KHR_MESH_QUANTIZATION}}class Ls extends pr{constructor(e,t,n,s){super(e,t,n,s)}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,s=this.valueSize,i=e*s*3+s;for(let a=0;a!==s;a++)t[a]=n[i+a];return t}}Ls.prototype.beforeStart_=Ls.prototype.copySampleValue_;Ls.prototype.afterEnd_=Ls.prototype.copySampleValue_;Ls.prototype.interpolate_=function(r,e,t,n){const s=this.resultBuffer,i=this.sampleValues,a=this.valueSize,o=a*2,c=a*3,l=n-e,u=(t-e)/l,h=u*u,d=h*u,p=r*c,f=p-c,m=-2*d+3*h,_=d-h,g=1-m,y=_-h+u;for(let x=0;x!==a;x++){const w=i[f+x+a],T=i[f+x+o]*l,M=i[p+x+a],S=i[p+x]*l;s[x]=g*w+y*T+m*M+_*S}return s};const xk=new hn;class bk extends Ls{interpolate_(e,t,n,s){const i=super.interpolate_(e,t,n,s);return xk.fromArray(i).normalize().toArray(i),i}}const gr={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Za={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},k2={9728:Ut,9729:gn,9984:Wl,9985:m1,9986:jl,9987:li},D2={33071:mn,33648:Po,10497:ui},P2={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},hd={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Zr={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},vk={CUBICSPLINE:void 0,LINEAR:fi,STEP:Ea},dd={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function wk(r){return r.DefaultMaterial===void 0&&(r.DefaultMaterial=new Ns({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:oi})),r.DefaultMaterial}function Qa(r,e,t){for(const n in t.extensions)r[n]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[n]=t.extensions[n])}function ks(r,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(r.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Sk(r,e,t){let n=!1,s=!1;for(let o=0,c=e.length;o<c;o++){const l=e[o];if(l.POSITION!==void 0&&(n=!0),l.NORMAL!==void 0&&(s=!0),n&&s)break}if(!n&&!s)return Promise.resolve(r);const i=[],a=[];for(let o=0,c=e.length;o<c;o++){const l=e[o];if(n){const u=l.POSITION!==void 0?t.getDependency("accessor",l.POSITION):r.attributes.position;i.push(u)}if(s){const u=l.NORMAL!==void 0?t.getDependency("accessor",l.NORMAL):r.attributes.normal;a.push(u)}}return Promise.all([Promise.all(i),Promise.all(a)]).then(function(o){const c=o[0],l=o[1];return n&&(r.morphAttributes.position=c),s&&(r.morphAttributes.normal=l),r.morphTargetsRelative=!0,r})}function Tk(r,e){if(r.updateMorphTargets(),e.weights!==void 0)for(let t=0,n=e.weights.length;t<n;t++)r.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(r.morphTargetInfluences.length===t.length){r.morphTargetDictionary={};for(let n=0,s=t.length;n<s;n++)r.morphTargetDictionary[t[n]]=n}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Ek(r){const e=r.extensions&&r.extensions[st.KHR_DRACO_MESH_COMPRESSION];let t;return e?t="draco:"+e.bufferView+":"+e.indices+":"+F2(e.attributes):t=r.indices+":"+F2(r.attributes)+":"+r.mode,t}function F2(r){let e="";const t=Object.keys(r).sort();for(let n=0,s=t.length;n<s;n++)e+=t[n]+":"+r[t[n]]+";";return e}function pd(r){switch(r){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class Mk{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new nk,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.textureCache={},this.nodeNamesUsed={},typeof createImageBitmap!="undefined"&&/Firefox/.test(navigator.userAgent)===!1?this.textureLoader=new N2(this.options.manager):this.textureLoader=new nd(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new td(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const n=this,s=this.json,i=this.extensions;this.cache.removeAll(),this._invokeAll(function(a){return a._markDefs&&a._markDefs()}),Promise.all(this._invokeAll(function(a){return a.beforeRoot&&a.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(a){const o={scene:a[0][s.scene||0],scenes:a[0],animations:a[1],cameras:a[2],asset:s.asset,parser:n,userData:{}};Qa(i,o,s),ks(o,s),Promise.all(n._invokeAll(function(c){return c.afterRoot&&c.afterRoot(o)})).then(function(){e(o)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[];for(let s=0,i=t.length;s<i;s++){const a=t[s].joints;for(let o=0,c=a.length;o<c;o++)e[a[o]].isBone=!0}for(let s=0,i=e.length;s<i;s++){const a=e[s];a.mesh!==void 0&&(this._addNodeRef(this.meshCache,a.mesh),a.skin!==void 0&&(n[a.mesh].isSkinnedMesh=!0)),a.camera!==void 0&&this._addNodeRef(this.cameraCache,a.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,n){if(e.refs[t]<=1)return n;const s=n.clone(),i=(a,o)=>{const c=this.associations.get(a);c!=null&&this.associations.set(o,c);for(const[l,u]of a.children.entries())i(u,o.children[l])};return i(n,s),s.name+="_instance_"+e.uses[t]++,s}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let n=0;n<t.length;n++){const s=e(t[n]);if(s)return s}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const n=[];for(let s=0;s<t.length;s++){const i=e(t[s]);i&&n.push(i)}return n}getDependency(e,t){const n=e+":"+t;let s=this.cache.get(n);if(!s){switch(e){case"scene":s=this.loadScene(t);break;case"node":s=this.loadNode(t);break;case"mesh":s=this._invokeOne(function(i){return i.loadMesh&&i.loadMesh(t)});break;case"accessor":s=this.loadAccessor(t);break;case"bufferView":s=this._invokeOne(function(i){return i.loadBufferView&&i.loadBufferView(t)});break;case"buffer":s=this.loadBuffer(t);break;case"material":s=this._invokeOne(function(i){return i.loadMaterial&&i.loadMaterial(t)});break;case"texture":s=this._invokeOne(function(i){return i.loadTexture&&i.loadTexture(t)});break;case"skin":s=this.loadSkin(t);break;case"animation":s=this.loadAnimation(t);break;case"camera":s=this.loadCamera(t);break;default:throw new Error("Unknown type: "+e)}this.cache.add(n,s)}return s}getDependencies(e){let t=this.cache.get(e);if(!t){const n=this,s=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(s.map(function(i,a){return n.getDependency(e,a)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],n=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[st.KHR_BINARY_GLTF].body);const s=this.options;return new Promise(function(i,a){n.load(Yr.resolveURL(t.uri,s.path),i,void 0,function(){a(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(n){const s=t.byteLength||0,i=t.byteOffset||0;return n.slice(i,i+s)})}loadAccessor(e){const t=this,n=this.json,s=this.json.accessors[e];if(s.bufferView===void 0&&s.sparse===void 0)return Promise.resolve(null);const i=[];return s.bufferView!==void 0?i.push(this.getDependency("bufferView",s.bufferView)):i.push(null),s.sparse!==void 0&&(i.push(this.getDependency("bufferView",s.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",s.sparse.values.bufferView))),Promise.all(i).then(function(a){const o=a[0],c=P2[s.type],l=Za[s.componentType],u=l.BYTES_PER_ELEMENT,h=u*c,d=s.byteOffset||0,p=s.bufferView!==void 0?n.bufferViews[s.bufferView].byteStride:void 0,f=s.normalized===!0;let m,_;if(p&&p!==h){const g=Math.floor(d/p),y="InterleavedBuffer:"+s.bufferView+":"+s.componentType+":"+g+":"+s.count;let x=t.cache.get(y);x||(m=new l(o,g*p,s.count*p/u),x=new zi(m,p/u),t.cache.add(y,x)),_=new Ui(x,c,d%p/u,f)}else o===null?m=new l(s.count*c):m=new l(o,d,s.count*c),_=new It(m,c,f);if(s.sparse!==void 0){const g=P2.SCALAR,y=Za[s.sparse.indices.componentType],x=s.sparse.indices.byteOffset||0,w=s.sparse.values.byteOffset||0,T=new y(a[1],x,s.sparse.count*g),M=new l(a[2],w,s.sparse.count*c);o!==null&&(_=new It(_.array.slice(),_.itemSize,_.normalized));for(let S=0,R=T.length;S<R;S++){const k=T[S];if(_.setX(k,M[S*c]),c>=2&&_.setY(k,M[S*c+1]),c>=3&&_.setZ(k,M[S*c+2]),c>=4&&_.setW(k,M[S*c+3]),c>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return _})}loadTexture(e){const t=this.json,n=this.options,s=t.textures[e],i=t.images[s.source];let a=this.textureLoader;if(i.uri){const o=n.manager.getHandler(i.uri);o!==null&&(a=o)}return this.loadTextureImage(e,i,a)}loadTextureImage(e,t,n){const s=this,i=this.json,a=this.options,o=i.textures[e],c=(t.uri||t.bufferView)+":"+o.sampler;if(this.textureCache[c])return this.textureCache[c];const l=self.URL||self.webkitURL;let u=t.uri||"",h=!1;if(t.bufferView!==void 0)u=s.getDependency("bufferView",t.bufferView).then(function(p){h=!0;const f=new Blob([p],{type:t.mimeType});return u=l.createObjectURL(f),u});else if(t.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const d=Promise.resolve(u).then(function(p){return new Promise(function(f,m){let _=f;n.isImageBitmapLoader===!0&&(_=function(g){const y=new Vt(g);y.needsUpdate=!0,f(y)}),n.load(Yr.resolveURL(p,a.path),_,void 0,m)})}).then(function(p){h===!0&&l.revokeObjectURL(u),p.flipY=!1,o.name&&(p.name=o.name);const m=(i.samplers||{})[o.sampler]||{};return p.magFilter=k2[m.magFilter]||gn,p.minFilter=k2[m.minFilter]||li,p.wrapS=D2[m.wrapS]||ui,p.wrapT=D2[m.wrapT]||ui,s.associations.set(p,{textures:e}),p}).catch(function(){return console.error("THREE.GLTFLoader: Couldn't load texture",u),null});return this.textureCache[c]=d,d}assignTexture(e,t,n){const s=this;return this.getDependency("texture",n.index).then(function(i){if(n.texCoord!==void 0&&n.texCoord!=0&&!(t==="aoMap"&&n.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+n.texCoord+" for texture "+t+" not yet supported."),s.extensions[st.KHR_TEXTURE_TRANSFORM]){const a=n.extensions!==void 0?n.extensions[st.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const o=s.associations.get(i);i=s.extensions[st.KHR_TEXTURE_TRANSFORM].extendTexture(i,a),s.associations.set(i,o)}}return e[t]=i,i})}assignFinalMaterial(e){const t=e.geometry;let n=e.material;const s=t.attributes.tangent===void 0,i=t.attributes.color!==void 0,a=t.attributes.normal===void 0;if(e.isPoints){const o="PointsMaterial:"+n.uuid;let c=this.cache.get(o);c||(c=new Vh,Ht.prototype.copy.call(c,n),c.color.copy(n.color),c.map=n.map,c.sizeAttenuation=!1,this.cache.add(o,c)),n=c}else if(e.isLine){const o="LineBasicMaterial:"+n.uuid;let c=this.cache.get(o);c||(c=new Wi,Ht.prototype.copy.call(c,n),c.color.copy(n.color),this.cache.add(o,c)),n=c}if(s||i||a){let o="ClonedMaterial:"+n.uuid+":";n.isGLTFSpecularGlossinessMaterial&&(o+="specular-glossiness:"),s&&(o+="derivative-tangents:"),i&&(o+="vertex-colors:"),a&&(o+="flat-shading:");let c=this.cache.get(o);c||(c=n.clone(),i&&(c.vertexColors=!0),a&&(c.flatShading=!0),s&&(c.normalScale&&(c.normalScale.y*=-1),c.clearcoatNormalScale&&(c.clearcoatNormalScale.y*=-1)),this.cache.add(o,c),this.associations.set(c,this.associations.get(n))),n=c}n.aoMap&&t.attributes.uv2===void 0&&t.attributes.uv!==void 0&&t.setAttribute("uv2",t.attributes.uv),e.material=n}getMaterialType(){return Ns}loadMaterial(e){const t=this,n=this.json,s=this.extensions,i=n.materials[e];let a;const o={},c=i.extensions||{},l=[];if(c[st.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const h=s[st.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];a=h.getMaterialType(),l.push(h.extendParams(o,i,t))}else if(c[st.KHR_MATERIALS_UNLIT]){const h=s[st.KHR_MATERIALS_UNLIT];a=h.getMaterialType(),l.push(h.extendParams(o,i,t))}else{const h=i.pbrMetallicRoughness||{};if(o.color=new Le(1,1,1),o.opacity=1,Array.isArray(h.baseColorFactor)){const d=h.baseColorFactor;o.color.fromArray(d),o.opacity=d[3]}h.baseColorTexture!==void 0&&l.push(t.assignTexture(o,"map",h.baseColorTexture)),o.metalness=h.metallicFactor!==void 0?h.metallicFactor:1,o.roughness=h.roughnessFactor!==void 0?h.roughnessFactor:1,h.metallicRoughnessTexture!==void 0&&(l.push(t.assignTexture(o,"metalnessMap",h.metallicRoughnessTexture)),l.push(t.assignTexture(o,"roughnessMap",h.metallicRoughnessTexture))),a=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),l.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,o)})))}i.doubleSided===!0&&(o.side=ys);const u=i.alphaMode||dd.OPAQUE;if(u===dd.BLEND?(o.transparent=!0,o.depthWrite=!1):(o.format=Fr,o.transparent=!1,u===dd.MASK&&(o.alphaTest=i.alphaCutoff!==void 0?i.alphaCutoff:.5)),i.normalTexture!==void 0&&a!==qn&&(l.push(t.assignTexture(o,"normalMap",i.normalTexture)),o.normalScale=new fe(1,1),i.normalTexture.scale!==void 0)){const h=i.normalTexture.scale;o.normalScale.set(h,h)}return i.occlusionTexture!==void 0&&a!==qn&&(l.push(t.assignTexture(o,"aoMap",i.occlusionTexture)),i.occlusionTexture.strength!==void 0&&(o.aoMapIntensity=i.occlusionTexture.strength)),i.emissiveFactor!==void 0&&a!==qn&&(o.emissive=new Le().fromArray(i.emissiveFactor)),i.emissiveTexture!==void 0&&a!==qn&&l.push(t.assignTexture(o,"emissiveMap",i.emissiveTexture)),Promise.all(l).then(function(){let h;return a===ld?h=s[st.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(o):h=new a(o),i.name&&(h.name=i.name),h.map&&(h.map.encoding=Or),h.emissiveMap&&(h.emissiveMap.encoding=Or),ks(h,i),t.associations.set(h,{materials:e}),i.extensions&&Qa(s,h,i),h})}createUniqueName(e){const t=ht.sanitizeNodeName(e||"");let n=t;for(let s=1;this.nodeNamesUsed[n];++s)n=t+"_"+s;return this.nodeNamesUsed[n]=!0,n}loadGeometries(e){const t=this,n=this.extensions,s=this.primitiveCache;function i(o){return n[st.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o,t).then(function(c){return B2(c,o,t)})}const a=[];for(let o=0,c=e.length;o<c;o++){const l=e[o],u=Ek(l),h=s[u];if(h)a.push(h.promise);else{let d;l.extensions&&l.extensions[st.KHR_DRACO_MESH_COMPRESSION]?d=i(l):d=B2(new yt,l,t),s[u]={primitive:l,promise:d},a.push(d)}}return Promise.all(a)}loadMesh(e){const t=this,n=this.json,s=this.extensions,i=n.meshes[e],a=i.primitives,o=[];for(let c=0,l=a.length;c<l;c++){const u=a[c].material===void 0?wk(this.cache):this.getDependency("material",a[c].material);o.push(u)}return o.push(t.loadGeometries(a)),Promise.all(o).then(function(c){const l=c.slice(0,c.length-1),u=c[c.length-1],h=[];for(let p=0,f=u.length;p<f;p++){const m=u[p],_=a[p];let g;const y=l[p];if(_.mode===gr.TRIANGLES||_.mode===gr.TRIANGLE_STRIP||_.mode===gr.TRIANGLE_FAN||_.mode===void 0)g=i.isSkinnedMesh===!0?new Fh(m,y):new $t(m,y),g.isSkinnedMesh===!0&&!g.geometry.attributes.skinWeight.normalized&&g.normalizeSkinWeights(),_.mode===gr.TRIANGLE_STRIP?g.geometry=z2(g.geometry,DM):_.mode===gr.TRIANGLE_FAN&&(g.geometry=z2(g.geometry,A1));else if(_.mode===gr.LINES)g=new yc(m,y);else if(_.mode===gr.LINE_STRIP)g=new gc(m,y);else if(_.mode===gr.LINE_LOOP)g=new Zg(m,y);else if(_.mode===gr.POINTS)g=new e2(m,y);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+_.mode);Object.keys(g.geometry.morphAttributes).length>0&&Tk(g,i),g.name=t.createUniqueName(i.name||"mesh_"+e),ks(g,i),_.extensions&&Qa(s,g,_),t.assignFinalMaterial(g),h.push(g)}for(let p=0,f=h.length;p<f;p++)t.associations.set(h[p],{meshes:e,primitives:p});if(h.length===1)return h[0];const d=new qr;t.associations.set(d,{meshes:e});for(let p=0,f=h.length;p<f;p++)d.add(h[p]);return d})}loadCamera(e){let t;const n=this.json.cameras[e],s=n[n.type];if(!s){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return n.type==="perspective"?t=new dn(ZM.radToDeg(s.yfov),s.aspectRatio||1,s.znear||1,s.zfar||2e6):n.type==="orthographic"&&(t=new Pa(-s.xmag,s.xmag,s.ymag,-s.ymag,s.znear,s.zfar)),n.name&&(t.name=this.createUniqueName(n.name)),ks(t,n),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],n={joints:t.joints};return t.inverseBindMatrices===void 0?Promise.resolve(n):this.getDependency("accessor",t.inverseBindMatrices).then(function(s){return n.inverseBindMatrices=s,n})}loadAnimation(e){const n=this.json.animations[e],s=[],i=[],a=[],o=[],c=[];for(let l=0,u=n.channels.length;l<u;l++){const h=n.channels[l],d=n.samplers[h.sampler],p=h.target,f=p.node!==void 0?p.node:p.id,m=n.parameters!==void 0?n.parameters[d.input]:d.input,_=n.parameters!==void 0?n.parameters[d.output]:d.output;s.push(this.getDependency("node",f)),i.push(this.getDependency("accessor",m)),a.push(this.getDependency("accessor",_)),o.push(d),c.push(p)}return Promise.all([Promise.all(s),Promise.all(i),Promise.all(a),Promise.all(o),Promise.all(c)]).then(function(l){const u=l[0],h=l[1],d=l[2],p=l[3],f=l[4],m=[];for(let g=0,y=u.length;g<y;g++){const x=u[g],w=h[g],T=d[g],M=p[g],S=f[g];if(x===void 0)continue;x.updateMatrix(),x.matrixAutoUpdate=!0;let R;switch(Zr[S.path]){case Zr.weights:R=Ka;break;case Zr.rotation:R=Cs;break;case Zr.position:case Zr.scale:default:R=Xa;break}const k=x.name?x.name:x.uuid,O=M.interpolation!==void 0?vk[M.interpolation]:fi,A=[];Zr[S.path]===Zr.weights?x.traverse(function(B){B.morphTargetInfluences&&A.push(B.name?B.name:B.uuid)}):A.push(k);let Y=T.array;if(T.normalized){const B=pd(Y.constructor),H=new Float32Array(Y.length);for(let U=0,j=Y.length;U<j;U++)H[U]=Y[U]*B;Y=H}for(let B=0,H=A.length;B<H;B++){const U=new R(A[B]+"."+Zr[S.path],w.array,Y,O);M.interpolation==="CUBICSPLINE"&&(U.createInterpolant=function(K){const se=this instanceof Cs?bk:Ls;return new se(this.times,this.values,this.getValueSize()/3,K)},U.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),m.push(U)}}const _=n.name?n.name:"animation_"+e;return new ed(_,void 0,m)})}createNodeMesh(e){const t=this.json,n=this,s=t.nodes[e];return s.mesh===void 0?null:n.getDependency("mesh",s.mesh).then(function(i){const a=n._getNodeRef(n.meshCache,s.mesh,i);return s.weights!==void 0&&a.traverse(function(o){if(!!o.isMesh)for(let c=0,l=s.weights.length;c<l;c++)o.morphTargetInfluences[c]=s.weights[c]}),a})}loadNode(e){const t=this.json,n=this.extensions,s=this,i=t.nodes[e],a=i.name?s.createUniqueName(i.name):"";return function(){const o=[],c=s._invokeOne(function(l){return l.createNodeMesh&&l.createNodeMesh(e)});return c&&o.push(c),i.camera!==void 0&&o.push(s.getDependency("camera",i.camera).then(function(l){return s._getNodeRef(s.cameraCache,i.camera,l)})),s._invokeAll(function(l){return l.createNodeAttachment&&l.createNodeAttachment(e)}).forEach(function(l){o.push(l)}),Promise.all(o)}().then(function(o){let c;if(i.isBone===!0?c=new Oh:o.length>1?c=new qr:o.length===1?c=o[0]:c=new it,c!==o[0])for(let l=0,u=o.length;l<u;l++)c.add(o[l]);if(i.name&&(c.userData.name=i.name,c.name=a),ks(c,i),i.extensions&&Qa(n,c,i),i.matrix!==void 0){const l=new Be;l.fromArray(i.matrix),c.applyMatrix4(l)}else i.translation!==void 0&&c.position.fromArray(i.translation),i.rotation!==void 0&&c.quaternion.fromArray(i.rotation),i.scale!==void 0&&c.scale.fromArray(i.scale);return s.associations.has(c)||s.associations.set(c,{}),s.associations.get(c).nodes=e,c})}loadScene(e){const t=this.json,n=this.extensions,s=this.json.scenes[e],i=this,a=new qr;s.name&&(a.name=i.createUniqueName(s.name)),ks(a,s),s.extensions&&Qa(n,a,s);const o=s.nodes||[],c=[];for(let l=0,u=o.length;l<u;l++)c.push(O2(o[l],a,t,i));return Promise.all(c).then(function(){const l=u=>{const h=new Map;for(const[d,p]of i.associations)(d instanceof Ht||d instanceof Vt)&&h.set(d,p);return u.traverse(d=>{const p=i.associations.get(d);p!=null&&h.set(d,p)}),h};return i.associations=l(a),a})}}function O2(r,e,t,n){const s=t.nodes[r];return n.getDependency("node",r).then(function(i){if(s.skin===void 0)return i;let a;return n.getDependency("skin",s.skin).then(function(o){a=o;const c=[];for(let l=0,u=a.joints.length;l<u;l++)c.push(n.getDependency("node",a.joints[l]));return Promise.all(c)}).then(function(o){return i.traverse(function(c){if(!c.isMesh)return;const l=[],u=[];for(let h=0,d=o.length;h<d;h++){const p=o[h];if(p){l.push(p);const f=new Be;a.inverseBindMatrices!==void 0&&f.fromArray(a.inverseBindMatrices.array,h*16),u.push(f)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',a.joints[h])}c.bind(new Bh(l,u),c.matrixWorld)}),i})}).then(function(i){e.add(i);const a=[];if(s.children){const o=s.children;for(let c=0,l=o.length;c<l;c++){const u=o[c];a.push(O2(u,i,t,n))}}return Promise.all(a)})}function Ak(r,e,t){const n=e.attributes,s=new Cn;if(n.POSITION!==void 0){const o=t.json.accessors[n.POSITION],c=o.min,l=o.max;if(c!==void 0&&l!==void 0){if(s.set(new L(c[0],c[1],c[2]),new L(l[0],l[1],l[2])),o.normalized){const u=pd(Za[o.componentType]);s.min.multiplyScalar(u),s.max.multiplyScalar(u)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const i=e.targets;if(i!==void 0){const o=new L,c=new L;for(let l=0,u=i.length;l<u;l++){const h=i[l];if(h.POSITION!==void 0){const d=t.json.accessors[h.POSITION],p=d.min,f=d.max;if(p!==void 0&&f!==void 0){if(c.setX(Math.max(Math.abs(p[0]),Math.abs(f[0]))),c.setY(Math.max(Math.abs(p[1]),Math.abs(f[1]))),c.setZ(Math.max(Math.abs(p[2]),Math.abs(f[2]))),d.normalized){const m=pd(Za[d.componentType]);c.multiplyScalar(m)}o.max(c)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}s.expandByVector(o)}r.boundingBox=s;const a=new Ts;s.getCenter(a.center),a.radius=s.min.distanceTo(s.max)/2,r.boundingSphere=a}function B2(r,e,t){const n=e.attributes,s=[];function i(a,o){return t.getDependency("accessor",a).then(function(c){r.setAttribute(o,c)})}for(const a in n){const o=hd[a]||a.toLowerCase();o in r.attributes||s.push(i(n[a],o))}if(e.indices!==void 0&&!r.index){const a=t.getDependency("accessor",e.indices).then(function(o){r.setIndex(o)});s.push(a)}return ks(r,e),Ak(r,e,t),Promise.all(s).then(function(){return e.targets!==void 0?Sk(r,e.targets,t):r})}function z2(r,e){let t=r.getIndex();if(t===null){const a=[],o=r.getAttribute("position");if(o!==void 0){for(let c=0;c<o.count;c++)a.push(c);r.setIndex(a),t=r.getIndex()}else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),r}const n=t.count-2,s=[];if(e===A1)for(let a=1;a<=n;a++)s.push(t.getX(0)),s.push(t.getX(a)),s.push(t.getX(a+1));else for(let a=0;a<n;a++)a%2==0?(s.push(t.getX(a)),s.push(t.getX(a+1)),s.push(t.getX(a+2))):(s.push(t.getX(a+2)),s.push(t.getX(a+1)),s.push(t.getX(a)));s.length/3!==n&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=r.clone();return i.setIndex(s),i}const Ik=[.499976992607117,.34746599197387695,.500025987625122,.45251297950744596,.499974012374878,.397628009319305,.482113003730774,.528020977973938,.500150978565216,.47284400463104204,.499909996986389,.5017470121383669,.499523013830185,.59893798828125,.289712011814117,.6192359924316411,.499954998493195,.687601983547211,.499987006187439,.730081021785736,.500023007392883,.892949998378754,.500023007392883,.33376598358154297,.5000159740448,.320775985717773,.500023007392883,.30765199661254905,.499976992607117,.30472201108932495,.499976992607117,.29406601190567005,.499976992607117,.280614972114563,.499976992607117,.262980997562408,.499967992305756,.21862900257110596,.499816000461578,.43701899051666304,.473773002624512,.42609000205993697,.104906998574734,.745859026908875,.365929991006851,.590424001216888,.338757991790771,.58697497844696,.311120003461838,.590539991855621,.274657994508743,.6108689904212949,.393361985683441,.596293985843658,.345234006643295,.655988991260529,.370094001293182,.6539239883422849,.319321990013123,.652734994888306,.297903001308441,.646408975124359,.24779200553894,.589190006256104,.396889001131058,.15724498033523604,.280097991228104,.6244000196456909,.106310002505779,.6000440120697019,.2099249958992,.6086469888687129,.355807989835739,.46559399366378795,.471751004457474,.34959602355957,.474155008792877,.319808006286621,.439785003662109,.342770993709564,.414617002010345,.33345901966095004,.450374007225037,.319139003753662,.428770989179611,.31730902194976796,.374971002340317,.272194981575012,.486716985702515,.452371001243591,.485300987958908,.47260499000549305,.257764995098114,.685509979724884,.401223003864288,.544827997684479,.429818987846375,.451385021209717,.421351999044418,.466259002685547,.276895999908447,.467943012714386,.483370006084442,.500413000583649,.33721199631691,.7171170115470891,.296391993761063,.706757009029388,.169294998049736,.806186020374298,.447580009698868,.697390019893646,.392390012741089,.646112024784088,.354490011930466,.30321598052978505,.067304998636246,.269894957542419,.442739009857178,.427173972129822,.457098007202148,.415207982063293,.381974011659622,.305289030075073,.392388999462128,.305796980857849,.277076005935669,.728067994117737,.422551989555359,.436766982078552,.385919004678726,.718635976314545,.383103013038635,.744159996509552,.331431001424789,.880285978317261,.229923993349075,.767997026443481,.364500999450684,.810886025428772,.229622006416321,.700459003448486,.173287004232407,.721252024173737,.472878992557526,.33380198478698697,.446828007698059,.331472992897034,.422762006521225,.32611000537872303,.445307999849319,.41993403434753396,.388103008270264,.306038975715637,.403039008378983,.293460011482239,.403629004955292,.306046962738037,.460041999816895,.44286096096038796,.431158006191254,.307633996009827,.452181994915009,.307633996009827,.475387006998062,.307633996009827,.465828001499176,.22080999612808205,.472328990697861,.263774037361145,.473087012767792,.282142996788025,.473122000694275,.295374035835266,.473033010959625,.30472201108932495,.427942007780075,.30472201108932495,.426479011774063,.29646003246307395,.423162013292313,.28815400600433305,.4183090031147,.27993702888488803,.390094995498657,.360427021980286,.013953999616206,.439965963363647,.499913990497589,.41985297203064,.413199990987778,.30460000038146995,.409626007080078,.29817700386047397,.468080013990402,.398465037345886,.422728985548019,.414014995098114,.463079988956451,.406216025352478,.37211999297142,.52658599615097,.334562003612518,.5039269924163821,.411671012639999,.45303499698638905,.242175996303558,.85232400894165,.290776997804642,.798554003238678,.327338010072708,.7434729933738711,.399509996175766,.251078963279724,.441727995872498,.738323986530304,.429764986038208,.8121659755706789,.412198007106781,.891098976135254,.288955003023148,.601047992706299,.218936994671822,.564589023590088,.41278201341629,.601029992103577,.257135003805161,.644559979438782,.427684992551804,.562039017677307,.448339998722076,.46306395530700695,.178560003638268,.54244601726532,.247308000922203,.542806029319763,.286267012357712,.532325029373169,.332827985286713,.5392879843711851,.368755996227264,.552793025970459,.398963987827301,.567345023155212,.476410001516342,.594193994998932,.189241006970406,.47607600688934304,.228962004184723,.651049017906189,.490725994110107,.43759900331497203,.404670000076294,.514867007732391,.019469000399113,.598435997962952,.426243007183075,.5795689821243291,.396993011236191,.451202988624573,.266469985246658,.6230229735374451,.439121007919312,.48104202747345004,.032313998788595,.355643033981323,.419054001569748,.612845003604889,.462783008813858,.49425303936004605,.238978996872902,.22025501728057895,.198220998048782,.16806197166442904,.107550002634525,.459244966506958,.183610007166862,.259742975234985,.134409993886948,.6663169860839839,.385764002799988,.11684602499008201,.490967005491257,.42062199115753196,.382384985685349,.491427004337311,.174399003386497,.602329015731812,.318785011768341,.60376501083374,.343364000320435,.599403023719788,.396100014448166,.28978300094604503,.187885001301765,.41146200895309404,.430987000465393,.05593502521514904,.318993002176285,.101714968681335,.266247987747192,.130298972129822,.500023007392883,.809423983097076,.499976992607117,.045547008514403964,.366169989109039,.601177990436554,.393207013607025,.6044629812240601,.410373002290726,.608919978141785,.194993004202843,.657898008823395,.388664990663528,.6377159953117371,.365961998701096,.644029021263123,.343364000320435,.6446430087089541,.318785011768341,.64165997505188,.301414996385574,.636843979358673,.058132998645306,.680923998355865,.301414996385574,.612550973892212,.499987989664078,.38156598806381203,.415838003158569,.375804007053375,.445681989192963,.43392300605773904,.465844005346298,.379359006881714,.49992299079895,.648476004600525,.288718998432159,.180054008960724,.335278987884521,.14718002080917403,.440512001514435,.09758102893829301,.128294005990028,.20805901288986195,.408771991729736,.6261060237884519,.455606997013092,.548198997974396,.499877005815506,.09100997447967496,.375436991453171,.07580798864364602,.11421000212431,.38497799634933505,.448662012815475,.30472201108932495,.4480200111866,.295367956161499,.447111994028091,.28419196605682395,.444831997156143,.269205987453461,.430011987686157,.23319101333618197,.406787008047104,.31432700157165505,.400738000869751,.318930983543396,.392399996519089,.32229697704315197,.367855995893478,.33608102798461903,.247923001646996,.39866697788238503,.452769994735718,.579150021076202,.43639200925827,.640112996101379,.416164010763168,.631286025047302,.413385987281799,.307633996009827,.228018000721931,.316428005695343,.468268007040024,.6473289728164671,.411361992359161,.195672988891602,.499989002943039,.530174970626831,.479153990745544,.557345986366272,.499974012374878,.5603629946708679,.432112008333206,.506411015987396,.499886006116867,.13308298587799094,.49991300702095,.17827099561691295,.456548988819122,.18079900741577104,.344549000263214,.254561007022858,.37890899181366,.425989985466003,.374292999505997,.219815015792847,.319687992334366,.42926204204559304,.357154995203018,.395730018615723,.295284003019333,.37841904163360596,.447750002145767,.137522995471954,.410986006259918,.491276979446411,.31395098567009,.22469198703765902,.354128003120422,.187447011470795,.324548006057739,.296007037162781,.189096003770828,.35370004177093495,.279776990413666,.28534197807312,.1338230073452,.317299008369446,.336768001317978,.35526698827743497,.429883986711502,.533478021621704,.455527991056442,.451377034187317,.437114000320435,.441103994846344,.467287987470627,.47007501125335704,.414712011814117,.6647800207138059,.37704598903656,.677222013473511,.344107985496521,.679849028587341,.312875986099243,.67766797542572,.283526003360748,.6668099761009221,.241245999932289,.617214024066925,.102986000478268,.531237006187439,.267612010240555,.575439989566803,.297879010438919,.5668240189552309,.333433985710144,.5661219954490659,.366427004337311,.573884010314941,.396012008190155,.583303987979889,.420121014118195,.58977198600769,.007561000064015,.519222974777222,.432949006557465,.43048202991485596,.458638995885849,.520910978317261,.473466008901596,.45425599813461304,.476087987422943,.43616998195648204,.468472003936768,.444943010807037,.433990985155106,.417638003826141,.483518004417419,.43701601028442405,.482482999563217,.42215096950530995,.42645001411438,.6102010011672969,.438998997211456,.60350501537323,.450067013502121,.599565982818604,.289712011814117,.631747007369995,.276670008897781,.636627018451691,.517862021923065,.528051972389221,.710287988185883,.6192359924316411,.526226997375488,.42609000205993697,.895093023777008,.745859026908875,.634069979190826,.590424001216888,.661242008209229,.58697497844696,.688880026340485,.590539991855621,.725341975688934,.6108689904212949,.606630027294159,.5962949991226201,.654766023159027,.655988991260529,.629905998706818,.6539239883422849,.680678009986877,.652734994888306,.702096998691559,.646408975124359,.75221198797226,.589195013046265,.602918028831482,.15713703632354703,.719901978969574,.6244000196456909,.893692970275879,.600040018558502,.790081977844238,.608645975589752,.643998026847839,.465512037277222,.528249025344849,.34959602355957,.525849997997284,.31980895996093806,.560214996337891,.342770993709564,.585384011268616,.33345901966095004,.549625992774963,.319139003753662,.57122802734375,.317308008670807,.624852001667023,.27190101146698,.513050019741058,.45271801948547397,.51509702205658,.472748041152954,.742246985435486,.685492992401123,.598631024360657,.545020997524261,.570338010787964,.451424956321716,.578631997108459,.46637701988220204,.723087012767792,.467945992946625,.516445994377136,.500361025333405,.662801027297974,.717082023620605,.70362401008606,.706728994846344,.830704987049103,.806186020374298,.552385985851288,.697431981563568,.607609987258911,.646112024784088,.645429015159607,.30329298973083496,.932694971561432,.269894957542419,.557260990142822,.427173972129822,.542901992797852,.415207982063293,.6180260181427,.305289030075073,.607590973377228,.305796980857849,.722943007946014,.7280369997024541,.577413976192474,.43683302402496305,.614082992076874,.7186130285263059,.616907000541687,.744113981723785,.668509006500244,.880086004734039,.770092010498047,.767979025840759,.635536015033722,.8107510209083559,.77039098739624,.7004439830780029,.826722025871277,.7212449908256531,.527121007442474,.33380198478698697,.553171992301941,.331472992897034,.577238023281097,.32611000537872303,.554691970348358,.41993403434753396,.611896991729736,.306038975715637,.59696102142334,.293460011482239,.596370995044708,.306046962738037,.539958000183105,.44286096096038796,.568841993808746,.307633996009827,.547818005084991,.307633996009827,.52461302280426,.307633996009827,.534089982509613,.22085899114608798,.527670979499817,.263774037361145,.526912987232208,.282142996788025,.526877999305725,.295374035835266,.526966989040375,.30472201108932495,.572058022022247,.30472201108932495,.573521018028259,.29646003246307395,.57683801651001,.28815400600433305,.581691026687622,.27993702888488803,.609944999217987,.36009001731872603,.986046016216278,.439965963363647,.5867999792099,.30460000038146995,.590372025966644,.29817700386047397,.531915009021759,.398463010787964,.577268004417419,.414065003395081,.536915004253387,.406213998794556,.627542972564697,.526647984981537,.665585994720459,.5040490031242371,.588353991508484,.45313799381256104,.757824003696442,.85232400894165,.709249973297119,.798492014408112,.672684013843536,.743418991565704,.600408971309662,.25099503993988004,.55826598405838,.738327980041504,.570303976535797,.812129020690918,.588165998458862,.890955984592438,.711045026779175,.601047992706299,.781069993972778,.564594984054565,.587247014045715,.601068019866943,.742869973182678,.644554018974304,.572156012058258,.562348008155823,.55186802148819,.46342998743057295,.821442008018494,.542443990707397,.752701997756958,.542818009853363,.71375697851181,.532373011112213,.66711300611496,.539327025413513,.631101012229919,.552846014499664,.6008620262146,.567526996135712,.523481011390686,.5943729877471919,.810747981071472,.476073980331421,.771045982837677,.6510409712791441,.509127020835876,.43728196620941195,.595292985439301,.514976024627686,.980530977249146,.598435997962952,.573499977588654,.579999983310699,.602994978427887,.45131200551986705,.733529984951019,.6230229735374451,.560611009597778,.48098301887512196,.967685997486115,.355643033981323,.580985009670258,.612839996814728,.537728011608124,.494614958763123,.760966002941132,.22024703025817904,.801778972148895,.16806197166442904,.892440974712372,.45923900604248,.816350996494293,.259739995002747,.865594983100891,.666312992572784,.614073991775513,.11675399541854903,.508952975273132,.42056202888488803,.617941975593567,.49168395996093806,.825608015060425,.602325022220612,.681214988231659,.60376501083374,.656635999679565,.599403023719788,.603900015354156,.28978300094604503,.81208598613739,.41146099567413297,.56801301240921,.05543500185012795,.681007981300354,.101714968681335,.733752012252808,.130298972129822,.633830010890961,.601177990436554,.606792986392975,.6044629812240601,.589659988880157,.6089379787445071,.805015981197357,.657891988754272,.611334979534149,.6377159953117371,.634037971496582,.644029021263123,.656635999679565,.6446430087089541,.681214988231659,.64165997505188,.698584973812103,.636843979358673,.941866993904114,.680923998355865,.698584973812103,.612550973892212,.584177017211914,.375892996788025,.554318010807037,.43392300605773904,.534153997898102,.37935996055603005,.711217999458313,.18002498149871804,.664629995822906,.14712899923324596,.559099972248077,.09736800193786599,.871706008911133,.20805901288986195,.591234028339386,.6261060237884519,.544341027736664,.548416018486023,.624562978744507,.07580798864364602,.88577002286911,.384971022605896,.551338016986847,.30472201108932495,.551980018615723,.295367956161499,.552887976169586,.28419196605682395,.555167973041534,.269205987453461,.569944024085999,.23296499252319303,.593203008174896,.31432402133941695,.599261999130249,.318930983543396,.607599973678589,.32229697704315197,.631937980651855,.33649998903274503,.752032995223999,.398684978485107,.547226011753082,.579604983329773,.563543975353241,.640172004699707,.583841025829315,.631286025047302,.586614012718201,.307633996009827,.771915018558502,.31642198562622104,.531597018241882,.647517025470734,.588370978832245,.19555902481079102,.52079701423645,.5574349761009221,.567984998226166,.5065209865570071,.543282985687256,.18074500560760498,.655317008495331,.25448501110076904,.621008992195129,.42598199844360396,.625559985637665,.21968799829483,.680198013782501,.42928099632263195,.64276397228241,.39566200971603405,.704662978649139,.378470003604889,.552012026309967,.13740801811218295,.589071989059448,.491362988948822,.685944974422455,.224642992019653,.645735025405884,.18735998868942305,.675342977046967,.29602199792861905,.810858011245728,.35369503498077404,.72012197971344,.28533303737640403,.866151988506317,.31729501485824596,.663187026977539,.35540300607681297,.570082008838654,.533674001693726,.544561982154846,.451624035835266,.562758982181549,.441215038299561,.531987011432648,.469859957695007,.585271000862122,.664822995662689,.622952997684479,.67722100019455,.655896008014679,.679836988449097,.687132000923157,.677654027938843,.716481983661652,.666799008846283,.758756995201111,.617213010787964,.897013008594513,.531230986118317,.732392013072968,.575452983379364,.70211398601532,.566837012767792,.66652500629425,.566133975982666,.633504986763,.5739120244979861,.603875994682312,.583413004875183,.579657971858978,.590054988861084,.992439985275269,.519222974777222,.567192018032074,.43058001995086703,.54136598110199,.521100997924805,.526564002037048,.453881978988647,.523913025856018,.43616998195648204,.531529009342194,.444943010807037,.566035985946655,.41767096519470204,.51631098985672,.43694603443145796,.5174720287323,.42212295532226596,.573594987392426,.610193014144897,.560697972774506,.604668021202087,.549755990505219,.6002489924430849,.710287988185883,.631747007369995,.723330020904541,.636627018451691],Nk=[323.11651611328125,323.94647216796875,-17.568782806396484,321.64990234375,267.7066650390625,-31.925785064697266,321.6676330566406,285.19525146484375,-17.194509506225586,306.4206848144531,216.11929321289062,-23.553361892700195,321.1368103027344,251.257568359375,-33.84282302856445,320.308837890625,230.17721557617188,-31.289081573486328,318.3310546875,181.22036743164062,-14.797897338867188,210.6700897216797,183.96359252929688,8.644062042236328,317.1302490234375,148.72677612304688,-10.399860382080078,316.5323791503906,128.6800079345703,-11.26718521118164,314.0401611328125,52.11235046386719,-3.3319506645202637,323.38702392578125,332.09625244140625,-16.704530715942383,323.5595397949219,338.2655944824219,-14.759981155395508,323.5887756347656,340.659423828125,-12.136107444763184,323.96087646484375,342.1773681640625,-11.875374794006348,324.2167663574219,348.4466857910156,-12.978582382202148,324.48931884765625,356.75933837890625,-14.554830551147461,324.84228515625,366.36590576171875,-14.144981384277344,325.2572937011719,384.9513854980469,-8.975934028625488,321.7921142578125,276.28167724609375,-28.98696517944336,306.4281921386719,275.7503662109375,-20.878870010375977,159.87014770507812,131.3053741455078,37.14374923706055,254.20277404785156,194.42990112304688,2.7031404972076416,239.59185791015625,196.41848754882812,2.972090482711792,225.3127899169922,196.68807983398438,4.522538185119629,205.5539093017578,190.17918395996094,9.360472679138184,266.25823974609375,190.09291076660156,3.3210108280181885,232.54664611816406,161.1142578125,.4966323971748352,248.14019775390625,161.02940368652344,.7534967660903931,218.1525421142578,163.57833862304688,2.2705366611480713,208.49998474121094,168.55471801757812,4.669690132141113,194.8409423828125,200.6750030517578,12.155685424804688,267.7841796875,414.53961181640625,-1.8064359426498413,205.23828125,181.122802734375,10.508393287658691,154.94073486328125,197.5607452392578,38.3432731628418,178.42001342773438,191.921142578125,18.159528732299805,244.1207733154297,258.5937194824219,-3.900184154510498,303.1524658203125,321.52093505859375,-16.866844177246094,306.58087158203125,338.35498046875,-13.89834213256836,283.00830078125,327.0491027832031,-13.434535026550293,270.6599426269531,334.0726623535156,-9.07385540008545,291.79815673828125,339.4311828613281,-11.61515998840332,280.6661376953125,341.4773864746094,-7.595709800720215,253.0904083251953,359.0290832519531,-.5970669388771057,308.47296142578125,267.54986572265625,-31.436981201171875,305.8460998535156,251.86883544921875,-33.17796325683594,185.6485137939453,153.70790100097656,6.360101699829102,273.1829833984375,218.42984008789062,-4.297842025756836,270.1053466796875,264.7032470703125,-16.802474975585938,268.9358215332031,256.55902099609375,-14.856505393981934,201.0337677001953,258.9792785644531,3.5506505966186523,305.99237060546875,232.39395141601562,-29.471277236938477,219.88006591796875,137.08212280273438,-3.7479465007781982,199.33328247070312,142.66859436035156,.7038824558258057,171.93594360351562,102.62930297851562,25.879261016845703,285.7288818359375,146.78271484375,-8.614612579345703,262.0455322265625,164.37820434570312,2.617023468017578,240.76773071289062,344.6684875488281,1.1622507572174072,172.84420776367188,344.5473937988281,52.14391326904297,281.74786376953125,273.1513977050781,-14.525100708007812,295.11383056640625,278.23193359375,-15.336343765258789,257.3583984375,344.6321105957031,.5829941630363464,264.4135437011719,343.39166259765625,-1.017601490020752,191.10064697265625,132.69065856933594,3.8590035438537598,269.67431640625,271.9882507324219,-13.59800910949707,248.12142944335938,137.29592895507812,-6.9757537841796875,244.83111572265625,124.17098999023438,-8.012014389038086,228.30499267578125,62.86616516113281,3.8345837593078613,181.92501831054688,116.54222106933594,13.413105964660645,238.1670684814453,91.65449523925781,-2.371932029724121,177.29916381835938,147.32359313964844,11.65469741821289,168.9032745361328,139.77952575683594,23.712440490722656,304.657470703125,331.4319152832031,-16.049942016601562,287.97210693359375,334.75262451171875,-12.795928955078125,275.8045959472656,338.0773620605469,-8.809469223022461,285.7834777832031,276.115234375,-13.412927627563477,261.038330078125,344.1378173828125,-.24986127018928528,268.093505859375,345.9375,-4.172092914581299,266.13116455078125,342.62908935546875,-1.2260991334915161,290.6131896972656,267.3948974609375,-22.783634185791016,283.6044006347656,340.5296936035156,-6.641707897186279,295.03564453125,340.2284851074219,-9.275909423828125,308.5382080078125,340.4044189453125,-11.458096504211426,304.6598815917969,384.4068908691406,-8.751299858093262,305.5709228515625,365.5459289550781,-13.695691108703613,306.277099609375,355.4984130859375,-14.016304016113281,307.0936279296875,347.2339782714844,-12.360522270202637,308.20281982421875,342.0711975097656,-11.197815895080566,282.26275634765625,342.27349853515625,-6.5559587478637695,280.1040344238281,344.2525634765625,-7.676806926727295,276.89044189453125,348.6038513183594,-8.685104370117188,273.98187255859375,354.4639892578125,-7.716130256652832,256.96429443359375,315.8611145019531,-7.173637390136719,156.67434692382812,268.1974182128906,61.823402404785156,321.67657470703125,279.9446105957031,-21.204376220703125,274.7763671875,342.8690490722656,-3.4922499656677246,271.748291015625,343.65057373046875,-4.173834800720215,300.82440185546875,285.601806640625,-15.708353042602539,275.4014892578125,281.88909912109375,-9.427604675292969,298.0133056640625,282.04547119140625,-15.658348083496094,257.8790588378906,228.18124389648438,-2.3751800060272217,234.48097229003906,239.43783569335938,-.8608551621437073,266.601318359375,263.881103515625,-11.564746856689453,193.27264404296875,79.32144165039062,13.976980209350586,203.66551208496094,99.89955139160156,4.993534564971924,214.192626953125,124.35659790039062,-2.3503618240356445,266.8046569824219,368.8791198730469,-3.8713901042938232,280.217041015625,126.4576416015625,-10.782143592834473,274.21429443359375,89.12802124023438,-6.5469970703125,267.3445739746094,54.692535400390625,-2.064028263092041,212.81898498535156,194.91871643066406,6.971029758453369,180.09385681152344,212.29409790039062,15.353899002075195,273.771484375,185.7499237060547,4.228655815124512,192.789306640625,172.89857482910156,9.732086181640625,283.6727600097656,207.76104736328125,-6.431457042694092,280.1270751953125,258.4156799316406,-22.589630126953125,165.6214141845703,224.11279296875,21.64031410217285,190.24551391601562,221.98941040039062,9.924493789672852,209.01893615722656,226.47073364257812,4.510352611541748,236.8439178466797,222.82125854492188,1.8049453496932983,257.20220947265625,215.456787109375,.6790369749069214,272.492431640625,207.42327880859375,-.8617515563964844,303.6573181152344,185.8953857421875,-12.504512786865234,168.3778076171875,256.185791015625,19.68412971496582,181.09927368164062,171.31813049316406,12.517826080322266,313.75042724609375,275.7742919921875,-28.656028747558594,274.2816162109375,233.32928466796875,-6.912413597106934,152.38613891601562,198.63865661621094,58.12936782836914,283.8626403808594,198.5483856201172,-1.6045750379562378,265.49407958984375,265.3607177734375,-5.484303951263428,200.5620574951172,182.45314025878906,11.547853469848633,278.98931884765625,248.54299926757812,-20.185150146484375,162.0050048828125,305.53851318359375,58.60392379760742,272.994140625,180.28761291503906,5.834909915924072,292.3125915527344,238.79739379882812,-25.972232818603516,202.45433044433594,379.2152099609375,20.797351837158203,204.62899780273438,398.7668762207031,30.881372451782227,156.33914184570312,262.9945373535156,40.65882110595703,184.59329223632812,358.08984375,28.37997055053711,161.83724975585938,166.27520751953125,32.74825668334961,264.6654357910156,433.0896301269531,1.4305986166000366,315.250244140625,279.32794189453125,-20.81725311279297,261.2689208984375,245.606689453125,-4.830883979797363,166.9665069580078,195.82589721679688,24.034517288208008,225.92388916015625,187.05523681640625,5.200074195861816,238.94944763183594,187.44232177734375,3.7697904109954834,264.1736145019531,349.2875061035156,-3.1675024032592773,171.58206176757812,287.9273376464844,21.306987762451172,293.95599365234375,457.10064697265625,2.6667895317077637,246.57467651367188,434.9912109375,14.810300827026367,226.7908172607422,419.973388671875,21.8872013092041,315.3326416015625,88.80404663085938,-7.664234161376953,327.2855224609375,459.603759765625,1.0371936559677124,251.32020568847656,185.9434814453125,3.591391086578369,262.6206359863281,183.20826721191406,4.425485134124756,269.65252685546875,181.5925750732422,5.718056678771973,171.45248413085938,168.89012145996094,18.5508975982666,260.152099609375,172.79396057128906,3.693479537963867,247.5819549560547,170.77157592773438,2.508162260055542,235.03382873535156,170.6088409423828,2.6751668453216553,222.2652587890625,173.05519104003906,4.039044380187988,213.94973754882812,176.4881591796875,5.945765972137451,153.9766845703125,161.3706817626953,49.039398193359375,216.9583282470703,185.66758728027344,7.032083511352539,322.1541442871094,297.5083312988281,-16.00879669189453,269.7311706542969,305.6127624511719,-10.331046104431152,281.48126220703125,270.48370361328125,-16.717947006225586,300.04461669921875,299.4017333984375,-15.656883239746094,317.66339111328125,164.8524627685547,-10.237009048461914,222.44737243652344,400.28460693359375,14.630343437194824,242.59323120117188,416.992431640625,8.299786567687988,292.862060546875,443.7979736328125,-4.521420001983643,187.72213745117188,375.5125427246094,41.960391998291016,268.95684814453125,176.8852081298828,4.970767021179199,294.11273193359375,210.64590454101562,-14.587058067321777,327.2318115234375,446.44342041015625,-5.906525611877441,268.2618408203125,448.0268859863281,7.456300258636475,161.5745849609375,297.48333740234375,39.41569519042969,294.0351257324219,341.7873840332031,-9.140814781188965,291.95458984375,345.6842956542969,-10.367130279541016,289.845947265625,352.1710205078125,-11.577893257141113,288.1461486816406,361.09893798828125,-11.053465843200684,283.66680908203125,377.870361328125,-7.087894439697266,270.8735046386719,342.74639892578125,-4.103464603424072,266.14617919921875,341.66937255859375,-4.162796974182129,261.54791259765625,339.3941345214844,-4.1746826171875,246.18902587890625,329.3245849609375,-2.961322546005249,190.56277465820312,294.2333984375,9.390547752380371,293.86993408203125,195.8378448486328,-9.012523651123047,285.0931091308594,169.88436889648438,1.7015331983566284,275.52679443359375,172.66934204101562,3.9000771045684814,274.2338562011719,340.83880615234375,-3.529534101486206,189.50616455078125,333.734619140625,17.67523956298828,298.2148742675781,168.2777862548828,-6.0877814292907715,275.1707458496094,395.8807373046875,-4.150460243225098,319.609375,213.20645141601562,-25.531686782836914,304.7801818847656,201.61163330078125,-18.585384368896484,318.9832458496094,197.57528686523438,-19.884870529174805,283.4682312011719,235.45059204101562,-14.688872337341309,326.6484069824219,427.47015380859375,-9.102132797241211,325.87774658203125,404.880126953125,-8.94002914428711,299.8717041015625,403.94073486328125,-7.80373477935791,238.68128967285156,367.0010986328125,2.7526659965515137,253.98707580566406,278.80322265625,-4.358704566955566,255.34938049316406,383.8130798339844,-.5109075903892517,221.5740203857422,278.1018981933594,-1.8077586889266968,241.415771484375,295.5854797363281,-3.5574092864990234,209.53550720214844,304.8381042480469,2.743500232696533,294.94976806640625,425.327880859375,-7.4867353439331055,274.0611572265625,244.91165161132812,-10.546663284301758,226.30633544921875,380.7353515625,8.176047325134277,246.79827880859375,398.94097900390625,3.8866376876831055,225.9365234375,347.2131042480469,3.8363399505615234,175.85333251953125,315.1534729003906,23.08595848083496,207.78817749023438,350.5667724609375,9.71776008605957,169.63876342773438,329.195556640625,36.44424057006836,230.44189453125,317.53167724609375,-.9267317652702332,284.35980224609375,221.7354736328125,-10.449814796447754,285.5650634765625,264.9780578613281,-23.92240333557129,274.9562683105469,269.5750732421875,-17.530813217163086,292.2945861816406,254.3388671875,-28.237804412841797,273.01220703125,158.96517944335938,-.09002730250358582,248.7141571044922,152.65328979492188,-1.389674425125122,227.8582763671875,151.95883178710938,-1.2474606037139893,210.54685974121094,154.68576049804688,1.0268592834472656,198.41705322265625,161.3450469970703,4.723947048187256,191.10504150390625,186.9726104736328,13.84589958190918,153.60556030273438,229.93136596679688,39.786155700683594,202.93617248535156,206.47616577148438,9.13370418548584,218.19210815429688,209.81057739257812,5.49985933303833,237.618408203125,208.71490478515625,3.108225107192993,256.08367919921875,204.24436950683594,2.2745330333709717,270.3304138183594,198.43910217285156,2.0658209323883057,280.03753662109375,192.8920440673828,1.8290718793869019,154.55300903320312,233.4366455078125,61.95684814453125,275.45025634765625,273.9498596191406,-14.600406646728516,294.47747802734375,224.07571411132812,-19.41942596435547,297.1092529296875,265.4220275878906,-28.585128784179688,305.83050537109375,273.2985534667969,-26.266172409057617,297.0882568359375,268.02960205078125,-25.710546493530273,280.0792236328125,278.9830322265625,-12.655070304870605,308.76202392578125,274.71514892578125,-27.840410232543945,310.0816345214844,278.26849365234375,-20.86105728149414,278.5430603027344,181.00303649902344,4.947571754455566,287.54656982421875,184.307861328125,1.260591745376587,292.3014831542969,186.36598205566406,-3.143568992614746,209.09744262695312,179.09437561035156,7.914038181304932,201.1513214111328,174.12767028808594,8.084104537963867,332.9224853515625,215.6724853515625,-23.370018005371094,424.55767822265625,180.68113708496094,9.830978393554688,336.6293640136719,275.2829284667969,-20.78504180908203,469.8965148925781,125.57901000976562,38.99407958984375,382.28717041015625,192.43331909179688,3.4612600803375244,396.9390869140625,193.86790466308594,3.8914084434509277,411.00787353515625,193.62002563476562,5.549503803253174,429.71795654296875,186.66195678710938,10.617892265319824,370.05230712890625,188.40982055664062,3.9252419471740723,401.5653991699219,158.86630249023438,1.4472987651824951,386.22540283203125,159.340087890625,1.508786678314209,415.85626220703125,160.82952880859375,3.381333351135254,425.4224853515625,165.43167114257812,5.918134689331055,440.8648986816406,196.23458862304688,13.489381790161133,383.5614013671875,412.1856689453125,-1.2763981819152832,429.66766357421875,177.68446350097656,11.750621795654297,478.7536926269531,191.44679260253906,40.292274475097656,456.2593688964844,187.05970764160156,19.656951904296875,396.70855712890625,255.54208374023438,-3.1392972469329834,342.8689270019531,320.60870361328125,-16.659250259399414,340.4381408691406,337.6176452636719,-13.7393217086792,363.13134765625,325.23089599609375,-12.994629859924316,375.7514953613281,331.7568359375,-8.478598594665527,355.1566162109375,338.01800537109375,-11.234922409057617,366.4199523925781,339.488037109375,-7.100727081298828,394.68389892578125,356.0306396484375,.13269051909446716,334.7259216308594,267.0843811035156,-31.326902389526367,336.2799377441406,251.33706665039062,-33.022640228271484,446.9028625488281,149.9997100830078,7.749013900756836,365.2566833496094,216.65200805664062,-3.8045411109924316,371.8299865722656,262.5707702636719,-16.28518295288086,372.3122253417969,254.44293212890625,-14.348434448242188,439.06005859375,254.14584350585938,4.803002834320068,334.6656799316406,231.83706665039062,-29.320056915283203,412.4833679199219,134.77537536621094,-2.8003480434417725,432.9185485839844,139.5846405029297,1.896531343460083,456.6582336425781,97.67573547363281,27.524517059326172,348.30828857421875,146.11997985839844,-8.290468215942383,372.6208801269531,162.8184356689453,3.228713274002075,406.0555419921875,341.1844787597656,2.0252270698547363,469.9366149902344,338.3891296386719,53.86491394042969,360.842041015625,271.5228271484375,-14.121028900146484,347.8482360839844,277.2429504394531,-15.139877319335938,389.7527770996094,341.73504638671875,1.3748646974563599,382.7810974121094,340.7091064453125,-.3233203589916229,440.296630859375,129.44049072265625,5.1410088539123535,372.5621643066406,269.7780456542969,-13.115525245666504,384.7712707519531,135.73818969726562,-6.309181213378906,387.2312316894531,122.5787353515625,-7.326788425445557,399.4652099609375,60.144744873046875,4.721075057983398,448.0954895019531,112.34931945800781,14.905879974365234,391.7792663574219,89.46018981933594,-1.5736668109893799,454.69744873046875,143.20791625976562,13.139555931091309,462.18414306640625,134.90118408203125,25.395933151245117,342.05596923828125,330.6085510253906,-15.849852561950684,358.6634216308594,333.08514404296875,-12.385476112365723,371.0511474609375,335.9906005859375,-8.29167366027832,356.9338073730469,274.68096923828125,-13.09109878540039,386.1968078613281,341.385986328125,.4633089601993561,379.505615234375,343.56292724609375,-3.58079195022583,380.99072265625,339.9813537597656,-.56928950548172,351.92706298828125,266.1675109863281,-22.411170959472656,363.1768798828125,338.68280029296875,-6.149283409118652,351.8752136230469,338.9214782714844,-8.935256958007812,338.43121337890625,339.7230224609375,-11.266111373901367,345.47833251953125,383.5452880859375,-8.54257869720459,343.7301940917969,364.6892395019531,-13.523378372192383,342.5115051269531,354.8351135253906,-13.84434986114502,341.0390930175781,346.5924072265625,-12.141350746154785,339.55938720703125,341.4112854003906,-11.004034996032715,365.00738525390625,340.4651794433594,-6.095052242279053,367.36639404296875,342.3319396972656,-7.191629409790039,370.9842224121094,346.59893798828125,-8.184698104858398,374.2361755371094,352.38916015625,-7.224337100982666,388.0760803222656,312.992431640625,-6.49540376663208,480.3379821777344,261.6239013671875,63.763389587402344,372.50164794921875,340.673095703125,-2.910421848297119,375.647216796875,341.3985290527344,-3.5980868339538574,342.5552673339844,284.8035583496094,-15.550444602966309,367.3857421875,280.0863342285156,-9.014886856079102,345.03631591796875,281.2030029296875,-15.500083923339844,381.04669189453125,225.75692749023438,-1.7069110870361328,404.9681091308594,236.08831787109375,-.008579621091485023,374.9254150390625,261.70758056640625,-11.010907173156738,434.6033935546875,75.28443145751953,15.280303001403809,425.8450927734375,96.6444091796875,6.181840419769287,417.2605285644531,121.89888000488281,-1.3361674547195435,381.77252197265625,366.4750061035156,-3.2928552627563477,352.6125793457031,125.71281433105469,-10.41528606414795,356.1432189941406,87.92901611328125,-6.096003532409668,360.54925537109375,53.24565887451172,-1.6013318300247192,423.0085144042969,191.4607391357422,8.192007064819336,455.9168701171875,207.06011962890625,16.840869903564453,362.320556640625,184.3780059814453,4.786047458648682,441.0181579589844,169.07571411132812,11.076071739196777,354.32940673828125,206.4979248046875,-6.017457962036133,361.7270812988281,256.7944030761719,-22.147241592407227,470.78857421875,218.2230224609375,23.366037368774414,446.9043884277344,217.05377197265625,11.335209846496582,428.977783203125,222.14804077148438,5.704945087432861,401.39324951171875,219.66403198242188,2.709503650665283,380.70123291015625,213.15652465820312,1.3608025312423706,365.122802734375,205.7574920654297,-.3050336539745331,333.2375793457031,185.38961791992188,-12.339582443237305,470.42559814453125,250.09902954101562,21.368783950805664,452.41015625,166.84707641601562,14.01742935180664,329.67291259765625,275.4928894042969,-28.54446029663086,365.2168884277344,231.57791137695312,-6.41494607925415,480.26104736328125,192.2894287109375,60.1459846496582,353.3818359375,197.30165100097656,-1.2043124437332153,375.92144775390625,263.09228515625,-4.952785968780518,434.0610656738281,178.89532470703125,12.865796089172363,362.0376892089844,246.83267211914062,-19.729684829711914,477.7235412597656,299.0860290527344,60.44133758544922,362.7712707519531,178.93336486816406,6.433119297027588,348.4642639160156,237.6964111328125,-25.6434268951416,444.9437255859375,374.3408203125,22.08431625366211,443.3897399902344,393.920654296875,32.19438171386719,481.78631591796875,256.505615234375,42.56291961669922,460.74566650390625,352.44598388671875,29.870811462402344,470.4197998046875,160.69410705566406,34.579654693603516,387.6665344238281,430.642333984375,2.0062272548675537,328.07861328125,279.17724609375,-20.75840950012207,378.8198547363281,243.26248168945312,-4.24747371673584,467.50250244140625,190.25503540039062,25.744525909423828,409.82464599609375,184.141357421875,6.231921195983887,397.0033264160156,185.0110321044922,4.7111334800720215,383.4640197753906,346.753662109375,-2.522388458251953,469.2848205566406,281.7126159667969,22.92217445373535,360.1937255859375,455.74932861328125,2.9791202545166016,405.12158203125,431.91900634765625,15.62734603881836,423.4313049316406,416.1868591308594,22.959041595458984,384.67138671875,183.9629364013672,4.3632402420043945,373.213623046875,181.48912048339844,5.123116970062256,366.1402893066406,180.15541076660156,6.310164928436279,461.6444091796875,163.96163940429688,20.155040740966797,374.98333740234375,171.23558044433594,4.387862682342529,387.49774169921875,168.8740692138672,3.304352283477783,399.94378662109375,168.39108276367188,3.634413242340088,412.6290588378906,170.36415100097656,5.1217498779296875,420.96893310546875,173.51547241210938,7.114045143127441,476.9218444824219,155.16864013671875,50.95864486694336,418.4987487792969,182.4808807373047,8.162747383117676,374.7021179199219,303.31707763671875,-9.819207191467285,360.9924621582031,268.89068603515625,-16.321969985961914,344.3481140136719,298.4349365234375,-15.438346862792969,426.8325500488281,396.30877685546875,15.641507148742676,408.3316955566406,413.7490539550781,9.129907608032227,360.76519775390625,442.39337158203125,-4.226146221160889,457.8586120605469,370.0028991699219,43.47062301635742,366.5082092285156,175.42959594726562,5.558383464813232,344.51177978515625,209.68707275390625,-14.27273941040039,384.7861022949219,445.6679382324219,8.124580383300781,478.9347229003906,290.98956298828125,41.21711349487305,353.3740539550781,340.5323486328125,-8.78250789642334,355.8246154785156,344.3572082519531,-9.997100830078125,358.39141845703125,350.72332763671875,-11.240950584411621,360.680419921875,359.6910400390625,-10.636283874511719,365.86053466796875,376.1639099121094,-6.660977363586426,376.22296142578125,340.27056884765625,-3.5048739910125732,380.8910217285156,339.0758972167969,-3.475714921951294,385.29180908203125,336.63427734375,-3.401749610900879,399.6767883300781,325.93450927734375,-2.128159523010254,451.57861328125,288.81036376953125,10.718208312988281,343.4667053222656,194.96011352539062,-8.735547065734863,350.09100341796875,169.0031280517578,2.0712971687316895,359.6502990722656,171.5241241455078,4.450891017913818,372.62359619140625,338.539794921875,-2.956547975540161,454.8492431640625,328.1819152832031,19.078685760498047,337.1347351074219,167.7401123046875,-5.871736526489258,375.0529479980469,393.76483154296875,-3.6778383255004883,333.4227294921875,201.0952911376953,-18.425695419311523,356.4927062988281,234.01895141601562,-14.301460266113281,351.2936706542969,402.79620361328125,-7.5585551261901855,409.10919189453125,363.5516357421875,3.57236647605896,388.25555419921875,276.1095275878906,-3.709625244140625,393.75286865234375,380.920166015625,.1369001269340515,420.40191650390625,273.9984436035156,-.8729774355888367,401.9803161621094,292.1586608886719,-2.742661714553833,433.86163330078125,300.2438659667969,3.79644513130188,357.5480041503906,424.0931091308594,-7.21943998336792,366.2776184082031,243.02346801757812,-10.05320930480957,422.03759765625,376.86553955078125,9.139190673828125,403.22271728515625,395.7782897949219,4.615209102630615,420.5649108886719,343.19183349609375,4.793065071105957,466.7944641113281,309.1900329589844,24.664592742919922,438.3085021972656,345.8584899902344,10.867822647094727,473.22900390625,323.0245361328125,38.14845275878906,414.3385925292969,313.6124267578125,.012857065536081791,354.69293212890625,220.4129638671875,-10.033292770385742,356.8241271972656,263.5083312988281,-23.556297302246094,367.4049072265625,267.6433410644531,-17.09963607788086,349.74609375,253.279541015625,-27.92021942138672,361.42388916015625,157.93853759765625,.41821685433387756,385.1235046386719,150.96600341796875,-.6607803106307983,405.5707702636719,149.6215057373047,-.3118784427642822,422.8327941894531,151.75064086914062,2.1794090270996094,434.8728332519531,158.0150146484375,5.985780239105225,443.5646667480469,182.8747100830078,15.249552726745605,482.15576171875,223.59829711914062,41.767704010009766,433.39141845703125,202.36753845214844,10.402255058288574,418.7890625,206.17379760742188,6.606390953063965,399.58636474609375,205.84176635742188,4.021158218383789,381.0849609375,202.08261108398438,3.0047805309295654,366.6188659667969,196.7928924560547,2.618781566619873,356.5893859863281,191.5957794189453,2.271151542663574,480.2386474609375,226.94879150390625,63.96815872192383,367.0486755371094,272.0451965332031,-14.173871994018555,345.1959228515625,223.20333862304688,-19.10439682006836,345.7338562011719,264.4343566894531,-28.369665145874023,337.3208312988281,272.7472839355469,-26.105701446533203,345.6841125488281,267.1420593261719,-25.44144630432129,362.701171875,277.2493591308594,-12.29609489440918,334.5038757324219,274.249267578125,-27.719623565673828,333.1357727050781,277.93988037109375,-20.768848419189453,357.30718994140625,179.84762573242188,5.402637004852295,348.57269287109375,183.3765869140625,1.6270942687988281,344.1528015136719,185.49330139160156,-2.848400592803955,425.8621520996094,175.94349670410156,9.125075340270996,432.9592590332031,170.6381378173828,9.381414413452148];/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rk=[127,34,139,11,0,37,232,231,120,72,37,39,128,121,47,232,121,128,104,69,67,175,171,148,157,154,155,118,50,101,73,39,40,9,151,108,48,115,131,194,204,211,74,40,185,80,42,183,40,92,186,230,229,118,202,212,214,83,18,17,76,61,146,160,29,30,56,157,173,106,204,194,135,214,192,203,165,98,21,71,68,51,45,4,144,24,23,77,146,91,205,50,187,201,200,18,91,106,182,90,91,181,85,84,17,206,203,36,148,171,140,92,40,39,193,189,244,159,158,28,247,246,161,236,3,196,54,68,104,193,168,8,117,228,31,189,193,55,98,97,99,126,47,100,166,79,218,155,154,26,209,49,131,135,136,150,47,126,217,223,52,53,45,51,134,211,170,140,67,69,108,43,106,91,230,119,120,226,130,247,63,53,52,238,20,242,46,70,156,78,62,96,46,53,63,143,34,227,173,155,133,123,117,111,44,125,19,236,134,51,216,206,205,154,153,22,39,37,167,200,201,208,36,142,100,57,212,202,20,60,99,28,158,157,35,226,113,160,159,27,204,202,210,113,225,46,43,202,204,62,76,77,137,123,116,41,38,72,203,129,142,64,98,240,49,102,64,41,73,74,212,216,207,42,74,184,169,170,211,170,149,176,105,66,69,122,6,168,123,147,187,96,77,90,65,55,107,89,90,180,101,100,120,63,105,104,93,137,227,15,86,85,129,102,49,14,87,86,55,8,9,100,47,121,145,23,22,88,89,179,6,122,196,88,95,96,138,172,136,215,58,172,115,48,219,42,80,81,195,3,51,43,146,61,171,175,199,81,82,38,53,46,225,144,163,110,246,33,7,52,65,66,229,228,117,34,127,234,107,108,69,109,108,151,48,64,235,62,78,191,129,209,126,111,35,143,163,161,246,117,123,50,222,65,52,19,125,141,221,55,65,3,195,197,25,7,33,220,237,44,70,71,139,122,193,245,247,130,33,71,21,162,153,158,159,170,169,150,188,174,196,216,186,92,144,160,161,2,97,167,141,125,241,164,167,37,72,38,12,145,159,160,38,82,13,63,68,71,226,35,111,158,153,154,101,50,205,206,92,165,209,198,217,165,167,97,220,115,218,133,112,243,239,238,241,214,135,169,190,173,133,171,208,32,125,44,237,86,87,178,85,86,179,84,85,180,83,84,181,201,83,182,137,93,132,76,62,183,61,76,184,57,61,185,212,57,186,214,207,187,34,143,156,79,239,237,123,137,177,44,1,4,201,194,32,64,102,129,213,215,138,59,166,219,242,99,97,2,94,141,75,59,235,24,110,228,25,130,226,23,24,229,22,23,230,26,22,231,112,26,232,189,190,243,221,56,190,28,56,221,27,28,222,29,27,223,30,29,224,247,30,225,238,79,20,166,59,75,60,75,240,147,177,215,20,79,166,187,147,213,112,233,244,233,128,245,128,114,188,114,217,174,131,115,220,217,198,236,198,131,134,177,132,58,143,35,124,110,163,7,228,110,25,356,389,368,11,302,267,452,350,349,302,303,269,357,343,277,452,453,357,333,332,297,175,152,377,384,398,382,347,348,330,303,304,270,9,336,337,278,279,360,418,262,431,304,408,409,310,415,407,270,409,410,450,348,347,422,430,434,313,314,17,306,307,375,387,388,260,286,414,398,335,406,418,364,367,416,423,358,327,251,284,298,281,5,4,373,374,253,307,320,321,425,427,411,421,313,18,321,405,406,320,404,405,315,16,17,426,425,266,377,400,369,322,391,269,417,465,464,386,257,258,466,260,388,456,399,419,284,332,333,417,285,8,346,340,261,413,441,285,327,460,328,355,371,329,392,439,438,382,341,256,429,420,360,364,394,379,277,343,437,443,444,283,275,440,363,431,262,369,297,338,337,273,375,321,450,451,349,446,342,467,293,334,282,458,461,462,276,353,383,308,324,325,276,300,293,372,345,447,382,398,362,352,345,340,274,1,19,456,248,281,436,427,425,381,256,252,269,391,393,200,199,428,266,330,329,287,273,422,250,462,328,258,286,384,265,353,342,387,259,257,424,431,430,342,353,276,273,335,424,292,325,307,366,447,345,271,303,302,423,266,371,294,455,460,279,278,294,271,272,304,432,434,427,272,407,408,394,430,431,395,369,400,334,333,299,351,417,168,352,280,411,325,319,320,295,296,336,319,403,404,330,348,349,293,298,333,323,454,447,15,16,315,358,429,279,14,15,316,285,336,9,329,349,350,374,380,252,318,402,403,6,197,419,318,319,325,367,364,365,435,367,397,344,438,439,272,271,311,195,5,281,273,287,291,396,428,199,311,271,268,283,444,445,373,254,339,263,466,249,282,334,296,449,347,346,264,447,454,336,296,299,338,10,151,278,439,455,292,407,415,358,371,355,340,345,372,390,249,466,346,347,280,442,443,282,19,94,370,441,442,295,248,419,197,263,255,359,440,275,274,300,383,368,351,412,465,263,467,466,301,368,389,380,374,386,395,378,379,412,351,419,436,426,322,373,390,388,2,164,393,370,462,461,164,0,267,302,11,12,374,373,387,268,12,13,293,300,301,446,261,340,385,384,381,330,266,425,426,423,391,429,355,437,391,327,326,440,457,438,341,382,362,459,457,461,434,430,394,414,463,362,396,369,262,354,461,457,316,403,402,315,404,403,314,405,404,313,406,405,421,418,406,366,401,361,306,408,407,291,409,408,287,410,409,432,436,410,434,416,411,264,368,383,309,438,457,352,376,401,274,275,4,421,428,262,294,327,358,433,416,367,289,455,439,462,370,326,2,326,370,305,460,455,254,449,448,255,261,446,253,450,449,252,451,450,256,452,451,341,453,452,413,464,463,441,413,414,258,442,441,257,443,442,259,444,443,260,445,444,467,342,445,459,458,250,289,392,290,290,328,460,376,433,435,250,290,392,411,416,433,341,463,464,453,464,465,357,465,412,343,412,399,360,363,440,437,399,456,420,456,363,401,435,288,372,383,353,339,255,249,448,261,255,133,243,190,133,155,112,33,246,247,33,130,25,398,384,286,362,398,414,362,463,341,263,359,467,263,249,255,466,467,260,75,60,166,238,239,79,162,127,139,72,11,37,121,232,120,73,72,39,114,128,47,233,232,128,103,104,67,152,175,148,173,157,155,119,118,101,74,73,40,107,9,108,49,48,131,32,194,211,184,74,185,191,80,183,185,40,186,119,230,118,210,202,214,84,83,17,77,76,146,161,160,30,190,56,173,182,106,194,138,135,192,129,203,98,54,21,68,5,51,4,145,144,23,90,77,91,207,205,187,83,201,18,181,91,182,180,90,181,16,85,17,205,206,36,176,148,140,165,92,39,245,193,244,27,159,28,30,247,161,174,236,196,103,54,104,55,193,8,111,117,31,221,189,55,240,98,99,142,126,100,219,166,218,112,155,26,198,209,131,169,135,150,114,47,217,224,223,53,220,45,134,32,211,140,109,67,108,146,43,91,231,230,120,113,226,247,105,63,52,241,238,242,124,46,156,95,78,96,70,46,63,116,143,227,116,123,111,1,44,19,3,236,51,207,216,205,26,154,22,165,39,167,199,200,208,101,36,100,43,57,202,242,20,99,56,28,157,124,35,113,29,160,27,211,204,210,124,113,46,106,43,204,96,62,77,227,137,116,73,41,72,36,203,142,235,64,240,48,49,64,42,41,74,214,212,207,183,42,184,210,169,211,140,170,176,104,105,69,193,122,168,50,123,187,89,96,90,66,65,107,179,89,180,119,101,120,68,63,104,234,93,227,16,15,85,209,129,49,15,14,86,107,55,9,120,100,121,153,145,22,178,88,179,197,6,196,89,88,96,135,138,136,138,215,172,218,115,219,41,42,81,5,195,51,57,43,61,208,171,199,41,81,38,224,53,225,24,144,110,105,52,66,118,229,117,227,34,234,66,107,69,10,109,151,219,48,235,183,62,191,142,129,126,116,111,143,7,163,246,118,117,50,223,222,52,94,19,141,222,221,65,196,3,197,45,220,44,156,70,139,188,122,245,139,71,162,145,153,159,149,170,150,122,188,196,206,216,92,163,144,161,164,2,167,242,141,241,0,164,37,11,72,12,144,145,160,12,38,13,70,63,71,31,226,111,157,158,154,36,101,205,203,206,165,126,209,217,98,165,97,237,220,218,237,239,241,210,214,169,140,171,32,241,125,237,179,86,178,180,85,179,181,84,180,182,83,181,194,201,182,177,137,132,184,76,183,185,61,184,186,57,185,216,212,186,192,214,187,139,34,156,218,79,237,147,123,177,45,44,4,208,201,32,98,64,129,192,213,138,235,59,219,141,242,97,97,2,141,240,75,235,229,24,228,31,25,226,230,23,229,231,22,230,232,26,231,233,112,232,244,189,243,189,221,190,222,28,221,223,27,222,224,29,223,225,30,224,113,247,225,99,60,240,213,147,215,60,20,166,192,187,213,243,112,244,244,233,245,245,128,188,188,114,174,134,131,220,174,217,236,236,198,134,215,177,58,156,143,124,25,110,7,31,228,25,264,356,368,0,11,267,451,452,349,267,302,269,350,357,277,350,452,357,299,333,297,396,175,377,381,384,382,280,347,330,269,303,270,151,9,337,344,278,360,424,418,431,270,304,409,272,310,407,322,270,410,449,450,347,432,422,434,18,313,17,291,306,375,259,387,260,424,335,418,434,364,416,391,423,327,301,251,298,275,281,4,254,373,253,375,307,321,280,425,411,200,421,18,335,321,406,321,320,405,314,315,17,423,426,266,396,377,369,270,322,269,413,417,464,385,386,258,248,456,419,298,284,333,168,417,8,448,346,261,417,413,285,326,327,328,277,355,329,309,392,438,381,382,256,279,429,360,365,364,379,355,277,437,282,443,283,281,275,363,395,431,369,299,297,337,335,273,321,348,450,349,359,446,467,283,293,282,250,458,462,300,276,383,292,308,325,283,276,293,264,372,447,346,352,340,354,274,19,363,456,281,426,436,425,380,381,252,267,269,393,421,200,428,371,266,329,432,287,422,290,250,328,385,258,384,446,265,342,386,387,257,422,424,430,445,342,276,422,273,424,306,292,307,352,366,345,268,271,302,358,423,371,327,294,460,331,279,294,303,271,304,436,432,427,304,272,408,395,394,431,378,395,400,296,334,299,6,351,168,376,352,411,307,325,320,285,295,336,320,319,404,329,330,349,334,293,333,366,323,447,316,15,315,331,358,279,317,14,316,8,285,9,277,329,350,253,374,252,319,318,403,351,6,419,324,318,325,397,367,365,288,435,397,278,344,439,310,272,311,248,195,281,375,273,291,175,396,199,312,311,268,276,283,445,390,373,339,295,282,296,448,449,346,356,264,454,337,336,299,337,338,151,294,278,455,308,292,415,429,358,355,265,340,372,388,390,466,352,346,280,295,442,282,354,19,370,285,441,295,195,248,197,457,440,274,301,300,368,417,351,465,251,301,389,385,380,386,394,395,379,399,412,419,410,436,322,387,373,388,326,2,393,354,370,461,393,164,267,268,302,12,386,374,387,312,268,13,298,293,301,265,446,340,380,385,381,280,330,425,322,426,391,420,429,437,393,391,326,344,440,438,458,459,461,364,434,394,428,396,262,274,354,457,317,316,402,316,315,403,315,314,404,314,313,405,313,421,406,323,366,361,292,306,407,306,291,408,291,287,409,287,432,410,427,434,411,372,264,383,459,309,457,366,352,401,1,274,4,418,421,262,331,294,358,435,433,367,392,289,439,328,462,326,94,2,370,289,305,455,339,254,448,359,255,446,254,253,449,253,252,450,252,256,451,256,341,452,414,413,463,286,441,414,286,258,441,258,257,442,257,259,443,259,260,444,260,467,445,309,459,250,305,289,290,305,290,460,401,376,435,309,250,392,376,411,433,453,341,464,357,453,465,343,357,412,437,343,399,344,360,440,420,437,456,360,420,363,361,401,288,265,372,353,390,339,249,339,448,255];function Ck(r,e){const t=r.load(e);t.encoding=Or,t.anisotropy=16;const n=.5;return new qn({map:t,transparent:!0,color:new Le(16777215),reflectivity:n})}function Lk(r,e){let t=window.innerWidth,n=window.innerHeight;const s=e.videoWidth,i=e.videoHeight,a=new lc,o=new lc,c=new n2(e),l=new $t(new Di(s,i),new qn({map:c}));l.position.set(0,0,-1e3),a.add(l);const u=l.clone();o.add(u);const h=new Pa(t/-2,t/2,n/2,n/-2,.1,1100);h.position.set(0,0,100),h.lookAt(a.position);const d=new dt({canvas:r,alpha:!0,antialias:!0});d.setPixelRatio(window.devicePixelRatio),d.setSize(t,n);const p=new _2(16777215,16777215,.2);a.add(p);const f=new id(16777215,1);f.position.set(t/2,n/4,-1e3).normalize(),a.add(f);const m=f.clone();m.position.z=1e3,a.add(m);const _=new yt;_.setIndex(Rk),_.setAttribute("position",new Nt(Nk,3)),_.setAttribute("uv",new Nt(Ik.map((k,O)=>O%2?k:1-k),2)),_.computeVertexNormals();const g=new nd,y=new tk;let x=null,w=null;function T(k){const A=U2(k.scaledMesh,s,i).reduce((Y,B)=>Y.concat(B),[]);_.setAttribute("position",new Nt(A,3)),_.attributes.position.needsUpdate=!0}function M(k){var O;if(k){const A=k.annotations;Object.keys(A).forEach(Y=>{A[Y]=U2(A[Y],s,i)}),(x==null?void 0:x.type)==="model"&&((O=x.loader)==null||O.track(w,k)),(x==null?void 0:x.type)==="texture"&&T(k),d.render(a,h)}else d.render(o,h)}function S(){t=window.innerWidth,n=window.innerHeight;const k=t/n,O=s/i,A=k>O?t/s:n/i;a.scale.set(-A,A,1),o.scale.set(-A,A,1),h.top=n/2,h.bottom=n/-2,h.left=t/-2,h.right=t/2,h.updateProjectionMatrix(),d.setSize(t,n)}function R(k){if(w&&a.remove(w),x=k,k.type==="model")w=k.loader.build(y);else if(k.type==="texture"){const O=k.texture?k.texture(g):Ck(g,k.path);w=new $t(_,O)}a.add(w),window.model=w}return[M,S,R]}function U2(r,e,t){return r.map(n=>[n[0]-e/2,t/2-n[1],-n[2]])}function fd(r,e=0,t=1){const n=new L(...r[e]),s=new L(...r[t]);return n.distanceTo(s)}function md(r,e=0,t=1,n=2){const s=new L(...r[e]),i=new L(...r[t]),a=new L(...r[n]),o=new Be,c=i.clone().sub(a).normalize(),l=i.clone().add(a).multiplyScalar(.5).sub(s).multiplyScalar(-1).normalize(),u=new L().crossVectors(c,l).normalize();return o.makeBasis(c,l,u),o.invert()}function kk(r){const e=new it;e.position.set(0,0,0),r.load("/models/stereo-glasses.glb",s=>{s.scene.scale.set(1.1,1.1,-1.1),s.scene.position.set(0,0,0),e.add(s.scene)});const t=new $t(new Di(.5,.25,32),new Ns({color:16762920,transparent:!0,opacity:.5,roughness:.25}));t.position.copy(new L(-.3,-.01,0)),e.add(t);const n=new $t(new Di(.5,.25,32),new Ns({color:11358463,transparent:!0,opacity:.5,roughness:.25}));return n.position.copy(new L(.3,-.01,0)),e.add(n),e}function Dk(r,e){const n=e.annotations.midwayBetweenEyes[0],s=fd(e.scaledMesh,234,454),i=md(e.scaledMesh,10,50,280);r.position.set(...n),r.scale.setScalar(s),r.rotation.setFromRotationMatrix(i),r.rotation.y=-r.rotation.y,r.rotateZ(Math.PI),r.rotateX(-Math.PI*.05)}const Pk={build:kk,track:Dk};function Fk(r){const e=new it;return e.position.set(0,0,0),r.load("/models/zelda_-_breath_of_the_wild/scene.gltf",t=>{t.scene.scale.setScalar(6),t.scene.position.set(-30,-920,-100),e.add(t.scene)}),e}function Ok(r,e){const n=e.annotations.midwayBetweenEyes[0],s=fd(e.scaledMesh,234,454),i=md(e.scaledMesh,10,50,280);r.position.set(...n),r.scale.setScalar(s/100),r.rotation.setFromRotationMatrix(i),r.rotation.y=-r.rotation.y,r.rotateZ(Math.PI),r.rotateX(-Math.PI*.05)}const Bk={build:Fk,track:Ok};function zk(r){const e=new it;return e.position.set(0,0,0),r.load("/models/genshin_impact_barbara/scene.gltf",t=>{t.scene.scale.setScalar(60),t.scene.position.set(0,-1050,-100),t.scene.rotation.y=Math.PI,e.add(t.scene)}),e}function Uk(r,e){const n=e.annotations.midwayBetweenEyes[0],s=fd(e.scaledMesh,234,454),i=md(e.scaledMesh,10,50,280);r.position.set(...n),r.scale.setScalar(s/100),r.rotation.setFromRotationMatrix(i),r.rotation.y=-r.rotation.y,r.rotateZ(Math.PI),r.rotateX(-Math.PI*.05)}const Vk={build:zk,track:Uk};const Hk=Ud({props:{autoSelectFirst:Boolean},setup(r,{emit:e}){const t=[{name:"facepaint",thumb:"/textures/facepaint.png",type:"texture",path:"/textures/facepaint.png"},{name:"cheek",thumb:"/textures/cheek.png",thumbBg:"white",type:"texture",path:"/textures/cheek.png"},{name:"makeup",thumb:"/textures/makeup.png",thumbBg:"white",type:"texture",path:"/textures/makeup.png"},{name:"glasses",thumb:"",type:"model",loader:Pk},{name:"zelda",thumb:"",type:"model",loader:Bk},{name:"barbara",thumb:"",type:"model",loader:Vk}],n=Lc(),s=i=>{n.value=i,e("change",i)};return r.autoSelectFirst&&s(t[0]),{data:t,current:n,onClick:s}}}),$k={class:"gallery"},Gk=["onClick"],Wk={key:1,class:"name"};function jk(r,e,t,n,s,i){return Gs(),Ws("div",$k,[(Gs(!0),Ws(Vd,null,b3(r.data,a=>(Gs(),Ws("div",{key:a.name,class:v3(["item",{active:r.current&&r.current.name===a.name}]),onClick:o=>r.onClick(a)},[a.thumb?(Gs(),Ws("div",{key:0,class:"thumb",style:w3({backgroundImage:`url(${a.thumb})`,backgroundColor:a.thumbBg})},null,4)):(Gs(),Ws("div",Wk,Hd(a.name),1))],10,Gk))),128))])}var qk=zd(Hk,[["render",jk],["__scopeId","data-v-2888beb0"]]);iE("/tfjs-backend-wasm/");aE(2);const Kk=Ud({components:{Gallery:qk},setup(){const r=Lc(!1);let e=null;const t=Lc(s=>{e=s});async function n(){const s=document.getElementById("canvas"),i=document.getElementById("video");await i9("wasm"),console.log("getThreadsCount",oE()),await $v(i);const a=await zv(ma.mediapipeFacemesh,{shouldLoadIrisModel:!1,maxFaces:1}),[o,c,l]=Lk(s,i);t.value=l,e&&(l(e),e=null);async function u(h){const d=await h.estimateFaces({input:i,predictIrises:!1});d.length>0,r.value=d.length>0,o(d[0]),requestAnimationFrame(()=>{u(h)})}c(),u(a),window.onresize=c}return S3(n),T3(()=>{window.onresize=null}),{faceOn:r,onSelectModel:t}}}),V2=r=>(A3("data-v-a72be894"),r=r(),I3(),r),Xk={class:"info"},Yk=V2(()=>kc("video",{id:"video",width:"1",height:"1"},null,-1)),Jk=V2(()=>kc("canvas",{id:"canvas"},null,-1));function Zk(r,e,t,n,s,i){const a=E3("gallery");return Gs(),Ws(Vd,null,[kc("span",Xk,"face "+Hd(r.faceOn?"on":"detecting"),1),Yk,Jk,M3(a,{autoSelectFirst:!0,onChange:r.onSelectModel},null,8,["onChange"])],64)}var gD=zd(Kk,[["render",Zk],["__scopeId","data-v-a72be894"]]);export{gD as default};
